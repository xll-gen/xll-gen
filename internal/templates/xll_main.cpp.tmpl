{{- $gen := . }}
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
// This file contains the main entry point and XLL interface functions.

#include <windows.h>
#include "types/xlcall.h"
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>
#include <filesystem>
#include <sstream>
#include <map>
#include <fstream>
#include "xll_log.h"
#include "xll_path.h"
#include "types/mem.h"
#include "types/converters.h"
#include "types/utility.h"
#include "types/PascalString.h"
#include "xll_launch.h"
#include "xll_worker.h"
#include "xll_cache.h"
#include "xll_embed.h"
#include "xll_events.h"
#include "xll_ipc.h"
#include "xll_lifecycle.h"
#include "SHMAllocator.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
#include "protocol_generated.h"

// Disable "unreferenced formal parameter" warning
#pragma warning(disable: 4100)

using namespace xll;

// Lazy Initialization Globals
std::once_flag g_initFlag;
bool g_isInitialized = false;

// Helper to initialize the runtime (SHM, Server, Threads) safely
void EnsureInitialized() {
    std::call_once(g_initFlag, []() {
        LogInfo("Lazy Initialization started...");

        // Config Data needed for Init
        std::string projName = "{{.ProjectName}}";
        bool isSingleFile = false;
        std::string tempPattern = "";
        {{if eq .Build.Singlefile "xll"}}
        isSingleFile = true;
        tempPattern = "{{.Build.TempDir}}";
        {{end}}

        // Initialize Shared Memory
        std::string shmName = "{{.ProjectName}}";
        {{if not .ShouldAppendPid}}
        // Static name for testing/dev
        {{else}}
        shmName += "_" + std::to_string(GetCurrentProcessId());
        {{end}}

        LogInfo("Initializing Shared Memory: " + shmName);

        // HostConfig: hostSlots, guestSlots.
        shm::HostConfig hostCfg{};
        int workers = {{if .Server.Workers}}{{.Server.Workers}}{{else}}std::thread::hardware_concurrency(){{end}};
        if (workers < 1) workers = 1;
        hostCfg.numHostSlots = workers * 2 + 2;
        hostCfg.numGuestSlots = 2;
        hostCfg.shmName = shmName;
        hostCfg.payloadSize = 1024 * 1024; // 1MB

        // Initialize Host (Allocated if null)
        if (!g_phost) {
            g_phost = new shm::DirectHost();
        }

        auto initRes = g_host.Init(hostCfg);
        if (initRes.HasError()) {
            std::string err = "Failed to initialize shared memory: " + SHMErrorToString(initRes.GetError());
            LogError(err);
            MessageBoxA(NULL, err.c_str(), "XLL Runtime Error", MB_OK | MB_ICONERROR);
            // We do not set g_isInitialized to true, so subsequent calls might retry (or fail again)
            // But call_once only runs once. If it fails, the add-in is broken for this session.
            return;
        }

        // Launch Server Process
        {{if derefBool .Server.Launch.Enabled}}
        // Prepare Launch Config
        LaunchConfig cfg;
        cfg.projectName = L"{{.ProjectName}}";
        cfg.isSingleFile = isSingleFile;
        cfg.cwd = ""; // Default CWD (relative to bindir)
        cfg.command = "{{.Server.Command}}";
        cfg.shmName = shmName;
        {{if eq .Build.Singlefile "xll"}}cfg.tempDir = StringToWString(tempPattern);{{end}}

        std::wstring launchLog;
        if (!LaunchServer(cfg, GetXllDir(), g_procInfo, launchLog)) {
             LogError("Failed to launch server.");
             // Cleanup SHM to be safe? Or keep it open?
             // If server fails, we are broken.
             return;
        }

        // Start Monitor Thread
        if (g_monitorThread.joinable()) g_monitorThread.join();
        g_monitorThread = std::thread(MonitorThread, launchLog);
        {{else}}
        LogInfo("Server launch disabled by configuration.");
        {{end}}

        // Start Worker Thread for Async Results
        xll::StartWorker();

        g_isInitialized = true;
        LogInfo("Lazy Initialization complete.");
    });
}

// XLL Interface Functions

extern "C" __declspec(dllexport) int __stdcall xlAutoOpen() {
    XLL_SAFE_BLOCK_BEGIN
        XLOPER12 xDLL; // Defined here for xlGetName

        // Setup Native Logging (Keep this in xlAutoOpen for debugging init itself)
        std::string tempPattern = "";
    std::string projName = "{{.ProjectName}}";
    bool isSingleFile = false;

    {{if eq .Build.Singlefile "xll"}}
    isSingleFile = true;
    tempPattern = "{{.Build.TempDir}}";
    {{end}}

    std::wstring binDir = GetXllDir();
    {{if eq .Build.Singlefile "xll"}}
    binDir = ExpandEnvVarsW(L"{{.Build.TempDir}}");
    {{end}}

    std::wstring logPath = L"{{.Logging.Dir}}";
    if (logPath == L"XLL_DIR") {
        logPath = GetXllDir() + L"\\{{.ProjectName}}_native.log";
    } else if (logPath == L"TEMP_DIR") {
        logPath = ExpandEnvVarsW(L"${TEMP}") + L"\\{{.ProjectName}}_native.log";
    } else {
        // Support placeholders like ${XLL_DIR}, ${BIN_DIR} and ${TEMP}
        ReplaceAll(logPath, L"${XLL_DIR}", GetXllDir());
        ReplaceAll(logPath, L"${BIN_DIR}", binDir);
        logPath = ExpandEnvVarsW(logPath);

        // If it's a directory (or ends with slash), append default log name
        if (!logPath.empty() && (std::filesystem::is_directory(logPath) || logPath.back() == L'\\' || logPath.back() == L'/')) {
            if (logPath.back() != L'\\' && logPath.back() != L'/') logPath += L"\\";
            logPath += L"{{.ProjectName}}_native.log";
        }
    }

    std::string logInitError;
    if (!InitLog(logPath, "{{.Logging.Level}}", tempPattern, projName, isSingleFile, logInitError)) {
            // If logging fails to initialize, we show a message box but proceed.
            MessageBoxA(NULL, ("Failed to initialize logging: " + logInitError).c_str(), "XLL Initialization Warning", MB_OK | MB_ICONWARNING);
    } else {
            LogInfo("Logging Initialized Successfully. LogPath: " + WideToUtf8(logPath));
    }

#ifdef SHM_DEBUG
    shm::SetLogHandler(LogHandler);
#endif

    LogInfo("xlAutoOpen: Loading XLL...");

    Excel12(xlGetName, &xDLL, 0);

    // Register Events
{{range .Events}}
    Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Handler}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    bool hasCache = {{.Cache.Enabled}};
    {{range .Functions}}
    {{if .Cache}}
    {{if .Cache.Enabled}}
    hasCache = true;
    {{end}}
    {{end}}
    {{end}}

    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded || hasCache) {
            Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }
    {{end}}

    // Register User Functions
{{range $i, $fn := .Functions}}
    {
        // Register {{.Name}}
        int regRes = Excel12(xlfRegister, 0, 10 + {{len .Args}},
            (LPXLOPER12)&xDLL,
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{if .Async}}>{{end}}{{if not .Async}}{{lookupXllType .Return}}{{end}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}$"),
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{range $j, $arg := .Args}}{{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}"),
            TempInt12(1), // Macro type
            TempStr12(L"{{if .Category}}{{.Category}}{{else}}{{$.ProjectName}}{{end}}"),
            TempStr12(L"{{.Shortcut}}"),
            TempStr12(L"{{.HelpTopic}}"),
            TempStr12(L"{{.Description}}"),
            {{range .Args}}TempStr12(L"{{.Description}}"),{{end}}
            0);

        if (regRes != xlretSuccess) {
            LogError("Failed to register function '{{.Name}}'. Code: " + std::to_string(regRes));
        } else {
            LogInfo("Registered function '{{.Name}}' successfully.");
        }
    }
{{end}}

        // Free xDLL
        Excel12(xlFree, 0, 1, (LPXLOPER12)&xDLL);

        LogInfo("xlAutoOpen: Registration complete. Runtime will be initialized on first use.");
        return 1;
    XLL_SAFE_BLOCK_END(0)
}

// Event Handlers
{{range .Events}}
__declspec(dllexport) void __stdcall {{.Handler}}() {
    EnsureInitialized();
    if (!g_isInitialized) return;

    std::vector<uint8_t> respBuf;
    // Construct Request (Event)
    // Currently not fully implemented for named events
    LogInfo("Event {{.Type}} triggered");
}
{{end}}

{{if hasEvent "CalculationEnded" .Events}}
// User defined handler exists
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    EnsureInitialized();
    if (!g_isInitialized) return;
    HandleCalculationEnded();
}
{{end}}

// User Functions
{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupCppArgType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    EnsureInitialized();
    if (!g_isInitialized) {
        {{if .Async}}
        XLOPER12 xErr; xErr.xltype = xltypeErr; xErr.val.err = xlerrValue;
        Excel12(xlAsyncReturn, 0, 2, (LPXLOPER12)asyncHandle, &xErr);
        return;
        {{else}}
        return {{defaultErrorVal .Return}};
        {{end}}
    }

    {{/* Determine Cache Configuration */}}
    {{ $cacheEnabled := $.Cache.Enabled }}
    {{ $ttl := $.Cache.TTL }}
    {{ if .Cache }}
        {{ if .Cache.Enabled }}{{ $cacheEnabled = derefBool .Cache.Enabled }}{{ end }}
        {{ if .Cache.TTL }}{{ $ttl = .Cache.TTL }}{{ end }}
    {{ end }}

    {{if and $cacheEnabled (not .Async)}}
    // Cache Lookup
    xll::CacheConfig cacheConfig;
    cacheConfig.enabled = true;
    cacheConfig.ttl = std::chrono::milliseconds({{parseDurationToMs $ttl}});
    cacheConfig.jitter = std::chrono::milliseconds({{parseDurationToMs $.Cache.Jitter}});

    // Prepare temporary XLOPERs for non-pointer arguments
    std::vector<XLOPER12> tempArgs({{len .Args}});
    std::vector<LPXLOPER12> cacheArgs;
    cacheArgs.reserve({{len .Args}});

    {{range $j, $arg := .Args}}
    {
        XLOPER12& xArg = tempArgs[{{$j}}];
        {{if eq .Type "int"}}
        xArg.xltype = xltypeInt;
        xArg.val.w = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "float"}}
        xArg.xltype = xltypeNum;
        xArg.val.num = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "bool"}}
        xArg.xltype = xltypeBool;
        xArg.val.xbool = {{.Name}} ? 1 : 0;
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "string"}}
        // Convert string to temp XLOPER12 for cache key
        // Use PascalToWString for safe conversion if it is string
        std::wstring s = (({{.Name}}->xltype & xltypeStr) ? PascalToWString({{.Name}}->val.str) : L"");
        xArg = CreateStringXLOPER(s.c_str());
        xArg.xltype |= xlbitDLLFree;
        cacheArgs.push_back(&xArg);
        {{else}}
        // Already a pointer
        cacheArgs.push_back((LPXLOPER12){{.Name}});
        {{end}}
    }
    {{end}}

    std::string cacheKey = xll::MakeCacheKey("{{.Name}}", cacheArgs);

    // Cleanup temporary string allocations
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    delete[] tempArgs[{{$j}}].val.str;
    {{end}}
    {{end}}

    std::vector<uint8_t> cachedData;
    if (xll::CacheManager::Instance().Get(cacheKey, cachedData)) {
        // Deserialize response
        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(cachedData.data());

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
    }
    {{end}}

    // NOTE: 'slot' is declared here using GetZeroCopySlot().
    // SHMAllocator uses it for Zero-Copy Write of the Request.
    auto slot = g_host.GetZeroCopySlot();
    SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
    flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

    // Arguments
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    auto arg{{$j}} = builder.CreateString(({{.Name}}->xltype == xltypeStr) ? ConvertExcelString(PascalToWString({{.Name}}->val.str).c_str()) : "");
    {{else if eq .Type "grid"}}
    auto arg{{$j}} = GridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "numgrid"}}
    auto arg{{$j}} = NumGridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "range"}}
    auto arg{{$j}} = RangeToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "any"}}
    auto arg{{$j}} = AnyToFlatBuffer(builder, {{.Name}});
    {{end}}
    {{end}}

    {{if .Caller}}
    flatbuffers::Offset<protocol::Range> caller_off = 0;
    {
        XLOPER12 xCaller;
        if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
            std::string callerFormat = "";
            XLOPER12 xType; xType.xltype = xltypeInt; xType.val.w = 7;
            XLOPER12 xFormat;
            if (Excel12(xlfGetCell, &xFormat, 2, &xType, &xCaller) == xlretSuccess) {
                if (xFormat.xltype == xltypeStr) {
                        callerFormat = ConvertExcelString(xFormat.val.str);
                }
                Excel12(xlFree, 0, 1, &xFormat);
            }
            caller_off = ConvertRange(&xCaller, builder, callerFormat);
            if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                Excel12(xlFree, 0, 1, &xCaller);
            }
        }
    }
    {{end}}

    {{if .Async}}
    auto asyncHandle_vec = builder.CreateVector((const uint8_t*)asyncHandle, sizeof(XLOPER12));
    {{end}}

    ipc::{{.Name}}RequestBuilder reqBuilder(builder);
    {{range $j, $arg := .Args}}
    {{if or (eq .Type "int") (eq .Type "float") (eq .Type "bool")}}
    reqBuilder.add_{{.Name}}({{if eq .Type "bool"}}({{.Name}} != 0){{else}}{{.Name}}{{end}});
    {{else}}
    reqBuilder.add_{{.Name}}(arg{{$j}});
    {{end}}
    {{end}}

    {{if .Caller}}
    if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
    {{end}}
    {{if .Async}}
    reqBuilder.add_async_handle(asyncHandle_vec);
    {{end}}

    auto req = reqBuilder.Finish();
    builder.Finish(req);

    {{if .Async}}
    // Async Send
    std::vector<uint8_t> dummyResp;
    auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, dummyResp, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.AsyncAckTimeout 2000}}{{end}});
    if (res.HasError()) {
            std::string err = "Async send failed: " + SHMErrorToString(res.GetError());
            LogError(err);
            XLOPER12 xErr;
            xErr.xltype = xltypeErr;
            xErr.val.err = xlerrValue;
            Excel12(xlAsyncReturn, 0, 2, (LPXLOPER12)asyncHandle, &xErr);
            return;
    }
    return;
    {{else}}
    // Sync Send
    std::vector<uint8_t> response;
    auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, response, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.Timeout 2000}}{{end}});

    if (res.HasError()) {
            return {{defaultErrorVal .Return}};
    }

    auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(response.data());

    {{if and $cacheEnabled (not .Async)}}
    // Store in cache
    {
        int32_t respSize = res.Value();
        if (respSize > 0) {
                xll::CacheManager::Instance().Put(cacheKey, response, cacheConfig);
        }
    }
    {{end}}

    {{if eq .Return "string"}}
    std::wstring wres = StringToWString(resp->result()->str());
    return NewExcelString(wres.c_str());
    {{else if eq .Return "int"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeInt;
    xRes.val.w = resp->result();
    return &xRes;
    {{else if eq .Return "float"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeNum;
    xRes.val.num = resp->result();
    return &xRes;
    {{else if eq .Return "bool"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeBool;
    xRes.val.xbool = resp->result() ? 1 : 0;
    return &xRes;
    {{else if eq .Return "any"}}
    return AnyToXLOPER12(resp->result());
    {{else if eq .Return "grid"}}
    return GridToXLOPER12(resp->result());
    {{else if eq .Return "numgrid"}}
    return NumGridToFP12(resp->result());
    {{else if eq .Return "range"}}
    return RangeToXLOPER12(resp->result());
    {{else}}
    return resp->result();
    {{end}}
    {{end}}
}
{{end}}
