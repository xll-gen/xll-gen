
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
#include <windows.h>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <map>
#include <mutex>
#include <sstream>
#include <wchar.h>
#include <random>
#include <iostream>
#include "include/xlcall.h"
#include "include/xll_mem.h"
#include "include/xll_utility.h"
#include "include/xll_ipc.h"
#include "include/xll_converters.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"

std::thread g_worker;
std::atomic<bool> g_running{false};

// Global Process Handle (for auto-launched server)
HANDLE g_hChildProcess = NULL;
HINSTANCE g_hModule = NULL;

// Global Error Value for Returns
static XLOPER12 g_xlErrValue;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);

        // Initialize global error
        g_xlErrValue.xltype = xltypeErr;
        g_xlErrValue.val.err = xlErrValue;
    }
    return TRUE;
}

bool IsSingleCell(LPXLOPER12 xRef) {
    if (!xRef) return false;
    int type = xRef->xltype & ~(xlbitXLFree | xlbitDLLFree);
    if (type == xltypeSRef) {
         const auto& r = xRef->val.sref.ref;
         return (r.rwFirst == r.rwLast && r.colFirst == r.colLast);
    } else if (type == xltypeRef) {
         const auto* m = xRef->val.mref.lpmref;
         if (m && m->count == 1) {
             const auto& r = m->reftbl[0];
             return (r.rwFirst == r.rwLast && r.colFirst == r.colLast);
         }
    }
    return false;
}

void ExecuteCommands(const ipc::CalculationEndedResponse* resp) {
    if (!resp || !resp->commands()) return;
    auto wrappers = resp->commands();
    for (auto it = wrappers->begin(); it != wrappers->end(); ++it) {
        if (it->cmd_type() == ipc::Command_SetCommand) {
            auto cmd = static_cast<const ipc::SetCommand*>(it->cmd());
            LPXLOPER12 xRef = RangeToXLOPER12(cmd->target());
            LPXLOPER12 xVal = AnyToXLOPER12(cmd->value());
            if (xRef && xVal) {
                Excel12(xlSet, 0, 2, xRef, xVal);
            }
            if (xRef) xlAutoFree12(xRef);
            if (xVal) xlAutoFree12(xVal);
        } else if (it->cmd_type() == ipc::Command_FormatCommand) {
            auto cmd = static_cast<const ipc::FormatCommand*>(it->cmd());
            LPXLOPER12 xRef = RangeToXLOPER12(cmd->target());
            if (xRef) {
                bool doFormat = true;
                std::string fmt = cmd->format()->str();
                std::wstring wfmt = StringToWString(fmt);

                if (IsSingleCell(xRef)) {
                    XLOPER12 xFmt;
                    if (Excel12(xlfGetCell, &xFmt, 2, TempInt12(7), xRef) == xlretSuccess) {
                        if (xFmt.xltype == xltypeStr && xFmt.val.str) {
                            size_t len = (size_t)xFmt.val.str[0];
                            if (len == wfmt.length()) {
                                if (wcsncmp(xFmt.val.str + 1, wfmt.c_str(), len) == 0) {
                                    doFormat = false;
                                }
                            }
                        }
                        Excel12(xlFree, 0, 1, &xFmt);
                    }
                }

                if (doFormat) {
                    XLOPER12 xOldSel;
                    if (Excel12(xlfSelection, &xOldSel, 0) == xlretSuccess) {
                        Excel12(xlcSelect, 0, 1, xRef);
                        Excel12(xlcFormatNumber, 0, 1, TempStr12(wfmt.c_str()));
                        Excel12(xlcSelect, 0, 1, &xOldSel);
                        Excel12(xlFree, 0, 1, &xOldSel);
                    }
                }
                xlAutoFree12(xRef);
            }
        }
    }
}

// Guest Call Handler (Async Return)
int32_t GuestHandler(const uint8_t* req, int32_t msgId, uint8_t* resp, uint32_t size, uint32_t timeoutMs) {
    switch (msgId) {
    case MSG_CHUNK: { // Chunk (128)
        return HandleChunk(req, msgId, resp, size, timeoutMs, GuestHandler);
    }
{{range $i, $fn := .Functions}}
    {{if .Async}}
    case {{add 132 $i}}: { // {{.Name}}
        auto response = flatbuffers::GetRoot<ipc::{{.Name}}Response>(req);
        LPXLOPER12 h = (LPXLOPER12)response->async_handle();

        if (response->error() && response->error()->size() > 0) {
            XLOPER12 xErr; xErr.xltype = xltypeErr; xErr.val.err = xlErrValue;
            Excel12(xlAsyncReturn, 0, 2, h, &xErr);
            return 0;
        }

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(response->result()->str());
        LPXLOPER12 xRes = NewExcelString(wres.c_str());
        Excel12(xlAsyncReturn, 0, 2, h, xRes);
        // NewExcelString sets xlbitDLLFree, so we can use xlAutoFree12 to clean it up.
        // This handles both the string buffer and returning the XLOPER12 to the pool.
        xlAutoFree12(xRes);
        {{else if eq .Return "int"}}
        XLOPER12 xRes; xRes.xltype = xltypeInt; xRes.val.w = response->result();
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{else if eq .Return "float"}}
        XLOPER12 xRes; xRes.xltype = xltypeNum; xRes.val.num = response->result();
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{else if eq .Return "bool"}}
        XLOPER12 xRes; xRes.xltype = xltypeBool; xRes.val.xbool = response->result() ? 1 : 0;
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{end}}
        return 0;
    }
    {{end}}
{{end}}
    default:
        return 0;
    }
}

extern "C" {

__declspec(dllexport) int __stdcall xlAutoOpen() {
    // Determine worker count
    int workers = {{.Server.Workers}};
    if (workers <= 0) {
        workers = std::thread::hardware_concurrency();
        if (workers == 0) workers = 16; // Fallback
    }

    // 1024 queue items, 1MB buffer size per slot
    {{if .ShouldAppendPid}}
    std::string shmName = "{{.ProjectName}}_" + std::to_string(GetCurrentProcessId());
    {{else}}
    std::string shmName = "{{.ProjectName}}";
    {{end}}

    if (!g_host.Init(shmName.c_str(), 1024, 1024*1024, workers)) {
        return 0;
    }

    g_running = true;
    g_worker = std::thread([]{
        while(g_running) {
             int n = g_host.ProcessGuestCalls(GuestHandler);
             if (n == 0) std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    });

    static XLOPER12 xDll;
    Excel12(xlGetName, &xDll, 0);

{{range .Events}}
    Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Name}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }
    {{end}}

{{range $i, $fn := .Functions}}
    {
        Excel12(xlfRegister, 0, {{registerCount $fn}},
            &xDll,
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{if .Async}}>{{end}}{{lookupXllType .Return}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}$"),
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{joinArgNames $fn}}"),
            TempStr12(L"1"),
            TempStr12(L"{{withDefault .Category $.ProjectName}}"),
            TempStr12(L"{{.Shortcut}}"),
            TempStr12(L"{{.HelpTopic}}"),
            TempStr12(L"{{.Description}}"){{if .Args}},{{end}}
            {{range $j, $arg := .Args}}TempStr12(L"{{$arg.Description}}"){{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}
            {{if .Async}}{{if .Args}},{{end}}TempStr12(L"Async Handle"){{end}}
        );
    }
{{end}}

{{if .Server.Launch}}
{{if derefBool .Server.Launch.Enabled}}
    // Launch Logic
    {
        std::wstring xllDir = GetXllDir();

        // Resolve CWD
        std::wstring cwd = xllDir;
        {{if .Server.Launch.Cwd}}
        std::string cfgCwd = "{{.Server.Launch.Cwd}}";
        if (cfgCwd != ".") {
            std::wstring wCwd = StringToWString(cfgCwd);
            bool isAbs = (wCwd.find(L":") != std::wstring::npos || (wCwd.size() > 1 && wCwd[0] == L'\\' && wCwd[1] == L'\\'));
            if (isAbs) {
                cwd = wCwd;
            } else {
                cwd = xllDir + L"\\" + wCwd;
            }
        }
        {{end}}

        // Resolve Command
        std::wstring exePath = xllDir + L"\\{{.ProjectName}}.exe";
        {{if .Server.Launch.Command}}
        std::string cfgCmd = "{{.Server.Launch.Command}}";
        std::wstring wCmd = StringToWString(cfgCmd);
        bool isCmdAbs = (wCmd.find(L":") != std::wstring::npos || (wCmd.size() > 1 && wCmd[0] == L'\\' && wCmd[1] == L'\\'));
        if (isCmdAbs) {
            exePath = wCmd;
        } else {
             if (cfgCmd.find("./") == 0 || cfgCmd.find(".\\") == 0) {
                 exePath = cwd + L"\\" + wCmd.substr(2);
            } else {
                 exePath = cwd + L"\\" + wCmd;
            }
        }
        {{end}}

        // Append SHM Flag (Quote the executable path to handle spaces)
        std::wstring cmd = L"\"" + exePath + L"\" -xll-shm=" + StringToWString(shmName);

        // Setup Log File
        std::wstring logPath = cwd + L"\\xll_launch.log";
        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = NULL;

        HANDLE hLog = CreateFileW(logPath.c_str(), FILE_APPEND_DATA, FILE_SHARE_READ, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hLog != INVALID_HANDLE_VALUE) {
            STARTUPINFOW si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags |= STARTF_USESTDHANDLES;
            si.hStdOutput = hLog;
            si.hStdError = hLog;
            si.hStdInput = NULL;

            PROCESS_INFORMATION pi;
            ZeroMemory(&pi, sizeof(pi));

            // Need mutable string for CreateProcess
            std::vector<wchar_t> cmdBuf(cmd.begin(), cmd.end());
            cmdBuf.push_back(0);

            if (CreateProcessW(NULL, cmdBuf.data(), NULL, NULL, TRUE, 0, NULL, cwd.c_str(), &si, &pi)) {
                g_hChildProcess = pi.hProcess;
                CloseHandle(pi.hThread);
            }

            CloseHandle(hLog);
        }
    }
{{end}}
{{end}}

    Excel12(xlFree, 0, 1, &xDll);
    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    g_running = false;
    if (g_worker.joinable()) g_worker.join();
    g_host.Shutdown();

    if (g_hChildProcess) {
        TerminateProcess(g_hChildProcess, 0);
        CloseHandle(g_hChildProcess);
        g_hChildProcess = NULL;
    }
    return 1;
}

{{range .Events}}
__declspec(dllexport) void __stdcall {{.Name}}() {
    {{if eq .Type "CalculationEnded"}}
    {
        std::lock_guard<std::mutex> lock(g_refCacheMutex);
        g_sentRefCache.clear();
    }
    auto slot = g_host.GetZeroCopySlot();
    if (slot.Send(0, MSG_CALCULATION_ENDED, 2000)) {
         if (slot.GetRespSize() > 0) {
             auto resp = flatbuffers::GetRoot<ipc::CalculationEndedResponse>(slot.GetRespBuffer());
             ExecuteCommands(resp);
         }
    }
    {{else if eq .Type "CalculationCanceled"}}
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, MSG_CALCULATION_CANCELED, 2000);
    {{else}}
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, {{lookupEventId .Type}}, 2000);
    {{end}}
}
{{end}}
{{if hasEvent "CalculationEnded" .Events}}
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    {
        std::lock_guard<std::mutex> lock(g_refCacheMutex);
        g_sentRefCache.clear();
    }
    auto slot = g_host.GetZeroCopySlot();
    if (slot.Send(0, MSG_CALCULATION_ENDED, 2000)) {
         if (slot.GetRespSize() > 0) {
             auto resp = flatbuffers::GetRoot<ipc::CalculationEndedResponse>(slot.GetRespBuffer());
             ExecuteCommands(resp);
         }
    }
}
{{end}}

{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupArgCppType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {

    auto slot = g_host.GetZeroCopySlot();
    flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), nullptr, false, slot.GetReqBuffer());

    {{range .Args}}
    {{if eq .Type "string"}}
    auto {{.Name}}_off = builder.CreateString(ConvertExcelString({{.Name}}));
    {{else if eq .Type "int?"}}
    flatbuffers::Offset<ipc::types::Int> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateInt(builder, *{{.Name}});
    }
    {{else if eq .Type "float?"}}
    flatbuffers::Offset<ipc::types::Num> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateNum(builder, *{{.Name}});
    }
    {{else if eq .Type "bool?"}}
    flatbuffers::Offset<ipc::types::Bool> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateBool(builder, (*{{.Name}} != 0));
    }
    {{else if eq .Type "range"}}
    auto {{.Name}}_off = ConvertRange({{.Name}}, builder);
    {{else if eq .Type "grid"}}
    auto {{.Name}}_off = ConvertGrid({{.Name}}, builder);
    {{else if eq .Type "numgrid"}}
    auto {{.Name}}_off = ConvertNumGrid({{.Name}}, builder);
    {{else if eq .Type "any"}}
    auto {{.Name}}_off = ConvertAny({{.Name}}, builder);
    {{end}}
    {{end}}

    {{if .Caller}}
    flatbuffers::Offset<ipc::types::Range> caller_off = 0;
    {
        XLOPER12 xCaller;
        if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
            caller_off = ConvertRange(&xCaller, builder);
            if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                Excel12(xlFree, 0, 1, &xCaller);
            }
        }
    }
    {{end}}

    ipc::{{.Name}}RequestBuilder reqBuilder(builder);
    {{range .Args}}
    {{if eq .Type "string"}}
    reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "int?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "float?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "bool?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "range"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "grid"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "numgrid"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "any"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else}}
    reqBuilder.add_{{.Name}}({{.Name}});
    {{end}}
    {{end}}
    {{if .Caller}}
    if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
    {{end}}
    {{if .Async}}
    reqBuilder.add_async_handle((uint64_t)asyncHandle);
    {{end}}
    auto req = reqBuilder.Finish();
    builder.Finish(req);

    // Zero-Copy Send (Size, MsgId, Timeout)
    {{if .Async}}
    // Async Handshake Timeout: Function override OR Global AsyncAckTimeout (default 2000)
    {{ $ackTimeout := parseTimeout .Timeout 0 }}
    {{ if eq $ackTimeout 0 }}{{ $ackTimeout = parseTimeout $.Server.AsyncAckTimeout 2000 }}{{ end }}
    bool ok = slot.Send(builder.GetSize(), {{add 132 $i}}, {{ $ackTimeout }});
    if (!ok) return;
    return;
    {{else}}
    // Sync Calculation Timeout: Function override OR Global Timeout (default 2000)
    {{ $syncTimeout := parseTimeout .Timeout 0 }}
    {{ if eq $syncTimeout 0 }}{{ $syncTimeout = parseTimeout $.Server.Timeout 2000 }}{{ end }}
    const uint8_t* respBuf = ReceiveChunked(slot, {{add 132 $i}}, builder.GetSize(), {{ $syncTimeout }});
    if (!respBuf) return {{defaultErrorVal .Return}};

    auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(respBuf);
    if (resp->error() && resp->error()->size() > 0) {
        return {{defaultErrorVal .Return}};
    }

    {{if eq .Return "string"}}
    std::wstring wres = StringToWString(resp->result()->str());
    return NewExcelString(wres.c_str());
    {{else}}
    return resp->result();
    {{end}}
    {{end}}
}
{{end}}

} // extern "C"
