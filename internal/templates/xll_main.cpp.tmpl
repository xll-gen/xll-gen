{{- $gen := . }}
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
// This file contains the main entry point and XLL interface functions.

#include <windows.h>
#include "types/xlcall.h"
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>
#include <filesystem>
#include <sstream>
#include <map>
#include <fstream>
#include "xll_log.h"
#include "xll_path.h"
#include "types/mem.h"
#include "types/converters.h"
#include "types/utility.h"
#include "xll_launch.h"
#include "xll_worker.h"
#include "xll_cache.h"
#include "xll_embed.h"
#include "xll_events.h"
#include "xll_ipc.h"
#include "xll_lifecycle.h"
#include "xll_excel.h"
#include "SHMAllocator.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
#include "protocol_generated.h"
{{if .Rtd.Enabled}}
#include <rtd/rtd.h>
{{end}}

// Disable "unreferenced formal parameter" warning
#pragma warning(disable: 4100)

using namespace xll;

{{if .Rtd.Enabled}}
// RTD Update Queue
struct RtdValue {
    long topicId;
    std::wstring value;
    bool dirty;
};
std::mutex g_rtdMutex;
std::map<long, RtdValue> g_rtdValues;
rtd::IRTDUpdateEvent* g_rtdCallback = nullptr;

void ProcessRtdUpdate(const protocol::RtdUpdate* update) {
    if (!update) return;
    long topicID = update->topic_id();

    // Extract value from Any
    std::wstring valStr;
    auto anyVal = update->val();
    if (anyVal) {
        if (anyVal->val_type() == protocol::AnyValue::Str) {
             valStr = StringToWString(anyVal->val_as_Str()->val()->str());
        } else if (anyVal->val_type() == protocol::AnyValue::Num) {
             valStr = std::to_wstring(anyVal->val_as_Num()->val());
        } else if (anyVal->val_type() == protocol::AnyValue::Int) {
             valStr = std::to_wstring(anyVal->val_as_Int()->val());
        } else if (anyVal->val_type() == protocol::AnyValue::Bool) {
             valStr = anyVal->val_as_Bool()->val() ? L"TRUE" : L"FALSE";
        } else {
             valStr = L"#VALUE!";
        }
    }

    {
        std::lock_guard<std::mutex> lock(g_rtdMutex);
        g_rtdValues[topicID] = {topicID, valStr, true};

        if (g_rtdCallback) {
            // We should use AddRef if we stored it, but here we just use the raw pointer carefully.
            // Ideally, we should have AddRef'd it in ConnectData.
            // For now, assume simple notify.
            // Note: UpdateNotify is thread-safe.
            g_rtdCallback->UpdateNotify();
        }
    }
}

// RTD Server Implementation
class RtdServer : public rtd::RtdServerBase {
public:
    // ConnectData: Called when a new topic is subscribed
    HRESULT __stdcall ConnectData(long TopicID, SAFEARRAY** Strings, VARIANT_BOOL* GetNewValues, VARIANT* pvarOut) override {
        // Send Connect Request to Go
        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

        std::vector<flatbuffers::Offset<flatbuffers::String>> strOffsets;
        if (Strings && *Strings) {
            SAFEARRAY* psa = *Strings;
            long lb, ub;
            SafeArrayGetLBound(psa, 1, &lb);
            SafeArrayGetUBound(psa, 1, &ub);
            for (long i = lb; i <= ub; ++i) {
                VARIANT v;
                VariantInit(&v);
                SafeArrayGetElement(psa, &i, &v);
                if (v.vt == VT_BSTR) {
                    std::wstring wstr(v.bstrVal, SysStringLen(v.bstrVal));
                    strOffsets.push_back(builder.CreateString(WideToUtf8(wstr)));
                }
                VariantClear(&v);
            }
        }

        auto stringsVec = builder.CreateVector(strOffsets);
        auto req = protocol::CreateRtdConnectRequest(builder, TopicID, stringsVec, (GetNewValues && *GetNewValues));
        builder.Finish(req);

        auto res = slot.Send(-((int)builder.GetSize()), (shm::MsgType)MSG_RTD_CONNECT, 2000);
        if (res.HasError()) {
            LogError("RTD Connect failed: " + SHMErrorToString(res.GetError()));
            // Return Error
            VariantInit(pvarOut);
            pvarOut->vt = VT_ERROR;
            pvarOut->scode = 2046; // xlErrConnect
            return S_OK;
        }

        {
             std::lock_guard<std::mutex> lock(g_rtdMutex);
             // Store reference to callback
             if (m_callback) {
                 if (g_rtdCallback) g_rtdCallback->Release();
                 g_rtdCallback = m_callback;
                 g_rtdCallback->AddRef();
             }
        }

        // Return #GettingData to indicate async update
        VariantInit(pvarOut);
        pvarOut->vt = VT_ERROR;
        pvarOut->scode = 2043; // xlErrGettingData
        return S_OK;
    }

    HRESULT __stdcall ServerTerminate() override {
        {
             std::lock_guard<std::mutex> lock(g_rtdMutex);
             if (g_rtdCallback) {
                 g_rtdCallback->Release();
                 g_rtdCallback = nullptr;
             }
        }
        return RtdServerBase::ServerTerminate();
    }

    // DisconnectData: Called when a topic is unsubscribed
    HRESULT __stdcall DisconnectData(long TopicID) override {
        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

        auto req = protocol::CreateRtdDisconnectRequest(builder, TopicID);
        builder.Finish(req);

        slot.Send(-((int)builder.GetSize()), (shm::MsgType)MSG_RTD_DISCONNECT, 500);

        // Cleanup
        {
             std::lock_guard<std::mutex> lock(g_rtdMutex);
             g_rtdValues.erase(TopicID);
        }

        return S_OK;
    }

    // RefreshData: Called by Excel to get new values
    HRESULT __stdcall RefreshData(long* TopicCount, SAFEARRAY** parrayOut) override {
        std::lock_guard<std::mutex> lock(g_rtdMutex);

        std::vector<RtdValue> updates;
        for (auto& [id, val] : g_rtdValues) {
            if (val.dirty) {
                updates.push_back(val);
                val.dirty = false;
            }
        }

        *TopicCount = (long)updates.size();
        HRESULT hr = CreateRefreshDataArray(*TopicCount, parrayOut);
        if (FAILED(hr)) return hr;

        if (*TopicCount == 0) return S_OK;

        long indices[2];
        for (long i = 0; i < *TopicCount; ++i) {
             long topicID = updates[i].topicId;
             indices[0] = 0; indices[1] = i;
             VARIANT vID; VariantInit(&vID);
             vID.vt = VT_I4; vID.lVal = topicID;
             SafeArrayPutElement(*parrayOut, indices, &vID);

             indices[0] = 1; indices[1] = i;
             VARIANT vVal; VariantInit(&vVal);
             vVal.vt = VT_BSTR;
             vVal.bstrVal = SysAllocString(updates[i].value.c_str());
             SafeArrayPutElement(*parrayOut, indices, &vVal);
             SysFreeString(vVal.bstrVal);
        }

        return S_OK;
    }
};

// Helper function to create CLSID from string
GUID StringToGuid(const std::wstring& str) {
    GUID guid;
    HRESULT hr = CLSIDFromString(str.c_str(), &guid);
    if (FAILED(hr)) {
        return { 0 };
    }
    return guid;
}

// Global CLSID
// We use a function to initialize it to avoid static initialization order issues
const CLSID& GetRtdClsid() {
    static CLSID clsid = StringToGuid(L"{{.Rtd.Clsid}}");
    // Fallback if empty or invalid
    if (IsEqualGUID(clsid, { 0 })) {
        // Fallback: Use a deterministic hash of the ProgID if Clsid is missing?
        // For now, let's rely on user providing valid CLSID or valid default.
        // If user provided nothing, we might be in trouble.
        // But generator validation should handle this?
        // Actually, config validator requires Clsid to be present if we want to be safe,
        // OR we just use a placeholder.
    }
    return clsid;
}

const wchar_t* g_szProgID = L"{{.Rtd.ProgID}}";
const wchar_t* g_szFriendlyName = L"{{.Rtd.Description}}";

extern "C" {
    __declspec(dllexport) HRESULT __stdcall DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
        if (!ppv) return E_POINTER;
        *ppv = nullptr;
        if (IsEqualGUID(rclsid, GetRtdClsid())) {
            rtd::ClassFactory<RtdServer>* pFactory = new rtd::ClassFactory<RtdServer>();
            HRESULT hr = pFactory->QueryInterface(riid, ppv);
            pFactory->Release();
            return hr;
        }
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    __declspec(dllexport) HRESULT __stdcall DllCanUnloadNow() {
        return (rtd::GlobalModule::GetLockCount() == 0) ? S_OK : S_FALSE;
    }

    __declspec(dllexport) HRESULT __stdcall DllRegisterServer() {
        return rtd::RegisterServer(g_hModule, GetRtdClsid(), g_szProgID, g_szFriendlyName);
    }

    __declspec(dllexport) HRESULT __stdcall DllUnregisterServer() {
        return rtd::UnregisterServer(GetRtdClsid(), g_szProgID);
    }
}
{{end}}

// XLL Interface Functions

extern "C" __declspec(dllexport) int __stdcall xlAutoOpen() {
    XLL_SAFE_BLOCK_BEGIN
        ScopedXLOPER12Result xDLL; // Defined here for xlGetName

        // Setup Native Logging
        std::string tempPattern = "";
    std::string projName = "{{.ProjectName}}";
    bool isSingleFile = false;
    std::wstring launchLog;
    LaunchConfig cfg;

    {{if eq .Build.Singlefile "xll"}}
    isSingleFile = true;
    tempPattern = "{{.Build.TempDir}}";
    {{end}}

    std::wstring binDir = GetXllDir();
    {{if eq .Build.Singlefile "xll"}}
    binDir = ExpandEnvVarsW(L"{{.Build.TempDir}}");
    {{end}}

    std::wstring logPath = L"{{.Logging.Dir}}";
    if (logPath == L"XLL_DIR") {
        logPath = GetXllDir() + L"\\{{.ProjectName}}_native.log";
    } else if (logPath == L"TEMP_DIR") {
        logPath = ExpandEnvVarsW(L"${TEMP}") + L"\\{{.ProjectName}}_native.log";
    } else {
        // Support placeholders like ${XLL_DIR}, ${BIN_DIR} and ${TEMP}
        ReplaceAll(logPath, L"${XLL_DIR}", GetXllDir());
        ReplaceAll(logPath, L"${BIN_DIR}", binDir);
        logPath = ExpandEnvVarsW(logPath);

        // If it's a directory (or ends with slash), append default log name
        if (!logPath.empty() && (std::filesystem::is_directory(logPath) || logPath.back() == L'\\' || logPath.back() == L'/')) {
            if (logPath.back() != L'\\' && logPath.back() != L'/') logPath += L"\\";
            logPath += L"{{.ProjectName}}_native.log";
        }
    }

    std::string logInitError;
    if (!InitLog(logPath, "{{.Logging.Level}}", tempPattern, projName, isSingleFile, logInitError)) {
            // If logging fails to initialize, we show a message box but proceed.
            // Logging is critical for debugging but not for core functionality.
            MessageBoxA(NULL, ("Failed to initialize logging: " + logInitError).c_str(), "XLL Initialization Warning", MB_OK | MB_ICONWARNING);
    } else {
            LogInfo("Logging Initialized Successfully. LogPath: " + WideToUtf8(logPath));
    }

#ifdef SHM_DEBUG
    shm::SetLogHandler(LogHandler);
#endif

    LogInfo("xlAutoOpen: Loading XLL...");

    xll::CallExcel(xlGetName, xDLL);

    {{if .Rtd.Enabled}}
    // Register RTD Server
    HRESULT hr = DllRegisterServer();
    if (FAILED(hr)) {
        LogError("Failed to register RTD server: " + std::to_string(hr));
    } else {
        LogInfo("RTD Server registered successfully.");
    }
    {{end}}

    // Initialize Shared Memory
    std::string shmName = "{{.ProjectName}}";
    {{if not .ShouldAppendPid}}
    // Static name for testing/dev
    {{else}}
    shmName += "_" + std::to_string(GetCurrentProcessId());
    {{end}}

    LogInfo("Initializing Shared Memory: " + shmName);

    // HostConfig: hostSlots, guestSlots.
    shm::HostConfig hostCfg{};
    int workers = {{if .Server.Workers}}{{.Server.Workers}}{{else}}std::thread::hardware_concurrency(){{end}};
    if (workers < 1) workers = 1;
    hostCfg.numHostSlots = workers * 2 + 2;
    hostCfg.numGuestSlots = 2;
    hostCfg.shmName = shmName;
    hostCfg.payloadSize = 1024 * 1024; // 1MB

    // Initialize Host (Allocated if null to persist across Probe Unloads)
    if (!g_phost) {
        g_phost = new shm::DirectHost();
    }

    auto initRes = g_host.Init(hostCfg);
    if (initRes.HasError()) {
            std::string err = "Failed to initialize shared memory: " + SHMErrorToString(initRes.GetError());
            LogError(err);
            MessageBoxA(NULL, err.c_str(), "XLL Error", MB_OK | MB_ICONERROR);
            return 0; // Fail loading
    }

    // Launch Server Process
    {{if derefBool .Server.Launch.Enabled}}
    // Check if already running
    if (g_procInfo.hProcess != NULL) {
        DWORD exitCode = 0;
        if (GetExitCodeProcess(g_procInfo.hProcess, &exitCode) && exitCode == STILL_ACTIVE) {
            LogInfo("Server process is already running. Skipping launch.");
        } else {
             // Process is dead, clean up handles
             if (g_procInfo.hProcess) CloseHandle(g_procInfo.hProcess);
             if (g_procInfo.hJob) CloseHandle(g_procInfo.hJob);
             if (g_procInfo.hShutdownEvent) CloseHandle(g_procInfo.hShutdownEvent);
             g_procInfo = { 0 };
             goto launch_server;
        }
    } else {
        goto launch_server;
    }
    // Skip launch if running
    goto start_worker;

launch_server:
    // Prepare Launch Config
    cfg.projectName = L"{{.ProjectName}}";
    cfg.isSingleFile = isSingleFile;
    cfg.cwd = ""; // Default CWD (relative to bindir)
    cfg.command = "{{.Server.Command}}";
    cfg.shmName = shmName;
    {{if eq .Build.Singlefile "xll"}}cfg.tempDir = StringToWString(tempPattern);{{end}}

    if (!LaunchServer(cfg, GetXllDir(), g_procInfo, launchLog)) {
            return 0;
    }

    // Start Monitor Thread
    g_monitorThread = std::thread(MonitorThread, launchLog);

start_worker:
    {{else}}
    LogInfo("Server launch disabled by configuration.");
    {{end}}

    // Start Worker Thread for Async Results
    xll::StartWorker();

    // Register Events
{{range .Events}}
    xll::CallExcel(xlEventRegister, nullptr, L"{{.Handler}}", {{lookupEventCode .Type}});
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    bool hasCache = {{.Cache.Enabled}};
    {{range .Functions}}
    {{if .Cache}}
    {{if .Cache.Enabled}}
    hasCache = true;
    {{end}}
    {{end}}
    {{end}}

    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded || hasCache) {
            xll::CallExcel(xlEventRegister, nullptr, L"CalculationEnded", xleventCalculationEnded);
    }
    {{end}}

    // Register User Functions
{{range $i, $fn := .Functions}}
    {
        // Register {{.Name}}
        ScopedXLOPER12Result xRegId;
        int regRes = xll::RegisterFunction(
            *xDLL,
            L"{{.Name}}", // Procedure
            L"{{if .Async}}>{{end}}{{if not .Async}}{{lookupXllType .Return}}{{end}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}$", // TypeText
            L"{{.Name}}", // FunctionText
            L"{{range $j, $arg := .Args}}{{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}", // ArgumentText
            1, // MacroType
            L"{{if .Category}}{{.Category}}{{else}}{{$.ProjectName}}{{end}}", // Category
            L"{{.Shortcut}}", // Shortcut
            L"{{.HelpTopic}}", // HelpTopic
            L"{{.Description}}", // FunctionHelp
            { // ArgumentHelp
                {{range .Args}}L"{{.Description}}",{{end}}
            },
            *xRegId // Output ID
        );

        if (regRes != xlretSuccess) {
            LogError("Failed to register function '{{.Name}}'. Code: " + std::to_string(regRes));
        } else {
            std::string idStr = "Unknown";
            if (xRegId->xltype == xltypeNum) idStr = std::to_string((int)xRegId->val.num);
            LogInfo("Registered function '{{.Name}}' successfully. ID: " + idStr);
        }
    }
{{end}}

        LogInfo("xlAutoOpen: Initialization complete. Returning 1.");
        return 1;
    XLL_SAFE_BLOCK_END(0)
}

// Event Handlers
{{range .Events}}
extern "C" __declspec(dllexport) void __stdcall {{.Handler}}() {
    std::vector<uint8_t> respBuf;
    // Construct Request (Event)
    // Currently not fully implemented for named events
    LogInfo("Event {{.Type}} triggered");
}
{{end}}

{{if hasEvent "CalculationEnded" .Events}}
// User defined handler exists
{{else}}
extern "C" __declspec(dllexport) void __stdcall CalculationEnded() {
    HandleCalculationEnded();
}
{{end}}

// User Functions
{{range $i, $fn := .Functions}}
extern "C" __declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupCppArgType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    LogDebug("Func Entry: {{.Name}}");
    {{/* Determine Cache Configuration */}}
    {{ $cacheEnabled := $.Cache.Enabled }}
    {{ $ttl := $.Cache.TTL }}
    {{ if .Cache }}
        {{ if .Cache.Enabled }}{{ $cacheEnabled = derefBool .Cache.Enabled }}{{ end }}
        {{ if .Cache.TTL }}{{ $ttl = .Cache.TTL }}{{ end }}
    {{ end }}

    {{if and $cacheEnabled (not .Async)}}
    // Cache Lookup
    xll::CacheConfig cacheConfig;
    cacheConfig.enabled = true;
    cacheConfig.ttl = std::chrono::milliseconds({{parseDurationToMs $ttl}});
    cacheConfig.jitter = std::chrono::milliseconds({{parseDurationToMs $.Cache.Jitter}});

    // Prepare temporary XLOPERs for non-pointer arguments
    std::vector<XLOPER12> tempArgs({{len .Args}});
    std::vector<LPXLOPER12> cacheArgs;
    cacheArgs.reserve({{len .Args}});

    {{range $j, $arg := .Args}}
    {
        XLOPER12& xArg = tempArgs[{{$j}}];
        {{if eq .Type "int"}}
        xArg.xltype = xltypeInt;
        xArg.val.w = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "float"}}
        xArg.xltype = xltypeNum;
        xArg.val.num = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "bool"}}
        xArg.xltype = xltypeBool;
        xArg.val.xbool = {{.Name}} ? 1 : 0;
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "string"}}
        // Convert string to temp XLOPER12 for cache key
        // Use PascalToWString for safe conversion if it is string
        std::wstring s = (({{.Name}}->xltype & xltypeStr) ? PascalToWString({{.Name}}->val.str) : L"");
        xArg = CreateStringXLOPER(s.c_str());
        xArg.xltype |= xlbitDLLFree;
        cacheArgs.push_back(&xArg);
        {{else}}
        // Already a pointer
        cacheArgs.push_back((LPXLOPER12){{.Name}});
        {{end}}
    }
    {{end}}

    std::string cacheKey = xll::MakeCacheKey("{{.Name}}", cacheArgs);

    // Cleanup temporary string allocations
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    delete[] tempArgs[{{$j}}].val.str;
    {{end}}
    {{end}}

    std::vector<uint8_t> cachedData;
    if (xll::CacheManager::Instance().Get(cacheKey, cachedData)) {
        // Deserialize response
        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(cachedData.data());

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
    }
    {{end}}

    // NOTE: 'slot' is declared here using GetZeroCopySlot().
    // SHMAllocator uses it for Zero-Copy Write of the Request.
    auto slot = g_host.GetZeroCopySlot();
    SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
    flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

    // Arguments
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    auto arg{{$j}} = builder.CreateString(({{.Name}}->xltype == xltypeStr) ? ConvertExcelString({{.Name}}->val.str) : "");
    {{else if eq .Type "grid"}}
    auto arg{{$j}} = GridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "numgrid"}}
    auto arg{{$j}} = NumGridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "range"}}
    auto arg{{$j}} = RangeToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "any"}}
    auto arg{{$j}} = AnyToFlatBuffer(builder, {{.Name}});
    {{end}}
    {{end}}

    {{if .Caller}}
    flatbuffers::Offset<protocol::Range> caller_off = 0;
    {
        ScopedXLOPER12 xCaller;
        if (xll::CallExcel(xlfCaller, &xCaller) == xlretSuccess) {
            std::string callerFormat = "";
            XLOPER12 xType; xType.xltype = xltypeInt; xType.val.w = 7;
            ScopedXLOPER12 xFormat;
            if (xll::CallExcel(xlfGetCell, &xFormat, &xType, &xCaller) == xlretSuccess) {
                if (xFormat->xltype == xltypeStr) {
                        callerFormat = ConvertExcelString(xFormat->val.str);
                }
            }
            caller_off = ConvertRange(&xCaller, builder, callerFormat);
        }
    }
    {{end}}

    {{if .Async}}
    auto asyncHandle_vec = builder.CreateVector((const uint8_t*)asyncHandle, sizeof(XLOPER12));
    {{end}}

    ipc::{{.Name}}RequestBuilder reqBuilder(builder);
    {{range $j, $arg := .Args}}
    {{if or (eq .Type "int") (eq .Type "float") (eq .Type "bool")}}
    reqBuilder.add_{{.Name}}({{if eq .Type "bool"}}({{.Name}} != 0){{else}}{{.Name}}{{end}});
    {{else}}
    reqBuilder.add_{{.Name}}(arg{{$j}});
    {{end}}
    {{end}}

    {{if .Caller}}
    if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
    {{end}}
    {{if .Async}}
    reqBuilder.add_async_handle(asyncHandle_vec);
    {{end}}

    auto req = reqBuilder.Finish();
    builder.Finish(req);

    {{if .Async}}
    // Async Send
    LogDebug("Async Send Start: {{.Name}}");
    auto res = slot.Send(-((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.AsyncAckTimeout 2000}}{{end}});
    LogDebug("Async Send End: {{.Name}}");

    if (res.HasError()) {
            std::string err = "Async send failed: " + SHMErrorToString(res.GetError());
            LogError(err);
            XLOPER12 xErr;
            xErr.xltype = xltypeErr;
            xErr.val.err = xlerrValue;
            xll::CallExcel(xlAsyncReturn, nullptr, (LPXLOPER12)asyncHandle, &xErr);
            return;
    }
    LogDebug("Func Exit: {{.Name}}");
    return;
    {{else}}
    // Sync Send
    auto res = slot.Send(-((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.Timeout 2000}}{{end}});

    if (res.HasError()) {
            return &g_xlErrValue;
    }

    auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(slot.GetRespBuffer());

    {{if and $cacheEnabled (not .Async)}}
    // Store in cache
    {
        int32_t respSize = slot.GetRespSize();
        if (respSize > 0) {
                std::vector<uint8_t> response(slot.GetRespBuffer(), slot.GetRespBuffer() + respSize);
                xll::CacheManager::Instance().Put(cacheKey, response, cacheConfig);
        }
    }
    {{end}}

    {{if eq .Return "string"}}
    std::wstring wres = StringToWString(resp->result()->str());
    return NewExcelString(wres.c_str());
    {{else if eq .Return "int"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeInt;
    xRes.val.w = resp->result();
    return &xRes;
    {{else if eq .Return "float"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeNum;
    xRes.val.num = resp->result();
    return &xRes;
    {{else if eq .Return "bool"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeBool;
    xRes.val.xbool = resp->result() ? 1 : 0;
    return &xRes;
    {{else if eq .Return "any"}}
    return AnyToXLOPER12(resp->result());
    {{else if eq .Return "grid"}}
    return GridToXLOPER12(resp->result());
    {{else if eq .Return "numgrid"}}
    return NumGridToFP12(resp->result());
    {{else if eq .Return "range"}}
    return RangeToXLOPER12(resp->result());
    {{else}}
    return resp->result();
    {{end}}
    {{end}}
}
{{end}}
