{{- $gen := . }}
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
// This file contains the main entry point and XLL interface functions.

#include <windows.h>
#include "types/xlcall.h"
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>
#include <filesystem>
#include <sstream>
#include <map>
#include <fstream>
#include "xll_log.h"
#include "xll_path.h"
#include "types/mem.h"
#include "types/converters.h"
#include "types/utility.h"
#include "types/PascalString.h"
#include "xll_launch.h"
#include "xll_worker.h"
#include "xll_cache.h"
#include "xll_embed.h"
#include "xll_events.h"
#include "xll_ipc.h"
#include "xll_lifecycle.h"
#include "xll_excel.h"
#include "SHMAllocator.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
#include "protocol_generated.h"

// Disable "unreferenced formal parameter" warning
#pragma warning(disable: 4100)

using namespace xll;

// XLL Interface Functions

extern "C" __declspec(dllexport) int __stdcall xlAutoOpen() {
    XLL_SAFE_BLOCK_BEGIN
        XLOPER12 xDLL; // Defined here for xlGetName

        // Setup Native Logging
        std::string tempPattern = "";
    std::string projName = "{{.ProjectName}}";
    bool isSingleFile = false;

    {{if eq .Build.Singlefile "xll"}}
    isSingleFile = true;
    tempPattern = "{{.Build.TempDir}}";
    {{end}}

    std::wstring binDir = GetXllDir();
    {{if eq .Build.Singlefile "xll"}}
    binDir = ExpandEnvVarsW(L"{{.Build.TempDir}}");
    {{end}}

    std::wstring logPath = L"{{.Logging.Dir}}";
    if (logPath == L"XLL_DIR") {
        logPath = GetXllDir() + L"\\{{.ProjectName}}_native.log";
    } else if (logPath == L"TEMP_DIR") {
        logPath = ExpandEnvVarsW(L"${TEMP}") + L"\\{{.ProjectName}}_native.log";
    } else {
        // Support placeholders like ${XLL_DIR}, ${BIN_DIR} and ${TEMP}
        ReplaceAll(logPath, L"${XLL_DIR}", GetXllDir());
        ReplaceAll(logPath, L"${BIN_DIR}", binDir);
        logPath = ExpandEnvVarsW(logPath);

        // If it's a directory (or ends with slash), append default log name
        if (!logPath.empty() && (std::filesystem::is_directory(logPath) || logPath.back() == L'\\' || logPath.back() == L'/')) {
            if (logPath.back() != L'\\' && logPath.back() != L'/') logPath += L"\\";
            logPath += L"{{.ProjectName}}_native.log";
        }
    }

    std::string logInitError;
    if (!InitLog(logPath, "{{.Logging.Level}}", tempPattern, projName, isSingleFile, logInitError)) {
            // If logging fails to initialize, we show a message box but proceed.
            // Logging is critical for debugging but not for core functionality.
            MessageBoxA(NULL, ("Failed to initialize logging: " + logInitError).c_str(), "XLL Initialization Warning", MB_OK | MB_ICONWARNING);
    } else {
            LogInfo("Logging Initialized Successfully. LogPath: " + WideToUtf8(logPath));
    }

#ifdef SHM_DEBUG
    shm::SetLogHandler(LogHandler);
#endif

    LogInfo("xlAutoOpen: Loading XLL...");

    xll::CallExcel(xlGetName, &xDLL);

    // Initialize Shared Memory
    std::string shmName = "{{.ProjectName}}";
    {{if not .ShouldAppendPid}}
    // Static name for testing/dev
    {{else}}
    shmName += "_" + std::to_string(GetCurrentProcessId());
    {{end}}

    LogInfo("Initializing Shared Memory: " + shmName);

    // HostConfig: hostSlots, guestSlots.
    shm::HostConfig hostCfg{};
    int workers = {{if .Server.Workers}}{{.Server.Workers}}{{else}}std::thread::hardware_concurrency(){{end}};
    if (workers < 1) workers = 1;
    hostCfg.numHostSlots = workers * 2 + 2;
    hostCfg.numGuestSlots = 2;
    hostCfg.shmName = shmName;
    hostCfg.payloadSize = 1024 * 1024; // 1MB

    // Initialize Host (Allocated if null to persist across Probe Unloads)
    if (!g_phost) {
        g_phost = new shm::DirectHost();
    }

    auto initRes = g_host.Init(hostCfg);
    if (initRes.HasError()) {
            std::string err = "Failed to initialize shared memory: " + SHMErrorToString(initRes.GetError());
            LogError(err);
            MessageBoxA(NULL, err.c_str(), "XLL Error", MB_OK | MB_ICONERROR);
            return 0; // Fail loading
    }

    // Launch Server Process
    {{if derefBool .Server.Launch.Enabled}}
    // Prepare Launch Config
    LaunchConfig cfg;
    cfg.projectName = L"{{.ProjectName}}";
    cfg.isSingleFile = isSingleFile;
    cfg.cwd = ""; // Default CWD (relative to bindir)
    cfg.command = "{{.Server.Command}}";
    cfg.shmName = shmName;
    {{if eq .Build.Singlefile "xll"}}cfg.tempDir = StringToWString(tempPattern);{{end}}

    std::wstring launchLog;
    if (!LaunchServer(cfg, GetXllDir(), g_procInfo, launchLog)) {
            return 0;
    }

    // Start Monitor Thread
    g_monitorThread = std::thread(MonitorThread, launchLog);
    {{else}}
    LogInfo("Server launch disabled by configuration.");
    {{end}}

    // Start Worker Thread for Async Results
    xll::StartWorker();

    // Register Events
{{range .Events}}
    xll::CallExcel(xlEventRegister, nullptr, L"{{.Handler}}", {{lookupEventCode .Type}});
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    bool hasCache = {{.Cache.Enabled}};
    {{range .Functions}}
    {{if .Cache}}
    {{if .Cache.Enabled}}
    hasCache = true;
    {{end}}
    {{end}}
    {{end}}

    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded || hasCache) {
            xll::CallExcel(xlEventRegister, nullptr, L"CalculationEnded", xleventCalculationEnded);
    }
    {{end}}

    // Register User Functions
{{range $i, $fn := .Functions}}
    {
        // Register {{.Name}}
        XLOPER12 xRegId;
        int regRes = xll::RegisterFunction(
            xDLL,
            L"{{.Name}}", // Procedure
            L"{{if .Async}}>{{end}}{{if not .Async}}{{lookupXllType .Return}}{{end}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}$", // TypeText
            L"{{.Name}}", // FunctionText
            L"{{range $j, $arg := .Args}}{{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}", // ArgumentText
            1, // MacroType
            L"{{if .Category}}{{.Category}}{{else}}{{$.ProjectName}}{{end}}", // Category
            L"{{.Shortcut}}", // Shortcut
            L"{{.HelpTopic}}", // HelpTopic
            L"{{.Description}}", // FunctionHelp
            { // ArgumentHelp
                {{range .Args}}L"{{.Description}}",{{end}}
            },
            xRegId // Output ID
        );

        if (regRes != xlretSuccess) {
            LogError("Failed to register function '{{.Name}}'. Code: " + std::to_string(regRes));
        } else {
            std::string idStr = "Unknown";
            if (xRegId.xltype == xltypeNum) idStr = std::to_string((int)xRegId.val.num);
            LogInfo("Registered function '{{.Name}}' successfully. ID: " + idStr);

            // Cleanup returned ID if needed
            if (xRegId.xltype & (xlbitXLFree | xlbitDLLFree)) {
                xll::CallExcel(xlFree, nullptr, &xRegId);
            }
        }
    }
{{end}}

        // Free xDLL
        xll::CallExcel(xlFree, nullptr, (LPXLOPER12)&xDLL);

        LogInfo("xlAutoOpen: Initialization complete. Returning 1.");
        return 1;
    XLL_SAFE_BLOCK_END(0)
}

// Event Handlers
{{range .Events}}
__declspec(dllexport) void __stdcall {{.Handler}}() {
    std::vector<uint8_t> respBuf;
    // Construct Request (Event)
    // Currently not fully implemented for named events
    LogInfo("Event {{.Type}} triggered");
}
{{end}}

{{if hasEvent "CalculationEnded" .Events}}
// User defined handler exists
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    HandleCalculationEnded();
}
{{end}}

// User Functions
{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupCppArgType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    {{/* Determine Cache Configuration */}}
    {{ $cacheEnabled := $.Cache.Enabled }}
    {{ $ttl := $.Cache.TTL }}
    {{ if .Cache }}
        {{ if .Cache.Enabled }}{{ $cacheEnabled = derefBool .Cache.Enabled }}{{ end }}
        {{ if .Cache.TTL }}{{ $ttl = .Cache.TTL }}{{ end }}
    {{ end }}

    {{if and $cacheEnabled (not .Async)}}
    // Cache Lookup
    xll::CacheConfig cacheConfig;
    cacheConfig.enabled = true;
    cacheConfig.ttl = std::chrono::milliseconds({{parseDurationToMs $ttl}});
    cacheConfig.jitter = std::chrono::milliseconds({{parseDurationToMs $.Cache.Jitter}});

    // Prepare temporary XLOPERs for non-pointer arguments
    std::vector<XLOPER12> tempArgs({{len .Args}});
    std::vector<LPXLOPER12> cacheArgs;
    cacheArgs.reserve({{len .Args}});

    {{range $j, $arg := .Args}}
    {
        XLOPER12& xArg = tempArgs[{{$j}}];
        {{if eq .Type "int"}}
        xArg.xltype = xltypeInt;
        xArg.val.w = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "float"}}
        xArg.xltype = xltypeNum;
        xArg.val.num = {{.Name}};
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "bool"}}
        xArg.xltype = xltypeBool;
        xArg.val.xbool = {{.Name}} ? 1 : 0;
        cacheArgs.push_back(&xArg);
        {{else if eq .Type "string"}}
        // Convert string to temp XLOPER12 for cache key
        // Use PascalToWString for safe conversion if it is string
        std::wstring s = (({{.Name}}->xltype & xltypeStr) ? PascalToWString({{.Name}}->val.str) : L"");
        xArg = CreateStringXLOPER(s.c_str());
        xArg.xltype |= xlbitDLLFree;
        cacheArgs.push_back(&xArg);
        {{else}}
        // Already a pointer
        cacheArgs.push_back((LPXLOPER12){{.Name}});
        {{end}}
    }
    {{end}}

    std::string cacheKey = xll::MakeCacheKey("{{.Name}}", cacheArgs);

    // Cleanup temporary string allocations
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    delete[] tempArgs[{{$j}}].val.str;
    {{end}}
    {{end}}

    std::vector<uint8_t> cachedData;
    if (xll::CacheManager::Instance().Get(cacheKey, cachedData)) {
        // Deserialize response
        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(cachedData.data());

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
    }
    {{end}}

    // NOTE: 'slot' is declared here using GetZeroCopySlot().
    // SHMAllocator uses it for Zero-Copy Write of the Request.
    auto slot = g_host.GetZeroCopySlot();
    SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
    flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

    // Arguments
    {{range $j, $arg := .Args}}
    {{if eq .Type "string"}}
    auto arg{{$j}} = builder.CreateString(({{.Name}}->xltype == xltypeStr) ? ConvertExcelString(PascalToWString({{.Name}}->val.str).c_str()) : "");
    {{else if eq .Type "grid"}}
    auto arg{{$j}} = GridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "numgrid"}}
    auto arg{{$j}} = NumGridToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "range"}}
    auto arg{{$j}} = RangeToFlatBuffer(builder, {{.Name}});
    {{else if eq .Type "any"}}
    auto arg{{$j}} = AnyToFlatBuffer(builder, {{.Name}});
    {{end}}
    {{end}}

    {{if .Caller}}
    flatbuffers::Offset<protocol::Range> caller_off = 0;
    {
        XLOPER12 xCaller;
        if (xll::CallExcel(xlfCaller, &xCaller) == xlretSuccess) {
            std::string callerFormat = "";
            XLOPER12 xType; xType.xltype = xltypeInt; xType.val.w = 7;
            XLOPER12 xFormat;
            if (xll::CallExcel(xlfGetCell, &xFormat, &xType, &xCaller) == xlretSuccess) {
                if (xFormat.xltype == xltypeStr) {
                        callerFormat = ConvertExcelString(xFormat.val.str);
                }
                xll::CallExcel(xlFree, nullptr, &xFormat);
            }
            caller_off = ConvertRange(&xCaller, builder, callerFormat);
            if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                xll::CallExcel(xlFree, nullptr, &xCaller);
            }
        }
    }
    {{end}}

    {{if .Async}}
    auto asyncHandle_vec = builder.CreateVector((const uint8_t*)asyncHandle, sizeof(XLOPER12));
    {{end}}

    ipc::{{.Name}}RequestBuilder reqBuilder(builder);
    {{range $j, $arg := .Args}}
    {{if or (eq .Type "int") (eq .Type "float") (eq .Type "bool")}}
    reqBuilder.add_{{.Name}}({{if eq .Type "bool"}}({{.Name}} != 0){{else}}{{.Name}}{{end}});
    {{else}}
    reqBuilder.add_{{.Name}}(arg{{$j}});
    {{end}}
    {{end}}

    {{if .Caller}}
    if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
    {{end}}
    {{if .Async}}
    reqBuilder.add_async_handle(asyncHandle_vec);
    {{end}}

    auto req = reqBuilder.Finish();
    builder.Finish(req);

    {{if .Async}}
    // Async Send
    std::vector<uint8_t> dummyResp;
    auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, dummyResp, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.AsyncAckTimeout 2000}}{{end}});
    if (res.HasError()) {
            std::string err = "Async send failed: " + SHMErrorToString(res.GetError());
            LogError(err);
            XLOPER12 xErr;
            xErr.xltype = xltypeErr;
            xErr.val.err = xlerrValue;
            xll::CallExcel(xlAsyncReturn, nullptr, (LPXLOPER12)asyncHandle, &xErr);
            return;
    }
    return;
    {{else}}
    // Sync Send
    std::vector<uint8_t> response;
    auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add MsgUserStart $i}}, response, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.Timeout 2000}}{{end}});

    if (res.HasError()) {
            return &g_xlErrValue;
    }

    auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(response.data());

    {{if and $cacheEnabled (not .Async)}}
    // Store in cache
    {
        int32_t respSize = res.Value();
        if (respSize > 0) {
                xll::CacheManager::Instance().Put(cacheKey, response, cacheConfig);
        }
    }
    {{end}}

    {{if eq .Return "string"}}
    std::wstring wres = StringToWString(resp->result()->str());
    return NewExcelString(wres.c_str());
    {{else if eq .Return "int"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeInt;
    xRes.val.w = resp->result();
    return &xRes;
    {{else if eq .Return "float"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeNum;
    xRes.val.num = resp->result();
    return &xRes;
    {{else if eq .Return "bool"}}
    static thread_local XLOPER12 xRes;
    xRes.xltype = xltypeBool;
    xRes.val.xbool = resp->result() ? 1 : 0;
    return &xRes;
    {{else if eq .Return "any"}}
    return AnyToXLOPER12(resp->result());
    {{else if eq .Return "grid"}}
    return GridToXLOPER12(resp->result());
    {{else if eq .Return "numgrid"}}
    return NumGridToFP12(resp->result());
    {{else if eq .Return "range"}}
    return RangeToXLOPER12(resp->result());
    {{else}}
    return resp->result();
    {{end}}
    {{end}}
}
{{end}}
