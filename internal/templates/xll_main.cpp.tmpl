
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
#include <windows.h>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <map>
#include <mutex>
#include <sstream>
#include <wchar.h>
#include <random>
#include <iostream>
#include "include/xlcall.h"
#include "include/xll_mem.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"

// System Message IDs
#define MSG_ACK 2
#define MSG_CHUNK 128
#define MSG_SETREFCACHE 129
#define MSG_CALCULATION_ENDED 130
#define MSG_CALCULATION_CANCELED 131
#define MSG_USER_START 132

shm::DirectHost g_host;
std::thread g_worker;
std::atomic<bool> g_running{false};
std::map<std::string, bool> g_sentRefCache;
std::mutex g_refCacheMutex;

// Global Process Handle (for auto-launched server)
HANDLE g_hChildProcess = NULL;
HINSTANCE g_hModule = NULL;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }
    return TRUE;
}

// Helpers for registration
LPXLOPER12 TempStr12(const wchar_t* txt) {
    static XLOPER12 xOp[10];
    static int i = 0;
    i = (i + 1) % 10;
    LPXLOPER12 op = &xOp[i];

    op->xltype = xltypeStr;
    static wchar_t strBuf[10][256];
    size_t len = 0;
    if (txt) len = wcslen(txt);
    if (len > 255) len = 255;

    strBuf[i][0] = (wchar_t)len;
    if (len > 0) wmemcpy(strBuf[i]+1, txt, len);

    op->val.str = strBuf[i];
    return op;
}

LPXLOPER12 TempInt12(int val) {
    static XLOPER12 xOp[10];
    static int i = 0;
    i = (i + 1) % 10;
    LPXLOPER12 op = &xOp[i];
    op->xltype = xltypeInt;
    op->val.w = val;
    return op;
}

// Utility: String Conversion
std::wstring StringToWString(const std::string& str) {
    if (str.empty()) return std::wstring();
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
    std::wstring wstrTo(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

std::string WideToUtf8(const std::wstring& wstr) {
    if (wstr.empty()) return "";
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
    std::string strTo(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
    return strTo;
}

// Optimization: Thread-local buffer for string conversion
// Avoids allocating std::string for every conversion.
thread_local std::vector<char> g_strBuf;

const char* ConvertExcelString(const wchar_t* wstr) {
    if (!wstr) return "";
    size_t len = (size_t)wstr[0]; // Pascal string length
    if (len == 0) return "";

    // Ensure buffer space (UTF-8 max expansion is 4x)
    size_t cap = len * 4 + 1;
    if (g_strBuf.size() < cap) g_strBuf.resize(cap);

    int n = WideCharToMultiByte(CP_UTF8, 0, wstr + 1, (int)len, g_strBuf.data(), (int)g_strBuf.size(), NULL, NULL);
    if (n >= 0) g_strBuf[n] = '\0';
    else g_strBuf[0] = '\0';

    return g_strBuf.data();
}

std::wstring GetSheetName(LPXLOPER12 pxRef) {
    if (!pxRef || (pxRef->xltype != xltypeRef && pxRef->xltype != xltypeSRef)) {
        return L"";
    }

    XLOPER12 xRes;
    int ret = Excel12(xlSheetNm, &xRes, 1, pxRef);
    if (ret != xlretSuccess) return L"";

    std::wstring result;
    if (xRes.xltype == xltypeStr && xRes.val.str) {
         size_t len = (size_t)xRes.val.str[0];
         if (len > 0) {
             result.assign(xRes.val.str + 1, len);
         }
    }
    Excel12(xlFree, 0, 1, &xRes);
    return result;
}

std::wstring GetXllDir() {
    wchar_t path[MAX_PATH];
    if (GetModuleFileNameW(g_hModule, path, MAX_PATH) == 0) return L"";
    std::wstring p(path);
    size_t pos = p.find_last_of(L"\\/");
    if (pos != std::wstring::npos) {
        return p.substr(0, pos);
    }
    return L".";
}

// Chunking helper
int SendChunked(const uint8_t* data, size_t size, std::vector<uint8_t>& respBuf, uint32_t timeoutMs) {
    // Thread-safe random number generation
    thread_local std::mt19937_64 rng(std::random_device{}());
    thread_local std::uniform_int_distribution<uint64_t> dist;
    uint64_t transferId = dist(rng);

    const size_t chunkSize = 950 * 1024; // 950KB
    size_t offset = 0;

    while (offset < size) {
        size_t len = std::min(chunkSize, size - offset);

        flatbuffers::FlatBufferBuilder b(1024 + len); // Approx
        auto dataOff = b.CreateVector(data + offset, len);
        // MSG_SETREFCACHE is 129
        auto chunk = ipc::CreateChunk(b, transferId, (uint32_t)size, (uint32_t)offset, dataOff, MSG_SETREFCACHE);
        b.Finish(chunk);

        // MsgID 128 for Chunk
        bool ok = g_host.Send(b.GetBufferPointer(), b.GetSize(), MSG_CHUNK, respBuf, timeoutMs);
        if (!ok) return -1; // Fail (Timeout)

        // Response must be Ack (MsgID 2)
        // Since DirectHost.Send is copy-based, respBuf contains the response.
        // But SendChunked usage in ConvertAny implies we check 'ok' and respBuf.
        // If it's a chunk, we expect Ack(2) with ok=true
        if (respBuf.empty()) return -1;

        // Check message type. Since Send() returns bool now, we must inspect the buffer or rely on caller?
        // Wait, DirectHost::Send (copy) fills respBuf. But we don't know the MsgID unless we parse it?
        // Actually, DirectHost::Send (copy) returns the *size* of response in some versions, or just bool.
        // The *provided code snippet* shows Send returning bool, and filling outResp.
        // We need to know if the response is an ACK.

        // Assuming standard protocol: Response to Chunk is Ack.
        auto ack = ipc::GetAck(respBuf.data());
        if (!ack || !ack->ok()) return -1;

        offset += len;
    }
    return 1; // Success
}

const uint8_t* ReceiveChunked(shm::ZeroCopySlot& slot, int reqMsgId, size_t reqSize, uint32_t timeoutMs) {
    bool ok = slot.Send(reqSize, reqMsgId, timeoutMs);
    if (!ok) return nullptr;

    // slot.GetRespMsgId() doesn't exist in the provided snippet.
    // But slot.GetRespBuffer() is available.
    // We need to know if it's a Chunk or standard response.
    // The snippet didn't include GetRespMsgId().
    // We can inspect the Slot header directly via slot object? No, slot.host is private.
    // Wait, the snippet had: `slot.header->msgType = msgType` for request.
    // Response MsgType is in slot->header->msgType? No, `slot->header` is private in ZeroCopySlot.

    // However, we can check if the buffer is a Chunk.
    if (ipc::ChunkBufferHasIdentifier(slot.GetRespBuffer())) {
        thread_local std::vector<uint8_t> buf;
        buf.clear();

        while(true) {
            auto chunk = ipc::GetChunk(slot.GetRespBuffer());
            auto data = chunk->data();
            buf.insert(buf.end(), data->begin(), data->end());

            if (buf.size() >= chunk->total_size()) return buf.data();

            // Request next chunk via Ack (MsgID 2)
            flatbuffers::FlatBufferBuilder b(128, nullptr, false, slot.GetReqBuffer());
            auto ack = ipc::CreateAck(b, chunk->id(), true);
            b.Finish(ack);

            if (!slot.Send(b.GetSize(), MSG_ACK, timeoutMs)) return nullptr;
            if (!ipc::ChunkBufferHasIdentifier(slot.GetRespBuffer())) return nullptr;
        }
    }
    return slot.GetRespBuffer();
}

flatbuffers::Offset<ipc::types::Range> ConvertRange(LPXLOPER12 op, flatbuffers::FlatBufferBuilder& builder) {
    if (!op) return 0;

    std::vector<ipc::types::Rect> refs;
    std::wstring sheetName = GetSheetName(op);

    if (op->xltype == xltypeRef) {
        if (op->val.mref.lpmref) {
            for (WORD i = 0; i < op->val.mref.lpmref->count; ++i) {
                const auto& r = op->val.mref.lpmref->reftbl[i];
                refs.emplace_back(r.rwFirst, r.rwLast, r.colFirst, r.colLast);
            }
        }
    } else if (op->xltype == xltypeSRef) {
        const auto& r = op->val.sref.ref;
        refs.emplace_back(r.rwFirst, r.rwLast, r.colFirst, r.colLast);
    }

    auto sheetNameOffset = builder.CreateString(WideToUtf8(sheetName));
    auto refsOffset = builder.CreateVectorOfStructs(refs);
    return ipc::types::CreateRange(builder, sheetNameOffset, refsOffset);
}

flatbuffers::Offset<ipc::types::Scalar> ConvertScalar(const XLOPER12& cell, flatbuffers::FlatBufferBuilder& builder) {
    if (cell.xltype == xltypeNum) {
        auto val = ipc::types::CreateNum(builder, cell.val.num);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Num, val.Union());
    } else if (cell.xltype == xltypeInt) {
        auto val = ipc::types::CreateInt(builder, cell.val.w);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Int, val.Union());
    } else if (cell.xltype == xltypeBool) {
        auto val = ipc::types::CreateBool(builder, cell.val.xbool);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Bool, val.Union());
    } else if (cell.xltype == xltypeStr) {
        auto s = ConvertExcelString(cell.val.str);
        auto sOff = builder.CreateString(s);
        auto val = ipc::types::CreateStr(builder, sOff);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Str, val.Union());
    } else if (cell.xltype == xltypeErr) {
        auto val = ipc::types::CreateErr(builder, (ipc::types::XlError)cell.val.err);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Err, val.Union());
    }
    auto val = ipc::types::CreateNil(builder);
    return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Nil, val.Union());
}

flatbuffers::Offset<ipc::types::Any> ConvertMultiToAny(const XLOPER12& xMulti, flatbuffers::FlatBufferBuilder& builder) {
    int rows = xMulti.val.array.rows;
    int cols = xMulti.val.array.columns;
    int count = rows * cols;

    bool allNum = true;
    for(int i=0; i<count; ++i) {
        if (xMulti.val.array.lparray[i].xltype != xltypeNum) {
            allNum = false;
            break;
        }
    }

    if (allNum) {
        std::vector<double> data;
        data.reserve(count);
        for(int i=0; i<count; ++i) {
            data.push_back(xMulti.val.array.lparray[i].val.num);
        }
        auto dataOff = builder.CreateVector(data);
        auto arr = ipc::types::CreateNumGrid(builder, rows, cols, dataOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_NumGrid, arr.Union());
    } else {
        std::vector<flatbuffers::Offset<ipc::types::Scalar>> data;
        data.reserve(count);
        for(int i=0; i<count; ++i) {
             data.push_back(ConvertScalar(xMulti.val.array.lparray[i], builder));
        }
        auto dataOff = builder.CreateVector(data);
        auto arr = ipc::types::CreateGrid(builder, rows, cols, dataOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Grid, arr.Union());
    }
}

flatbuffers::Offset<ipc::types::NumGrid> ConvertNumGrid(FP12* fp, flatbuffers::FlatBufferBuilder& builder) {
    if (!fp) return 0;
    int rows = fp->rows;
    int cols = fp->columns;
    int count = rows * cols;
    std::vector<double> data(count);
    for(int i=0; i<count; ++i) data[i] = fp->array[i];
    auto dataOff = builder.CreateVector(data);
    return ipc::types::CreateNumGrid(builder, rows, cols, dataOff);
}

flatbuffers::Offset<ipc::types::Grid> ConvertGrid(LPXLOPER12 op, flatbuffers::FlatBufferBuilder& builder) {
    if (!op) return 0;
    XLOPER12 xMulti;
    int ret = Excel12(xlCoerce, &xMulti, 2, op, TempInt12(xltypeMulti));
    if (ret != xlretSuccess) return 0;

    int rows = xMulti.val.array.rows;
    int cols = xMulti.val.array.columns;
    int count = rows * cols;
    std::vector<flatbuffers::Offset<ipc::types::Scalar>> data;
    data.reserve(count);
    for(int i=0; i<count; ++i) {
         data.push_back(ConvertScalar(xMulti.val.array.lparray[i], builder));
    }
    Excel12(xlFree, 0, 1, &xMulti);
    auto dataOff = builder.CreateVector(data);
    return ipc::types::CreateGrid(builder, rows, cols, dataOff);
}

flatbuffers::Offset<ipc::types::Any> ConvertAny(LPXLOPER12 op, flatbuffers::FlatBufferBuilder& builder) {
    if (!op) {
        auto nilVal = ipc::types::CreateNil(builder);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, nilVal.Union());
    }

    if (op->xltype == xltypeNum) {
        auto val = ipc::types::CreateNum(builder, op->val.num);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Num, val.Union());
    } else if (op->xltype == xltypeInt) {
        auto val = ipc::types::CreateInt(builder, op->val.w);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Int, val.Union());
    } else if (op->xltype == xltypeBool) {
        auto val = ipc::types::CreateBool(builder, op->val.xbool);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Bool, val.Union());
    } else if (op->xltype == xltypeStr) {
        auto s = ConvertExcelString(op->val.str);
        auto sOff = builder.CreateString(s);
        auto val = ipc::types::CreateStr(builder, sOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Str, val.Union());
    } else if (op->xltype == xltypeErr) {
        auto val = ipc::types::CreateErr(builder, (ipc::types::XlError)op->val.err);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Err, val.Union());
    } else if (op->xltype == xltypeMissing || op->xltype == xltypeNil) {
        auto val = ipc::types::CreateNil(builder);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, val.Union());
    } else if (op->xltype == xltypeRef || op->xltype == xltypeSRef) {
        long rows = 0;
        long cols = 0;
        std::wstring sheetName = GetSheetName(op);
        std::stringstream ss;
        ss << WideToUtf8(sheetName) << "!";

        if (op->xltype == xltypeRef) {
             if (op->val.mref.lpmref) {
                 for (WORD i = 0; i < op->val.mref.lpmref->count; ++i) {
                     const auto& r = op->val.mref.lpmref->reftbl[i];
                     rows += (r.rwLast - r.rwFirst + 1);
                     if (i==0) cols = (r.colLast - r.colFirst + 1);
                     ss << r.rwFirst << ":" << r.rwLast << ":" << r.colFirst << ":" << r.colLast << ";";
                 }
             }
        } else {
             const auto& r = op->val.sref.ref;
             rows = r.rwLast - r.rwFirst + 1;
             cols = r.colLast - r.colFirst + 1;
             ss << r.rwFirst << ":" << r.rwLast << ":" << r.colFirst << ":" << r.colLast;
        }

        long totalCells = rows * cols;
        std::string key = ss.str();

        bool useCache = (totalCells > 100);

        if (useCache) {
             std::lock_guard<std::mutex> lock(g_refCacheMutex);
             bool cached = g_sentRefCache[key];
             if (!cached) {
                  XLOPER12 xMulti;
                  int ret = Excel12(xlCoerce, &xMulti, 2, op, TempInt12(xltypeMulti));
                  if (ret == xlretSuccess) {
                      flatbuffers::FlatBufferBuilder reqB(1024);

                      auto anyOff = ConvertMultiToAny(xMulti, reqB);
                      auto keyOff = reqB.CreateString(key);
                      auto cacheReq = ipc::CreateSetRefCacheRequest(reqB, keyOff, anyOff);
                      reqB.Finish(cacheReq);

                      Excel12(xlFree, 0, 1, &xMulti);

                      std::vector<uint8_t> respBuf;
                      bool ok;
                      // Use default timeout (2s) or configured async_ack_timeout?
                      // This is a synchronous cache update (internal).
                      // We should probably use a reasonably short timeout.
                      // Let's use 2000ms (default) as it's a system op.
                      uint32_t timeoutMs = 2000;

                      if (reqB.GetSize() > 950 * 1024) {
                          ok = (SendChunked(reqB.GetBufferPointer(), reqB.GetSize(), respBuf, timeoutMs) > 0);
                      } else {
                          // MSG_SETREFCACHE (129)
                          ok = g_host.Send(reqB.GetBufferPointer(), reqB.GetSize(), MSG_SETREFCACHE, respBuf, timeoutMs);
                      }

                      if (ok && !respBuf.empty()) {
                          auto ack = ipc::GetAck(respBuf.data());
                          if (ack && ack->ok()) {
                              g_sentRefCache[key] = true;
                              cached = true;
                          }
                      }
                  }
             }

             if (cached) {
                 auto keyOff = builder.CreateString(key);
                 auto val = ipc::types::CreateRefCache(builder, keyOff);
                 return ipc::types::CreateAny(builder, ipc::types::AnyValue_RefCache, val.Union());
             }
        }

        XLOPER12 xMulti;
        int ret = Excel12(xlCoerce, &xMulti, 2, op, TempInt12(xltypeMulti));
        if (ret == xlretSuccess) {
             auto anyOff = ConvertMultiToAny(xMulti, builder);
             Excel12(xlFree, 0, 1, &xMulti);
             return anyOff;
        }
    }

    auto nilVal = ipc::types::CreateNil(builder);
    return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, nilVal.Union());
}

// Guest Call Handler (Async Return)
int32_t GuestHandler(const uint8_t* req, uint8_t* resp, uint32_t msgId) {
    switch (msgId) {
    case MSG_CHUNK: { // Chunk (128)
        static std::map<uint64_t, std::vector<uint8_t>> asyncChunks;
        auto chunk = ipc::GetChunk(req);
        auto id = chunk->id();
        auto data = chunk->data();

        std::vector<uint8_t>& buf = asyncChunks[id];
        if (buf.empty()) buf.reserve(chunk->total_size());

        buf.insert(buf.end(), data->begin(), data->end());

        if (buf.size() >= chunk->total_size()) {
             uint32_t originalMsgId = chunk->msg_id();
             std::vector<uint8_t> fullPayload = buf;
             asyncChunks.erase(id);
             return GuestHandler(fullPayload.data(), resp, originalMsgId);
        }

        // Send Ack (MsgID 2) to request next
        flatbuffers::FlatBufferBuilder ackB(64);
        auto ack = ipc::CreateAck(ackB, id, true);
        ackB.Finish(ack);
        memcpy(resp, ackB.GetBufferPointer(), ackB.GetSize());
        return ackB.GetSize();
    }
{{range $i, $fn := .Functions}}
    {{if .Async}}
    case {{add 132 $i}}: { // {{.Name}}
        auto response = flatbuffers::GetRoot<ipc::{{.Name}}Response>(req);
        LPXLOPER12 h = (LPXLOPER12)response->async_handle();

        if (response->error() && response->error()->size() > 0) {
            XLOPER12 xErr; xErr.xltype = xltypeErr; xErr.val.err = xlErrValue;
            Excel12(xlAsyncReturn, 0, 2, h, &xErr);
            return 0;
        }

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(response->result()->str());
        LPXLOPER12 xRes = NewExcelString(wres.c_str());
        Excel12(xlAsyncReturn, 0, 2, h, xRes);
        // NewExcelString sets xlbitDLLFree, so we can use xlAutoFree12 to clean it up.
        // This handles both the string buffer and returning the XLOPER12 to the pool.
        xlAutoFree12(xRes);
        {{else if eq .Return "int"}}
        XLOPER12 xRes; xRes.xltype = xltypeInt; xRes.val.w = response->result();
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{else if eq .Return "float"}}
        XLOPER12 xRes; xRes.xltype = xltypeNum; xRes.val.num = response->result();
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{else if eq .Return "bool"}}
        XLOPER12 xRes; xRes.xltype = xltypeBool; xRes.val.xbool = response->result() ? 1 : 0;
        Excel12(xlAsyncReturn, 0, 2, h, &xRes);
        {{end}}
        return 0;
    }
    {{end}}
{{end}}
    default:
        return 0;
    }
}

extern "C" {

__declspec(dllexport) int __stdcall xlAutoOpen() {
    // Determine worker count
    int workers = {{.Server.Workers}};
    if (workers <= 0) {
        workers = std::thread::hardware_concurrency();
        if (workers == 0) workers = 16; // Fallback
    }

    // 1024 queue items, 1MB buffer size per slot
    {{if .ShouldAppendPid}}
    std::string shmName = "{{.ProjectName}}_" + std::to_string(GetCurrentProcessId());
    {{else}}
    std::string shmName = "{{.ProjectName}}";
    {{end}}

    if (!g_host.Init(shmName.c_str(), 1024, 1024*1024, workers)) {
        return 0;
    }

    g_running = true;
    g_worker = std::thread([]{
        while(g_running) {
             int n = g_host.ProcessGuestCalls(GuestHandler);
             if (n == 0) std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    });

    static XLOPER12 xDll;
    Excel12(xlGetName, &xDll, 0);

{{range .Events}}
    Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Name}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }
    {{end}}

{{range $i, $fn := .Functions}}
    {
        Excel12(xlfRegister, 0, {{registerCount $fn}},
            &xDll,
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{if .Async}}>{{end}}{{lookupXllType .Return}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}$"),
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{joinArgNames $fn}}"),
            TempStr12(L"1"),
            TempStr12(L"{{withDefault .Category $.ProjectName}}"),
            TempStr12(L"{{.Shortcut}}"),
            TempStr12(L"{{.HelpTopic}}"),
            TempStr12(L"{{.Description}}"){{if .Args}},{{end}}
            {{range $j, $arg := .Args}}TempStr12(L"{{$arg.Description}}"){{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}
            {{if .Async}}{{if .Args}},{{end}}TempStr12(L"Async Handle"){{end}}
        );
    }
{{end}}

{{if .Server.Launch}}
{{if derefBool .Server.Launch.Enabled}}
    // Launch Logic
    {
        std::wstring xllDir = GetXllDir();

        // Resolve CWD
        std::wstring cwd = xllDir;
        {{if .Server.Launch.Cwd}}
        std::string cfgCwd = "{{.Server.Launch.Cwd}}";
        if (cfgCwd != ".") {
            std::wstring wCwd = StringToWString(cfgCwd);
            bool isAbs = (wCwd.find(L":") != std::wstring::npos || (wCwd.size() > 1 && wCwd[0] == L'\\' && wCwd[1] == L'\\'));
            if (isAbs) {
                cwd = wCwd;
            } else {
                cwd = xllDir + L"\\" + wCwd;
            }
        }
        {{end}}

        // Resolve Command
        std::wstring exePath = xllDir + L"\\{{.ProjectName}}.exe";
        {{if .Server.Launch.Command}}
        std::string cfgCmd = "{{.Server.Launch.Command}}";
        std::wstring wCmd = StringToWString(cfgCmd);
        bool isCmdAbs = (wCmd.find(L":") != std::wstring::npos || (wCmd.size() > 1 && wCmd[0] == L'\\' && wCmd[1] == L'\\'));
        if (isCmdAbs) {
            exePath = wCmd;
        } else {
             if (cfgCmd.find("./") == 0 || cfgCmd.find(".\\") == 0) {
                 exePath = cwd + L"\\" + wCmd.substr(2);
            } else {
                 exePath = cwd + L"\\" + wCmd;
            }
        }
        {{end}}

        // Append SHM Flag (Quote the executable path to handle spaces)
        std::wstring cmd = L"\"" + exePath + L"\" -xll-shm=" + StringToWString(shmName);

        // Setup Log File
        std::wstring logPath = cwd + L"\\xll_launch.log";
        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = NULL;

        HANDLE hLog = CreateFileW(logPath.c_str(), FILE_APPEND_DATA, FILE_SHARE_READ, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hLog != INVALID_HANDLE_VALUE) {
            STARTUPINFOW si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags |= STARTF_USESTDHANDLES;
            si.hStdOutput = hLog;
            si.hStdError = hLog;
            si.hStdInput = NULL;

            PROCESS_INFORMATION pi;
            ZeroMemory(&pi, sizeof(pi));

            // Need mutable string for CreateProcess
            std::vector<wchar_t> cmdBuf(cmd.begin(), cmd.end());
            cmdBuf.push_back(0);

            if (CreateProcessW(NULL, cmdBuf.data(), NULL, NULL, TRUE, 0, NULL, cwd.c_str(), &si, &pi)) {
                g_hChildProcess = pi.hProcess;
                CloseHandle(pi.hThread);
            }

            CloseHandle(hLog);
        }
    }
{{end}}
{{end}}

    Excel12(xlFree, 0, 1, &xDll);
    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    g_running = false;
    if (g_worker.joinable()) g_worker.join();
    g_host.Shutdown();

    if (g_hChildProcess) {
        TerminateProcess(g_hChildProcess, 0);
        CloseHandle(g_hChildProcess);
        g_hChildProcess = NULL;
    }
    return 1;
}

{{range .Events}}
__declspec(dllexport) void __stdcall {{.Name}}() {
    {{if eq .Type "CalculationEnded"}}
    {
        std::lock_guard<std::mutex> lock(g_refCacheMutex);
        g_sentRefCache.clear();
    }
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, MSG_CALCULATION_ENDED); // Send takes (size, msgType, timeout)
    {{else if eq .Type "CalculationCanceled"}}
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, MSG_CALCULATION_CANCELED);
    {{else}}
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, {{lookupEventId .Type}});
    {{end}}
}
{{end}}
{{if hasEvent "CalculationEnded" .Events}}
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    {
        std::lock_guard<std::mutex> lock(g_refCacheMutex);
        g_sentRefCache.clear();
    }
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(0, MSG_CALCULATION_ENDED);
}
{{end}}

{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupArgCppType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {

    auto slot = g_host.GetZeroCopySlot();
    flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), nullptr, false, slot.GetReqBuffer());

    {{range .Args}}
    {{if eq .Type "string"}}
    auto {{.Name}}_off = builder.CreateString(ConvertExcelString({{.Name}}));
    {{else if eq .Type "int?"}}
    flatbuffers::Offset<ipc::types::Int> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateInt(builder, *{{.Name}});
    }
    {{else if eq .Type "float?"}}
    flatbuffers::Offset<ipc::types::Num> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateNum(builder, *{{.Name}});
    }
    {{else if eq .Type "bool?"}}
    flatbuffers::Offset<ipc::types::Bool> {{.Name}}_off = 0;
    if ({{.Name}}) {
        {{.Name}}_off = ipc::types::CreateBool(builder, (*{{.Name}} != 0));
    }
    {{else if eq .Type "range"}}
    auto {{.Name}}_off = ConvertRange({{.Name}}, builder);
    {{else if eq .Type "grid"}}
    auto {{.Name}}_off = ConvertGrid({{.Name}}, builder);
    {{else if eq .Type "numgrid"}}
    auto {{.Name}}_off = ConvertNumGrid({{.Name}}, builder);
    {{else if eq .Type "any"}}
    auto {{.Name}}_off = ConvertAny({{.Name}}, builder);
    {{end}}
    {{end}}

    {{if .Caller}}
    flatbuffers::Offset<ipc::types::Range> caller_off = 0;
    {
        XLOPER12 xCaller;
        if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
            caller_off = ConvertRange(&xCaller, builder);
            if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                Excel12(xlFree, 0, 1, &xCaller);
            }
        }
    }
    {{end}}

    ipc::{{.Name}}RequestBuilder reqBuilder(builder);
    {{range .Args}}
    {{if eq .Type "string"}}
    reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "int?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "float?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "bool?"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "range"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "grid"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "numgrid"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else if eq .Type "any"}}
    if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
    {{else}}
    reqBuilder.add_{{.Name}}({{.Name}});
    {{end}}
    {{end}}
    {{if .Caller}}
    if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
    {{end}}
    {{if .Async}}
    reqBuilder.add_async_handle((uint64_t)asyncHandle);
    {{end}}
    auto req = reqBuilder.Finish();
    builder.Finish(req);

    // Zero-Copy Send (Size, MsgId, Timeout)
    {{if .Async}}
    // Async Handshake Timeout: Function override OR Global AsyncAckTimeout (default 2000)
    {{ $ackTimeout := parseTimeout .Timeout 0 }}
    {{ if eq $ackTimeout 0 }}{{ $ackTimeout = parseTimeout $.Server.AsyncAckTimeout 2000 }}{{ end }}
    bool ok = slot.Send(builder.GetSize(), {{add 132 $i}}, {{ $ackTimeout }});
    if (!ok) return;
    return;
    {{else}}
    // Sync Calculation Timeout: Function override OR Global Timeout (default 2000)
    {{ $syncTimeout := parseTimeout .Timeout 0 }}
    {{ if eq $syncTimeout 0 }}{{ $syncTimeout = parseTimeout $.Server.Timeout 2000 }}{{ end }}
    const uint8_t* respBuf = ReceiveChunked(slot, {{add 132 $i}}, builder.GetSize(), {{ $syncTimeout }});
    if (!respBuf) return {{defaultErrorVal .Return}};

    auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(respBuf);
    if (resp->error() && resp->error()->size() > 0) {
        return {{defaultErrorVal .Return}};
    }

    {{if eq .Return "string"}}
    std::wstring wres = StringToWString(resp->result()->str());
    return NewExcelString(wres.c_str());
    {{else}}
    return resp->result();
    {{end}}
    {{end}}
}
{{end}}

} // extern "C"
