
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
#include <windows.h>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <map>
#include <mutex>
#include <sstream>
#include <wchar.h>
#include <random>
#include <iostream>
#include <fstream>
#include <cstring>
#include "include/xlcall.h"
#include "include/xll_mem.h"
#include "include/xll_utility.h"
#include "include/xll_ipc.h"
#include "include/xll_converters.h"
#include "include/xll_log.h"
#include "include/xll_commands.h"
#include "include/xll_async.h"
#include "include/SHMAllocator.h"
#include "include/PascalString.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
{{if eq .Build.Singlefile "xll"}}
#include "include/xll_embed.h"
{{end}}

std::thread g_worker;
std::thread g_monitor;
std::atomic<bool> g_running{false};

// Global Process Handle (for auto-launched server)
HANDLE g_hChildProcess = NULL;
HANDLE g_hJob = NULL;
HANDLE g_hShutdownEvent = NULL;
HINSTANCE g_hModule = NULL;

// Global Error Value for Returns
static XLOPER12 g_xlErrValue;

// Helper for creating string XLOPER12 without pool (for batching)
// We cannot use the global ObjectPool because xlAsyncReturn with xltypeMulti
// requires a contiguous array of XLOPER12 structs, while the pool provides
// pointers to scattered individual objects.
XLOPER12 CreateStringXLOPER(const std::wstring& str) {
    XLOPER12 x;
    x.xltype = xltypeStr;
    std::vector<wchar_t> pstr = WStringToPascalString(str);
    x.val.str = new wchar_t[pstr.size()];
    std::memcpy(x.val.str, pstr.data(), pstr.size() * sizeof(wchar_t));
    return x;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);

        // Initialize global error
        g_xlErrValue.xltype = xltypeErr;
        g_xlErrValue.val.err = xlerrValue;
    }
    return TRUE;
}

#ifdef SHM_DEBUG
static void LogHandler(shm::LogLevel level, const std::string& msg) {
    std::string prefix = "";
    switch (level) {
        case shm::LogLevel::TRACE: prefix = "[TRACE] "; break;
        case shm::LogLevel::DEBUG: prefix = "[DEBUG] "; break;
        case shm::LogLevel::INFO:  prefix = "[INFO]  "; break;
        case shm::LogLevel::WARN:  prefix = "[WARN]  "; break;
        case shm::LogLevel::ERROR: prefix = "[ERROR] "; break;
    }
    LogError(prefix + msg);
}
#endif

// Helper to replace all occurrences of a substring
void ReplaceAll(std::wstring& str, const std::wstring& from, const std::wstring& to) {
    if(from.empty()) return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::wstring::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
}

bool FileExists(const std::wstring& path) {
    DWORD dwAttrib = GetFileAttributesW(path.c_str());
    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

extern "C" {

__declspec(dllexport) int __stdcall xlAutoOpen() {
    {{if .Logging.Path}}
    // Setup Native Logging
    std::string tempPattern = "";
    std::string projName = "{{.ProjectName}}";
    bool isSingleFile = false;

    {{if eq .Build.Singlefile "xll"}}
    isSingleFile = true;
    tempPattern = "{{.Build.TempDir}}";
    {{end}}

    InitLog(L"{{.Logging.Path}}", tempPattern, projName, isSingleFile);
    {{end}}

#ifdef SHM_DEBUG
    shm::SetLogHandler(LogHandler);
#endif

    // Determine worker count
    int workers = {{.Server.Workers}};
    if (workers <= 0) {
        workers = std::thread::hardware_concurrency();
        if (workers == 0) workers = 16; // Fallback
    }

    // 1024 queue items, 1MB buffer size per slot
    {{if .ShouldAppendPid}}
    std::string shmName = "{{.ProjectName}}_" + std::to_string(GetCurrentProcessId());
    {{else}}
    std::string shmName = "{{.ProjectName}}";
    {{end}}

    g_hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // Configure SHM
    shm::HostConfig config;
    config.shmName = shmName;
    config.numHostSlots = workers * 2 + 2; // Support nested IPC (depth 1) + margin
    config.payloadSize = 1024 * 1024;      // 1MB per slot

    // Init Host
    if (!g_host.Init(config)) {
        LogError("Failed to initialize Shared Memory with name: " + shmName);
        return 0;
    }

    g_running = true;
    g_worker = std::thread([]{
        // Reusable vectors for batch processing
        std::vector<XLOPER12> handles;
        std::vector<XLOPER12> values;
        handles.reserve(256);
        values.reserve(256);

        g_host.Start([&handles, &values](const uint8_t* req, int32_t size, uint8_t* resp, uint32_t capacity, shm::MsgType msgId) -> int32_t {
             static std::map<uint64_t, std::vector<uint8_t>> chunkBuffers;
             static std::map<uint64_t, size_t> chunkSizes;

             try {
                 switch (msgId) {
                 case (shm::MsgType)129: { // MSG_CHUNK
                     auto chunk = flatbuffers::GetRoot<ipc::Chunk>(req);
                     uint64_t id = chunk->id();

                     std::vector<uint8_t>& buf = chunkBuffers[id];
                     if (buf.empty()) {
                         buf.resize(chunk->total_size());
                         chunkSizes[id] = 0;
                     }

                     auto data = chunk->data();
                     if (data) {
                         size_t offset = chunk->offset();
                         size_t len = data->size();
                         if (offset + len <= buf.size()) {
                             std::memcpy(buf.data() + offset, data->data(), len);
                             chunkSizes[id] += len;
                         }
                     }

                     if (chunkSizes[id] >= buf.size()) {
                         shm::MsgType payloadType = (shm::MsgType)chunk->msg_type();
                         int32_t ret = 0;
                         if (payloadType == (shm::MsgType)128) {
                             ret = ProcessAsyncBatchResponse(buf.data(), handles, values);
                         }
                         chunkBuffers.erase(id);
                         chunkSizes.erase(id);
                         return ret;
                     }
                     return 1; // ACK
                 }
                 case (shm::MsgType)128: { // MSG_BATCH_ASYNC_RESPONSE
                     return ProcessAsyncBatchResponse(req, handles, values);
                 }
                 default:
                     return 0;
                 }
             } catch (const std::exception& e) {
                 LogError("Exception in guest call handler: " + std::string(e.what()));
                 return 0;
             } catch (...) {
                 LogError("Unknown exception in guest call handler");
                 return 0;
             }
        });
    });

    static XLOPER12 xDll;
    Excel12(xlGetName, &xDll, 0);

{{range .Events}}
    Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Name}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationCanceled"), TempInt12(xleventCalculationCanceled));
    }
    {{end}}

{{range $i, $fn := .Functions}}
    {
        Excel12(xlfRegister, 0, {{registerCount $fn}},
            &xDll,
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{if .Async}}>{{else}}{{lookupXllType .Return}}{{end}}{{range .Args}}{{lookupArgXllType .Type}}{{end}}{{if .Async}}X{{end}}$"),
            TempStr12(L"{{.Name}}"),
            TempStr12(L"{{joinArgNames $fn}}"),
            TempStr12(L"1"),
            TempStr12(L"{{withDefault .Category $.ProjectName}}"),
            TempStr12(L"{{.Shortcut}}"),
            TempStr12(L"{{.HelpTopic}}"),
            TempStr12(L"{{.Description}}"){{if .Args}},{{end}}
            {{range $j, $arg := .Args}}TempStr12(L"{{$arg.Description}}"){{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}
        );
    }
{{end}}

{{if .Server.Launch}}
{{if derefBool .Server.Launch.Enabled}}
    // Launch Logic
    {
        // Create Job Object to ensure child process termination on exit
        g_hJob = CreateJobObject(NULL, NULL);
        if (g_hJob) {
            JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = { 0 };
            jeli.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
            SetInformationJobObject(g_hJob, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli));
        }

        std::wstring xllDir = GetXllDir();

        // Resolve CWD
        std::wstring cwd = xllDir;
        {{if .Server.Launch.Cwd}}
        std::string cfgCwd = "{{.Server.Launch.Cwd}}";
        if (cfgCwd != ".") {
            std::wstring wCwd = StringToWString(cfgCwd);
            bool isAbs = (wCwd.find(L":") != std::wstring::npos || (wCwd.size() > 1 && wCwd[0] == L'\\' && wCwd[1] == L'\\'));
            if (isAbs) {
                cwd = wCwd;
            } else {
                cwd = xllDir + L"\\" + wCwd;
            }
        }
        {{end}}

        // 1. Determine Default Binary Path
        std::wstring defaultBinPath;
{{if eq .Build.Singlefile "xll"}}
        // EMBEDDED MODE
        std::string extractedExe = embed::ExtractEmbeddedExe("{{.Build.TempDir}}", "{{.ProjectName}}");
        if (!extractedExe.empty()) {
            defaultBinPath = StringToWString(extractedExe);
            // In singlefile mode, run from the temp dir so logs appear there
            size_t lastSlash = defaultBinPath.find_last_of(L"\\");
            if (lastSlash != std::wstring::npos) {
                cwd = defaultBinPath.substr(0, lastSlash);
            }
        } else {
             // Fallback: Check standard locations
             std::wstring sameDir = xllDir + L"\\{{.ProjectName}}.exe";
             if (FileExists(sameDir)) {
                 defaultBinPath = sameDir;
             } else {
                 // Check parent directory (Standard Go build output in dev)
                 size_t lastSlash = xllDir.find_last_of(L"\\");
                 if (lastSlash != std::wstring::npos) {
                     std::wstring parentDir = xllDir.substr(0, lastSlash);
                     std::wstring parentExe = parentDir + L"\\{{.ProjectName}}.exe";
                     if (FileExists(parentExe)) {
                         defaultBinPath = parentExe;
                     } else {
                         defaultBinPath = sameDir; // Default to same dir for consistent error message
                     }
                 } else {
                      defaultBinPath = sameDir;
                 }
             }
        }
{{else}}
        // STANDARD MODE
        // Check same dir, then parent
        std::wstring sameDir = xllDir + L"\\{{.ProjectName}}.exe";
        if (FileExists(sameDir)) {
            defaultBinPath = sameDir;
        } else {
            size_t lastSlash = xllDir.find_last_of(L"\\");
            if (lastSlash != std::wstring::npos) {
                std::wstring parentDir = xllDir.substr(0, lastSlash);
                std::wstring parentExe = parentDir + L"\\{{.ProjectName}}.exe";
                if (FileExists(parentExe)) {
                    defaultBinPath = parentExe;
                } else {
                    defaultBinPath = sameDir;
                }
            } else {
                defaultBinPath = sameDir;
            }
        }
{{end}}

        // 2. Resolve Configured Command
        std::wstring exePath = defaultBinPath;
        {{if .Server.Launch.Command}}
        std::string cfgCmd = "{{.Server.Launch.Command}}";
        if (!cfgCmd.empty()) {
            std::wstring wCmd = StringToWString(cfgCmd);

            // Check for ${BIN} variable
            std::wstring varBin = L"${BIN}";
            if (wCmd.find(varBin) != std::wstring::npos) {
                ReplaceAll(wCmd, varBin, defaultBinPath);
                exePath = wCmd;
            } else {
{{if eq .Build.Singlefile "xll"}}
                // In singlefile mode, if the command explicitly points to the project executable (default config),
                // we should ignore it and use the extracted binary path instead.
                std::string projExe = "{{.ProjectName}}.exe";
                if (cfgCmd.find(projExe) != std::string::npos) {
                    // Ignore, keep exePath as defaultBinPath (extracted)
                } else {
{{end}}
                // Legacy/Standard relative path resolution
                // If the user provided a specific path without ${BIN}
                // We keep the existing logic that checks for absolute paths or prepends cwd/xllDir

                bool isCmdAbs = (wCmd.find(L":") != std::wstring::npos || (wCmd.size() > 1 && wCmd[0] == L'\\' && wCmd[1] == L'\\'));
                if (isCmdAbs) {
                    exePath = wCmd;
                } else {
                     if (cfgCmd.find("./") == 0 || cfgCmd.find(".\\") == 0) {
                         exePath = cwd + L"\\" + wCmd.substr(2);
                    } else {
                         exePath = cwd + L"\\" + wCmd;
                    }
                }
{{if eq .Build.Singlefile "xll"}}
                }
{{end}}
            }
        }
        {{end}}

        // Append SHM Flag (Quote the executable path to handle spaces)
        // If the path already starts with a quote (e.g. user provided "${BIN}" or "path"), assume it's a full command line and don't add outer quotes.
        std::wstring cmd;
        if (!exePath.empty() && exePath[0] == L'"') {
            cmd = exePath + L" -xll-shm=" + StringToWString(shmName);
        } else {
            cmd = L"\"" + exePath + L"\" -xll-shm=" + StringToWString(shmName);
        }

        // Setup Log File
        std::wstring logPath = cwd + L"\\xll_launch.log";
        SECURITY_ATTRIBUTES sa;
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = TRUE;
        sa.lpSecurityDescriptor = NULL;

        HANDLE hLog = CreateFileW(logPath.c_str(), FILE_APPEND_DATA, FILE_SHARE_READ, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hLog != INVALID_HANDLE_VALUE) {
            STARTUPINFOW si;
            ZeroMemory(&si, sizeof(si));
            si.cb = sizeof(si);
            si.dwFlags |= STARTF_USESTDHANDLES;
            si.hStdOutput = hLog;
            si.hStdError = hLog;
            si.hStdInput = NULL;

            PROCESS_INFORMATION pi;
            ZeroMemory(&pi, sizeof(pi));

            // Need mutable string for CreateProcess
            std::vector<wchar_t> cmdBuf(cmd.begin(), cmd.end());
            cmdBuf.push_back(0);

            if (CreateProcessW(NULL, cmdBuf.data(), NULL, NULL, TRUE, 0, NULL, cwd.c_str(), &si, &pi)) {
                g_hChildProcess = pi.hProcess;
                CloseHandle(pi.hThread);
                if (g_hJob) {
                    AssignProcessToJobObject(g_hJob, g_hChildProcess);
                }

                // Monitor Thread
                g_monitor = std::thread([logPath]{
                    HANDLE handles[2] = { g_hChildProcess, g_hShutdownEvent };
                    DWORD res = WaitForMultipleObjects(2, handles, FALSE, INFINITE);

                    if (res == WAIT_OBJECT_0) {
                        // Check if shutdown was requested concurrently
                        if (WaitForSingleObject(g_hShutdownEvent, 0) == WAIT_TIMEOUT) {
                            if (g_running) {
                                DWORD exitCode = 0;
                                GetExitCodeProcess(g_hChildProcess, &exitCode);

                                std::wstringstream ss;
                                ss << L"The Go server process has terminated unexpectedly (Exit Code: " << exitCode << L").\n";
                                ss << L"The Add-in will no longer function correctly.\n\n";
                                ss << L"Last log entries:\n";

                                HANDLE hRead = CreateFileW(logPath.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                                if (hRead != INVALID_HANDLE_VALUE) {
                                    LARGE_INTEGER size;
                                    if (GetFileSizeEx(hRead, &size)) {
                                        long long length = size.QuadPart;
                                        long long start = 0;
                                        if (length > 1024) start = length - 1024;

                                        LARGE_INTEGER move;
                                        move.QuadPart = start;
                                        SetFilePointerEx(hRead, move, NULL, FILE_BEGIN);

                                        std::vector<char> buffer((size_t)(length - start));
                                        DWORD bytesRead = 0;
                                        if (ReadFile(hRead, buffer.data(), (DWORD)buffer.size(), &bytesRead, NULL)) {
                                            std::string s(buffer.data(), bytesRead);
                                            ss << StringToWString(s);
                                        }
                                    }
                                    CloseHandle(hRead);
                                } else {
                                    ss << L"(Unable to read log file)";
                                }

                                MessageBoxW(NULL, ss.str().c_str(), L"Server Crash", MB_OK | MB_ICONERROR);
                            }
                        }
                    }
                });
            } else {
                // Process creation failed
                std::wstring msg = L"Failed to launch Go server.\nCommand: " + cmd;
                LogError(WideToUtf8(msg));
                MessageBoxW(NULL, msg.c_str(), L"Launch Error", MB_OK | MB_ICONERROR);
                if (g_hJob) { CloseHandle(g_hJob); g_hJob = NULL; }

                // Cleanup to allow safe unload
                g_running = false;
                if (g_worker.joinable()) g_worker.join();
                g_host.Shutdown();

                Excel12(xlFree, 0, 1, &xDll);
                return 0;
            }

            CloseHandle(hLog);
        }
    }
{{end}}
{{end}}

    Excel12(xlFree, 0, 1, &xDll);
    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    if (g_hShutdownEvent) SetEvent(g_hShutdownEvent);

    g_running = false;
    if (g_worker.joinable()) g_worker.join();
    g_host.Shutdown();

    if (g_hChildProcess) {
        TerminateProcess(g_hChildProcess, 0);
        // This will signal the monitor thread to wake up
    }

    if (g_monitor.joinable()) g_monitor.join();

    if (g_hChildProcess) {
        CloseHandle(g_hChildProcess);
        g_hChildProcess = NULL;
    }
    if (g_hJob) {
        CloseHandle(g_hJob);
        g_hJob = NULL;
    }
    if (g_hShutdownEvent) {
        CloseHandle(g_hShutdownEvent);
        g_hShutdownEvent = NULL;
    }
    return 1;
}

{{range .Events}}
__declspec(dllexport) void __stdcall {{.Name}}() {
    try {
        {{if eq .Type "CalculationEnded"}}
        {
            std::lock_guard<std::mutex> lock(g_refCacheMutex);
            g_sentRefCache.clear();
        }
        std::vector<uint8_t> respBuf;
        auto res = g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_ENDED, respBuf, 2000);
        if (res && res.Value() > 0) {
             auto resp = flatbuffers::GetRoot<ipc::CalculationEndedResponse>(respBuf.data());
             ExecuteCommands(resp);
        } else {
            // LogError("Failed to send CalculationEnded event or invalid response");
        }
        {{else if eq .Type "CalculationCanceled"}}
        std::vector<uint8_t> respBuf;
        g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_CANCELED, respBuf, 2000);
        {{else}}
        std::vector<uint8_t> respBuf;
        g_host.Send(nullptr, 0, (shm::MsgType){{lookupEventId .Type}}, respBuf, 2000);
        {{end}}
    } catch (const std::exception& e) {
        LogError("Exception in event handler {{.Name}}: " + std::string(e.what()));
    } catch (...) {
        LogError("Unknown exception in event handler {{.Name}}");
    }
}
{{end}}
{{if hasEvent "CalculationEnded" .Events}}
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    try {
        {
            std::lock_guard<std::mutex> lock(g_refCacheMutex);
            g_sentRefCache.clear();
        }
        std::vector<uint8_t> respBuf;
        auto res = g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_ENDED, respBuf, 2000);
        if (res && res.Value() > 0) {
             auto resp = flatbuffers::GetRoot<ipc::CalculationEndedResponse>(respBuf.data());
             ExecuteCommands(resp);
        }
    } catch (const std::exception& e) {
        LogError("Exception in CalculationEnded: " + std::string(e.what()));
    } catch (...) {
        LogError("Unknown exception in CalculationEnded");
    }
}
{{end}}
{{if hasEvent "CalculationCanceled" .Events}}
{{else}}
__declspec(dllexport) void __stdcall CalculationCanceled() {
    try {
        std::vector<uint8_t> respBuf;
        g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_CANCELED, respBuf, 2000);
        {
            std::lock_guard<std::mutex> lock(g_refCacheMutex);
            g_sentRefCache.clear();
        }
    } catch (const std::exception& e) {
        LogError("Exception in CalculationCanceled: " + std::string(e.what()));
    } catch (...) {
        LogError("Unknown exception in CalculationCanceled");
    }
}
{{end}}

{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupArgCppType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    try {
        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

        {{range .Args}}
        {{if eq .Type "string"}}
        auto {{.Name}}_off = builder.CreateString(ConvertExcelString(({{.Name}} && {{.Name}}->xltype == xltypeStr) ? {{.Name}}->val.str : nullptr));
        {{else if eq .Type "int?"}}
        flatbuffers::Offset<ipc::types::Int> {{.Name}}_off = 0;
        if ({{.Name}}) {
            {{.Name}}_off = ipc::types::CreateInt(builder, *{{.Name}});
        }
        {{else if eq .Type "float?"}}
        flatbuffers::Offset<ipc::types::Num> {{.Name}}_off = 0;
        if ({{.Name}}) {
            {{.Name}}_off = ipc::types::CreateNum(builder, *{{.Name}});
        }
        {{else if eq .Type "bool?"}}
        flatbuffers::Offset<ipc::types::Bool> {{.Name}}_off = 0;
        if ({{.Name}}) {
            {{.Name}}_off = ipc::types::CreateBool(builder, (*{{.Name}} != 0));
        }
        {{else if eq .Type "range"}}
        auto {{.Name}}_off = ConvertRange({{.Name}}, builder);
        {{else if eq .Type "grid"}}
        auto {{.Name}}_off = ConvertGrid({{.Name}}, builder);
        {{else if eq .Type "numgrid"}}
        auto {{.Name}}_off = ConvertNumGrid({{.Name}}, builder);
        {{else if eq .Type "any"}}
        auto {{.Name}}_off = ConvertAny({{.Name}}, builder);
        {{end}}
        {{end}}

        {{if .Caller}}
        flatbuffers::Offset<ipc::types::Range> caller_off = 0;
        {
            XLOPER12 xCaller;
            if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
                caller_off = ConvertRange(&xCaller, builder);
                if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                    Excel12(xlFree, 0, 1, &xCaller);
                }
            }
        }
        {{end}}

        ipc::{{.Name}}RequestBuilder reqBuilder(builder);
        {{range .Args}}
        {{if eq .Type "string"}}
        reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "int?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "float?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "bool?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "range"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "grid"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "numgrid"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "any"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else}}
        reqBuilder.add_{{.Name}}({{.Name}});
        {{end}}
        {{end}}
        {{if .Caller}}
        if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
        {{end}}
        {{if .Async}}
        reqBuilder.add_async_handle((uint64_t)asyncHandle);
        {{end}}
        auto req = reqBuilder.Finish();
        builder.Finish(req);

        // Zero-Copy Send (Size, MsgId, Timeout)
        // We send negative size to indicate the data is at the end of the buffer (Zero-Copy).
        int32_t reqSize = -((int32_t)builder.GetSize());

        {{if .Async}}
        // Async Handshake Timeout: Function override OR Global AsyncAckTimeout (default 2000)
        {{ $ackTimeout := parseTimeout .Timeout 0 }}
        {{ if eq $ackTimeout 0 }}{{ $ackTimeout = parseTimeout $.Server.AsyncAckTimeout 2000 }}{{ end }}
        auto res = slot.Send(reqSize, (shm::MsgType)({{add 133 $i}}), {{ $ackTimeout }});
        if (res.HasError()) {
            LogError("Failed to send async request for {{.Name}}");
        }
        return;
        {{else}}
        // Sync Calculation Timeout: Function override OR Global Timeout (default 2000)
        {{ $syncTimeout := parseTimeout .Timeout 0 }}
        {{ if eq $syncTimeout 0 }}{{ $syncTimeout = parseTimeout $.Server.Timeout 2000 }}{{ end }}
        auto res = slot.Send(reqSize, (shm::MsgType)({{add 133 $i}}), {{ $syncTimeout }});
        if (res.HasError()) {
            LogError("Failed to send request for {{.Name}}");
            return {{defaultErrorVal .Return}};
        }

        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(slot.GetRespBuffer());
        if (resp->error() && resp->error()->size() > 0) {
            LogError("Error executing {{.Name}}: " + resp->error()->str());
            return {{defaultErrorVal .Return}};
        }

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
        {{end}}
    } catch (const std::exception& e) {
        LogError("Exception in {{.Name}}: " + std::string(e.what()));
        {{if .Async}}return;{{else}}return {{defaultErrorVal .Return}};{{end}}
    } catch (...) {
        LogError("Unknown exception in {{.Name}}");
        {{if .Async}}return;{{else}}return {{defaultErrorVal .Return}};{{end}}
    }
}
{{end}}

} // extern "C"
