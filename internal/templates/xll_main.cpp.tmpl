// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
// This file contains the main entry point and XLL interface functions.

#include <windows.h>
#include <xlcall.h>
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>
#include <filesystem>
#include <sstream>
#include <map>
#include "include/xll_log.h"
#include "include/xll_mem.h"
#include "include/xll_converters.h"
#include "include/xll_utility.h"
#include "include/PascalString.h"
#include "include/xll_launch.h"
#include "include/xll_worker.h"
#include "include/xll_cache.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
#include "protocol_generated.h"

// Disable "unreferenced formal parameter" warning
#pragma warning(disable: 4100)

using namespace xll;

// Global Handle
HANDLE g_hModule = NULL;

// Global shutdown event
HANDLE g_hShutdownEvent = NULL;

// Forward Declarations
void RegisterFunctions();
void UnregisterFunctions();
extern void StartMonitorThread(HANDLE hProcess);

// Entry point
BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        g_hModule = hModule;
        // Initialize Global Error Value
        g_xlErrValue.xltype = xltypeErr;
        g_xlErrValue.val.err = xlerrValue;
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

// XLL Interface Functions

__declspec(dllexport) int __stdcall xlAutoOpen() {
    XLL_SAFE_BLOCK_BEGIN
        // Setup Native Logging
        std::string tempPattern = "";
        std::string projName = "{{.ProjectName}}";
        bool isSingleFile = false;

        {{if eq .Embed.Singlefile "xll"}}
        isSingleFile = true;
        tempPattern = "{{.Embed.TempDir}}";
        {{end}}

        InitLog(L"{{.Logging.Dir}}", "{{.Logging.Level}}", tempPattern, projName, isSingleFile);

#ifdef SHM_DEBUG
        shm::SetLogHandler(LogHandler);
#endif

        // Determine worker count
        int workers = {{.Server.Workers}};
        if (workers <= 0) {
            workers = std::thread::hardware_concurrency();
            if (workers == 0) workers = 16; // Fallback
        }
    }

    // Create log filename
    std::wstring logPath = (std::filesystem::path(logDir) / L"xll_native.log").wstring();
    // Initialize Logger
    InitLogger(logPath, "{{.Logging.Level}}");

    LogInfo("xlAutoOpen: Loading XLL...");

    Excel12(xlGetName, &xDLL, 0);

    // Initialize Shared Memory
    std::string shmName = "{{.ProjectName}}";
    {{if not .ShouldAppendPid}}
    // Static name for testing/dev
    {{else}}
    shmName += "_" + std::to_string(GetCurrentProcessId());
    {{end}}

    LogInfo("Initializing Shared Memory: " + shmName);

    // HostConfig: hostSlots, guestSlots.
    // hostSlots: slots for host-to-guest requests (user functions).
    // guestSlots: slots for guest-to-host requests (async results, callbacks).
    // guestSlots needs to be > 0 for MSG_BATCH_ASYNC_RESPONSE.
    // We assume 2 guest slots is enough for now.
    // Host slots depends on concurrency.
    shm::HostConfig hostCfg;
    int workers = {{if .Server.Workers}}{{.Server.Workers}}{{else}}std::thread::hardware_concurrency(){{end}};
    if (workers < 1) workers = 1;
    hostCfg.numHostSlots = workers * 2 + 2; // Heuristic
    hostCfg.numGuestSlots = 2; // Enable guest-initiated messages

    if (!g_host.Init(shmName, 1024 * 1024, hostCfg)) {
         std::string err = "Failed to initialize shared memory: " + g_host.GetLastErrorStr();
         LogError(err);
         MessageBoxA(NULL, err.c_str(), "XLL Error", MB_OK | MB_ICONERROR);
         return 0; // Fail loading
    }

    // Launch Server Process
    {{if derefBool .Server.Launch.Enabled}}
    // Command resolution
    std::string cmd = "{{.Server.Command}}"; // Template substitution
    if (!LaunchProcess(cmd, xllDir, shmName)) {
         LogError("Failed to launch server process");
         // We might continue if manual start is expected, but here we assume it's critical.
         // Actually, for "attach" debugging, we might want to continue.
         // But typical user expects it to work.
         MessageBoxA(NULL, "Failed to launch server process. See log for details.", "XLL Error", MB_OK | MB_ICONERROR);
         return 0;
    }
    {{else}}
    LogInfo("Server launch disabled by configuration.");
    {{end}}

    // Start Worker Thread for Async Results
    StartWorker();

    RegisterFunctions();

    // Register Events
{{range .Events}}
        Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Name}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
    {{if hasEvent "CalculationEnded" .Events}}
    {{else}}
    bool needCalcEnded = false;
    // Check if caching is enabled which needs RefCache cleanup
    bool hasCache = {{.Cache.Enabled}};
    {{range .Functions}}
    {{if .Cache}}
    {{if .Cache.Enabled}}
    hasCache = true;
    {{end}}
    {{end}}
    {{end}}

    {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
    if (needCalcEnded || hasCache) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }
    {{end}}

{{range $i, $fn := .Functions}}
        {
            // Register {{.Name}}
            // Signature: {{if .Async}}>{{end}}{{lookupXllType .Return}}{{range .Args}}{{lookupXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}{{if not .Async}}${{end}}
            // Types: {{if .Async}}Async Handle{{else}}{{lookupCppType .Return}}{{end}}, {{range $j, $arg := .Args}}{{lookupCppArgType .Type}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}, AsyncHandle{{end}}
            Excel12(xlfRegister, 0, 10 + {{len .Args}},
                (LPXLOPER12)&xDLL,
                TempStr12(L"{{.Name}}"),
                TempStr12(L"{{if .Async}}>{{end}}{{lookupXllType .Return}}{{range .Args}}{{lookupXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}{{if not .Async}}${{end}}"),
                TempStr12(L"{{.Name}}"),
                TempStr12(L"{{range $j, $arg := .Args}}{{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}"),
                TempInt12(1), // Macro type
                TempStr12(L"{{if .Category}}{{.Category}}{{else}}{{$.ProjectName}}{{end}}"),
                TempStr12(L"{{.Shortcut}}"),
                TempStr12(L"{{.HelpTopic}}"),
                TempStr12(L"{{.Description}}"),
                {{range .Args}}TempStr12(L"{{.Description}}"),{{end}}
                0);
        }
{{end}}

    // Free xDLL
    Excel12(xlFree, 0, 1, (LPXLOPER12)&xDLL);

    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    LogInfo("Unloading XLL...");

    // Stop Worker
    StopWorker();

        Excel12(xlFree, 0, 1, &xDll);
        return 1;
    XLL_SAFE_BLOCK_END(0)
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    XLL_SAFE_BLOCK_BEGIN
        LogInfo("Unloading XLL...");
        if (g_procInfo.hShutdownEvent) SetEvent(g_procInfo.hShutdownEvent);

    Excel12(xlGetName, &xDLL, 0);
    Excel12(xlfRegister, &xRegId, 2, (LPXLOPER12)&xDLL, pxName);
    Excel12(xlFree, 0, 1, (LPXLOPER12)&xDLL);

    return &xRegId;
}

__declspec(dllexport) int __stdcall xlAutoAdd(void) {
    return 1;
}

        if (g_procInfo.hProcess) {
            CloseHandle(g_procInfo.hProcess);
            g_procInfo.hProcess = NULL;
        }
        if (g_procInfo.hJob) {
            CloseHandle(g_procInfo.hJob);
            g_procInfo.hJob = NULL;
        }
        if (g_procInfo.hShutdownEvent) {
            CloseHandle(g_procInfo.hShutdownEvent);
            g_procInfo.hShutdownEvent = NULL;
        }
        return 1;
    XLL_SAFE_BLOCK_END(1)
}

// User Functions

// Event Handlers
{{range .Events}}
__declspec(dllexport) void __stdcall {{.Handler}}() {
    XLL_SAFE_BLOCK_BEGIN
        std::vector<uint8_t> respBuf;
        // Construct Request
        // We need a specific MsgID for events?
        // Or we map name to ID?
        // Current protocol doesn't support named events directly without ID.
        // We assume Events are in .Functions list or handled specially.
        // Actually, events are just functions invoked by Excel.
        // But here we need to notify Server.

        // TODO: Event ID mapping. For now, skipping implementation details as per spec focus.
        LogInfo("Event {{.Name}} triggered");
    XLL_SAFE_BLOCK_END_VOID
}
{{end}}

{{if hasEvent "CalculationEnded" .Events}}
// User defined handler exists
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    XLL_SAFE_BLOCK_BEGIN
        // Clear caches
        {
            std::lock_guard<std::mutex> lock(g_refCacheMutex);
            g_sentRefCache.clear();
        }
        xll::CacheManager::Instance().ClearRefCache();

        std::vector<uint8_t> respBuf;
        auto res = g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_ENDED, respBuf, 2000);
        if (res.Value() > 0) {
            // Process returned commands (e.g. SetCommand)
            auto root = flatbuffers::GetRoot<protocol::CalculationEndedResponse>(respBuf.data());
            auto commands = root->commands();
            if (commands) {
                ExecuteCommands(commands);
            }
        }
    XLL_SAFE_BLOCK_END_VOID
}
{{end}}

{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupCppArgType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    XLL_SAFE_BLOCK_BEGIN
        {{/* Determine Cache Configuration */}}
        {{ $cacheEnabled := $.Cache.Enabled }}
        {{ $ttl := $.Cache.TTL }}
        {{ if .Cache }}
            {{ if .Cache.Enabled }}{{ $cacheEnabled = derefBool .Cache.Enabled }}{{ end }}
            {{ if .Cache.TTL }}{{ $ttl = .Cache.TTL }}{{ end }}
        {{ end }}
        // DEBUG CACHE: Func={{.Name}} Global={{$.Cache.Enabled}} FuncOverride={{if .Cache}}YES{{else}}NO{{end}} Resolved={{$cacheEnabled}} Async={{.Async}}

        {{if and $cacheEnabled (not .Async)}}
        // Cache Lookup
        xll::CacheConfig cacheConfig;
        cacheConfig.enabled = true;
        cacheConfig.ttl = std::chrono::milliseconds({{parseDurationToMs $ttl}});
        cacheConfig.jitter = std::chrono::milliseconds({{parseDurationToMs $.Cache.Jitter}});

        // Prepare temporary XLOPERs for non-pointer arguments
        std::vector<XLOPER12> tempArgs({{len .Args}});
        std::vector<LPXLOPER12> cacheArgs;
        cacheArgs.reserve({{len .Args}});

        {{range $j, $arg := .Args}}
        {
            XLOPER12& xArg = tempArgs[{{$j}}];
            {{if eq .Type "int"}}
            xArg.xltype = xltypeInt;
            xArg.val.w = {{.Name}};
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "float"}}
            xArg.xltype = xltypeNum;
            xArg.val.num = {{.Name}};
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "bool"}}
            xArg.xltype = xltypeBool;
            xArg.val.xbool = {{.Name}} ? 1 : 0;
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "string"}}
            // Convert string to temp XLOPER12 (requires creating a Pascal String buffer)
            // But we don't want to alloc. We just want to wrap it for MakeCacheKey serialization.
            // Since MakeCacheKey uses SerializeXLOPER which expects xltypeStr with Pascal String,
            // we must conform.
            xArg.xltype = xltypeStr;
            // WStringToPascalString returns std::vector<wchar_t>. We need to keep it alive.
            // This is tricky inside this scope.
            // Alternative: MakeCacheKey should accept a variant or we serialize manually here.
            // Simpler: Just make the vector locally.
            // But we are in a loop.
            // Let's defer string handling or alloc.
            // For now, let's just create it. The vector will die at end of scope? No.
            // We can define a thread_local buffer or just alloc/free.
            // Actually, we can just use CreateStringXLOPER helper which allocs, then free it.
            xArg = CreateStringXLOPER(({{.Name}}) ? StringToWString({{.Name}}) : L"");
            xArg.xltype |= xlbitDLLFree; // Mark for freeing if we use xlAutoFree? No, we handle it manually.
            cacheArgs.push_back(&xArg);
            {{else}}
            // Already a pointer (range, grid, numgrid, any, or pointer-to-scalar)
            cacheArgs.push_back((LPXLOPER12){{.Name}});
            {{end}}
        }
        {{end}}

        std::string cacheKey = xll::MakeCacheKey("{{.Name}}", cacheArgs);

        // Cleanup temporary string allocations
        {{range $j, $arg := .Args}}
        {{if eq .Type "string"}}
        delete[] tempArgs[{{$j}}].val.str;
        {{end}}
        {{end}}

        std::vector<uint8_t> cachedData;
        if (xll::CacheManager::Instance().Get(cacheKey, cachedData)) {
            // Deserialize response
            auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(cachedData.data());

            {{if eq .Return "string"}}
            std::wstring wres = StringToWString(resp->result()->str());
            return NewExcelString(wres.c_str());
            {{else if eq .Return "int"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeInt;
            xRes.val.w = resp->result();
            return &xRes;
            {{else if eq .Return "float"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeNum;
            xRes.val.num = resp->result();
            return &xRes;
            {{else if eq .Return "bool"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeBool;
            xRes.val.xbool = resp->result() ? 1 : 0;
            return &xRes;
            {{else if eq .Return "any"}}
            return AnyToXLOPER12(resp->result());
            {{else if eq .Return "grid"}}
            return GridToXLOPER12(resp->result());
            {{else if eq .Return "numgrid"}}
            return NumGridToFP12(resp->result());
            {{else if eq .Return "range"}}
            return RangeToXLOPER12(resp->result());
            {{else}}
            return resp->result();
            {{end}}
        }
        {{end}}

        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

        // Arguments
        {{range $j, $arg := .Args}}
        {{if eq .Type "string"}}
        auto arg{{$j}} = builder.CreateString(ConvertExcelString({{.Name}}));
        {{else if eq .Type "grid"}}
        auto arg{{$j}} = GridToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "numgrid"}}
        auto arg{{$j}} = NumGridToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "range"}}
        auto arg{{$j}} = RangeToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "any"}}
        auto arg{{$j}} = AnyToFlatBuffer(builder, {{.Name}});
        {{end}}
        {{end}}

        // Request Builder
        ipc::{{.Name}}RequestBuilder reqBuilder(builder);
        {{if .Async}}
        reqBuilder.add_async_handle((uint64_t)asyncHandle);
        {{end}}
        {{range $j, $arg := .Args}}
        {{if or (eq .Type "int") (eq .Type "float") (eq .Type "bool")}}
        reqBuilder.add_arg{{$j}}({{if eq .Type "bool"}}*{{.Name}} != 0{{else}}*{{.Name}}{{end}});
        {{else}}
        reqBuilder.add_arg{{$j}}(arg{{$j}});
        {{end}}
        {{end}}
        {{if .Caller}}
        flatbuffers::Offset<protocol::Range> caller_off = 0;
        {
            XLOPER12 xCaller;
            if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
                std::string callerFormat = "";
                XLOPER12 xType; xType.xltype = xltypeInt; xType.val.w = 7;
                XLOPER12 xFormat;
                if (Excel12(xlfGetCell, &xFormat, 2, &xType, &xCaller) == xlretSuccess) {
                    if (xFormat.xltype == xltypeStr) {
                         // xFormat.val.str is Pascal String
                         callerFormat = ConvertExcelString(xFormat.val.str); // Convert to UTF8
                    }
                    Excel12(xlFree, 0, 1, &xFormat);
                }

                caller_off = ConvertRange(&xCaller, builder, callerFormat);
                if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                    Excel12(xlFree, 0, 1, &xCaller);
                }
            }
        }
        {{end}}

        {{if .Async}}
        auto asyncHandle_vec = builder.CreateVector((const uint8_t*)asyncHandle, sizeof(XLOPER12));
        {{end}}

        ipc::{{.Name}}RequestBuilder reqBuilder(builder);
        {{range .Args}}
        {{if eq .Type "string"}}
        reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "int?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "float?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "bool?"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "range"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "grid"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "numgrid"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else if eq .Type "any"}}
        if ({{.Name}}_off.o != 0) reqBuilder.add_{{.Name}}({{.Name}}_off);
        {{else}}
        reqBuilder.add_{{.Name}}({{.Name}});
        {{end}}
        {{end}}
        {{if .Caller}}
        if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
        {{end}}
        {{if .Async}}
        reqBuilder.add_async_handle(asyncHandle_vec);
        {{end}}
        auto req = reqBuilder.Finish();
        builder.Finish(req);

        {{if .Async}}
        // Async Send
        g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add 133 $i}}, nullptr, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.AsyncAckTimeout 2000}}{{end}});
        return;
        {{else}}
        // Sync Send
        auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add 133 $i}}, slot.GetRespBuffer(), {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.Timeout 2000}}{{end}});

        if (res.HasError()) {
             // Return Error
             return &g_xlErrValue;
        }

        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(slot.GetRespBuffer());

        {{if and $cacheEnabled (not .Async)}}
        // Store in cache
        {
            const uint8_t* respData = slot.GetRespBuffer();
            // Get size from GetRoot? No, GetRespBuffer is just a pointer.
            // But we know it's a FlatBuffer. We need to copy the *buffer*.
            // Since we used ZeroCopy, we need to know the size.
            // slot.GetRespSize() isn't exposed directly?
            // The slot abstraction in SHM might need checking.
            // DirectHost::Send returns shm::Result<int>. The int is the size of the response?
            // "If positive, returns bytes received".
            // Yes, res.Value() is size.

            int32_t respSize = res.Value();
            if (respSize > 0) {
                 std::vector<uint8_t> dataToCache(respData, respData + respSize);
                 xll::CacheManager::Instance().Put(cacheKey, dataToCache, cacheConfig);
            }
        }
        {{end}}

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
        {{end}}
    {{if .Async}}XLL_SAFE_BLOCK_END_VOID{{else}}XLL_SAFE_BLOCK_END(&g_xlErrValue){{end}}
}
{{end}}
