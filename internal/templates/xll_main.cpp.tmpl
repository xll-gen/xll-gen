{{- $gen := . }}
// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
// This file contains the main entry point and XLL interface functions.

#include <windows.h>
#include <xlcall.h>
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>
#include <filesystem>
#include <sstream>
#include <map>
#include "include/xll_log.h"
#include "include/xll_mem.h"
#include "include/xll_converters.h"
#include "include/xll_utility.h"
#include "include/PascalString.h"
#include "include/xll_launch.h"
#include "include/xll_worker.h"
#include "include/xll_cache.h"
#include "include/xll_embed.h"
#include "include/xll_events.h"
#include "include/xll_ipc.h"
#include "include/SHMAllocator.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"
#include "protocol_generated.h"

// Disable "unreferenced formal parameter" warning
#pragma warning(disable: 4100)

using namespace xll;

// Global Handle
HINSTANCE g_hModule = NULL;
// Global Error Value
XLOPER12 g_xlErrValue;

// Process Information for Server
ProcessInfo g_procInfo = { 0 };

// Forward Declarations
void RegisterFunctions();
void UnregisterFunctions();

// Thread for monitoring server process
void MonitorThread(std::wstring logPath) {
    MonitorProcess(g_procInfo, logPath);
}

// Entry point
BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        g_hModule = (HINSTANCE)hModule;
        // Initialize Global Error Value
        g_xlErrValue.xltype = xltypeErr;
        g_xlErrValue.val.err = xlerrValue;
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

// XLL Interface Functions

extern "C" __declspec(dllexport) int __stdcall xlAutoOpen() {
    XLL_SAFE_BLOCK_BEGIN
        // Setup Native Logging
        std::string tempPattern = "";
        std::string projName = "{{.ProjectName}}";
        bool isSingleFile = false;

        {{if eq .Build.Singlefile "xll"}}
        isSingleFile = true;
        tempPattern = "{{.Build.TempDir}}";
        {{end}}

        InitLog(L"{{.Logging.Dir}}", "{{.Logging.Level}}", tempPattern, projName, isSingleFile);

#ifdef SHM_DEBUG
        shm::SetLogHandler(LogHandler);
#endif

        LogInfo("xlAutoOpen: Loading XLL...");

        Excel12(xlGetName, &xDLL, 0);

        // Initialize Shared Memory
        std::string shmName = "{{.ProjectName}}";
        {{if not .ShouldAppendPid}}
        // Static name for testing/dev
        {{else}}
        shmName += "_" + std::to_string(GetCurrentProcessId());
        {{end}}

        LogInfo("Initializing Shared Memory: " + shmName);

        // HostConfig: hostSlots, guestSlots.
        shm::HostConfig hostCfg;
        int workers = {{if .Server.Workers}}{{.Server.Workers}}{{else}}std::thread::hardware_concurrency(){{end}};
        if (workers < 1) workers = 1;
        hostCfg.numHostSlots = workers * 2 + 2;
        hostCfg.numGuestSlots = 2;

        if (!g_host.Init(shmName, 1024 * 1024, hostCfg)) {
             std::string err = "Failed to initialize shared memory: " + g_host.GetLastErrorStr();
             LogError(err);
             MessageBoxA(NULL, err.c_str(), "XLL Error", MB_OK | MB_ICONERROR);
             return 0; // Fail loading
        }

        // Launch Server Process
        {{if derefBool .Server.Launch.Enabled}}
        // Prepare Launch Config
        LaunchConfig cfg;
        cfg.projectName = L"{{.ProjectName}}";
        cfg.isSingleFile = isSingleFile;
        cfg.cwd = ""; // Default CWD (relative to bindir)
        cfg.command = "{{.Server.Command}}";
        cfg.shmName = shmName;

        std::wstring launchLog;
        if (!LaunchServer(cfg, GetXllDir(), g_procInfo, launchLog)) {
             return 0;
        }

        // Start Monitor Thread
        std::thread(MonitorThread, launchLog).detach();
        {{else}}
        LogInfo("Server launch disabled by configuration.");
        {{end}}

        // Start Worker Thread for Async Results
        StartWorker();

        RegisterFunctions();

        // Register Events
{{range .Events}}
        Excel12(xlEventRegister, 0, 2, TempStr12(L"{{.Handler}}"), TempInt12({{lookupEventCode .Type}}));
{{end}}
        {{if hasEvent "CalculationEnded" .Events}}
        {{else}}
        bool needCalcEnded = false;
        bool hasCache = {{.Cache.Enabled}};
        {{range .Functions}}
        {{if .Cache}}
        {{if .Cache.Enabled}}
        hasCache = true;
        {{end}}
        {{end}}
        {{end}}

        {{range $i, $fn := .Functions}}{{range .Args}}{{if eq .Type "any"}}needCalcEnded=true;{{end}}{{end}}{{end}}
        if (needCalcEnded || hasCache) {
             Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
        }
        {{end}}

        // Register User Functions
{{range $i, $fn := .Functions}}
        {
            // Register {{.Name}}
            Excel12(xlfRegister, 0, 10 + {{len .Args}},
                (LPXLOPER12)&xDLL,
                TempStr12(L"{{.Name}}"),
                TempStr12(L"{{if .Async}}>{{end}}{{lookupXllType .Return}}{{range .Args}}{{lookupXllType .Type}}{{end}}{{if .Async}}X{{end}}{{if .Caller}}#{{end}}{{if .Volatile}}!{{end}}{{if not .Async}}${{end}}"),
                TempStr12(L"{{.Name}}"),
                TempStr12(L"{{range $j, $arg := .Args}}{{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}},{{end}}{{end}}"),
                TempInt12(1), // Macro type
                TempStr12(L"{{if .Category}}{{.Category}}{{else}}{{$.ProjectName}}{{end}}"),
                TempStr12(L"{{.Shortcut}}"),
                TempStr12(L"{{.HelpTopic}}"),
                TempStr12(L"{{.Description}}"),
                {{range .Args}}TempStr12(L"{{.Description}}"),{{end}}
                0);
        }
{{end}}

        // Free xDLL
        Excel12(xlFree, 0, 1, (LPXLOPER12)&xDLL);

        return 1;
    XLL_SAFE_BLOCK_END(0)
}

extern "C" __declspec(dllexport) int __stdcall xlAutoClose() {
    XLL_SAFE_BLOCK_BEGIN
        LogInfo("Unloading XLL...");

        // Signal shutdown to monitor thread
        if (g_procInfo.hShutdownEvent) SetEvent(g_procInfo.hShutdownEvent);

        // Stop Worker
        StopWorker();

        // Cleanup Process Handles
        if (g_procInfo.hProcess) {
            CloseHandle(g_procInfo.hProcess);
            g_procInfo.hProcess = NULL;
        }
        if (g_procInfo.hJob) {
            CloseHandle(g_procInfo.hJob);
            g_procInfo.hJob = NULL;
        }
        if (g_procInfo.hShutdownEvent) {
            CloseHandle(g_procInfo.hShutdownEvent);
            g_procInfo.hShutdownEvent = NULL;
        }

        return 1;
    XLL_SAFE_BLOCK_END(1)
}

extern "C" __declspec(dllexport) int __stdcall xlAutoAdd(void) {
    return 1;
}

// Event Handlers
{{range .Events}}
__declspec(dllexport) void __stdcall {{.Handler}}() {
    XLL_SAFE_BLOCK_BEGIN
        std::vector<uint8_t> respBuf;
        // Construct Request (Event)
        // Currently not fully implemented for named events
        LogInfo("Event {{.Type}} triggered");
    XLL_SAFE_BLOCK_END_VOID
}
{{end}}

{{if hasEvent "CalculationEnded" .Events}}
// User defined handler exists
{{else}}
__declspec(dllexport) void __stdcall CalculationEnded() {
    HandleCalculationEnded();
}
{{end}}

// User Functions
{{range $i, $fn := .Functions}}
__declspec(dllexport) {{if .Async}}void{{else}}{{lookupCppType .Return}}{{end}} __stdcall {{.Name}}({{range $j, $arg := .Args}}{{lookupCppArgType $arg.Type}} {{$arg.Name}}{{if lt $j (sub (len $fn.Args) 1)}}, {{end}}{{end}}{{if .Async}}{{if .Args}}, {{end}}LPXLOPER12 asyncHandle{{end}}) {
    XLL_SAFE_BLOCK_BEGIN
        {{/* Determine Cache Configuration */}}
        {{ $cacheEnabled := $.Cache.Enabled }}
        {{ $ttl := $.Cache.TTL }}
        {{ if .Cache }}
            {{ if .Cache.Enabled }}{{ $cacheEnabled = derefBool .Cache.Enabled }}{{ end }}
            {{ if .Cache.TTL }}{{ $ttl = .Cache.TTL }}{{ end }}
        {{ end }}

        {{if and $cacheEnabled (not .Async)}}
        // Cache Lookup
        xll::CacheConfig cacheConfig;
        cacheConfig.enabled = true;
        cacheConfig.ttl = std::chrono::milliseconds({{parseDurationToMs $ttl}});
        cacheConfig.jitter = std::chrono::milliseconds({{parseDurationToMs $.Cache.Jitter}});

        // Prepare temporary XLOPERs for non-pointer arguments
        std::vector<XLOPER12> tempArgs({{len .Args}});
        std::vector<LPXLOPER12> cacheArgs;
        cacheArgs.reserve({{len .Args}});

        {{range $j, $arg := .Args}}
        {
            XLOPER12& xArg = tempArgs[{{$j}}];
            {{if eq .Type "int"}}
            xArg.xltype = xltypeInt;
            xArg.val.w = {{.Name}};
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "float"}}
            xArg.xltype = xltypeNum;
            xArg.val.num = {{.Name}};
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "bool"}}
            xArg.xltype = xltypeBool;
            xArg.val.xbool = {{.Name}} ? 1 : 0;
            cacheArgs.push_back(&xArg);
            {{else if eq .Type "string"}}
            // Convert string to temp XLOPER12 for cache key
            // Use PascalToWString for safe conversion if it is string
            std::wstring s = (({{.Name}}->xltype & xltypeStr) ? PascalToWString({{.Name}}->val.str) : L"");
            xArg = CreateStringXLOPER(s.c_str());
            xArg.xltype |= xlbitDLLFree;
            cacheArgs.push_back(&xArg);
            {{else}}
            // Already a pointer
            cacheArgs.push_back((LPXLOPER12){{.Name}});
            {{end}}
        }
        {{end}}

        std::string cacheKey = xll::MakeCacheKey("{{.Name}}", cacheArgs);

        // Cleanup temporary string allocations
        {{range $j, $arg := .Args}}
        {{if eq .Type "string"}}
        delete[] tempArgs[{{$j}}].val.str;
        {{end}}
        {{end}}

        std::vector<uint8_t> cachedData;
        if (xll::CacheManager::Instance().Get(cacheKey, cachedData)) {
            // Deserialize response
            auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(cachedData.data());

            {{if eq .Return "string"}}
            std::wstring wres = StringToWString(resp->result()->str());
            return NewExcelString(wres.c_str());
            {{else if eq .Return "int"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeInt;
            xRes.val.w = resp->result();
            return &xRes;
            {{else if eq .Return "float"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeNum;
            xRes.val.num = resp->result();
            return &xRes;
            {{else if eq .Return "bool"}}
            static thread_local XLOPER12 xRes;
            xRes.xltype = xltypeBool;
            xRes.val.xbool = resp->result() ? 1 : 0;
            return &xRes;
            {{else if eq .Return "any"}}
            return AnyToXLOPER12(resp->result());
            {{else if eq .Return "grid"}}
            return GridToXLOPER12(resp->result());
            {{else if eq .Return "numgrid"}}
            return NumGridToFP12(resp->result());
            {{else if eq .Return "range"}}
            return RangeToXLOPER12(resp->result());
            {{else}}
            return resp->result();
            {{end}}
        }
        {{end}}

        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);

        // Arguments
        {{range $j, $arg := .Args}}
        {{if eq .Type "string"}}
        auto arg{{$j}} = builder.CreateString(({{.Name}}->xltype == xltypeStr) ? ConvertExcelString(PascalToWString({{.Name}}->val.str).c_str()) : "");
        {{else if eq .Type "grid"}}
        auto arg{{$j}} = GridToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "numgrid"}}
        auto arg{{$j}} = NumGridToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "range"}}
        auto arg{{$j}} = RangeToFlatBuffer(builder, {{.Name}});
        {{else if eq .Type "any"}}
        auto arg{{$j}} = AnyToFlatBuffer(builder, {{.Name}});
        {{end}}
        {{end}}

        {{if .Caller}}
        flatbuffers::Offset<protocol::Range> caller_off = 0;
        {
            XLOPER12 xCaller;
            if (Excel12(xlfCaller, &xCaller, 0) == xlretSuccess) {
                std::string callerFormat = "";
                XLOPER12 xType; xType.xltype = xltypeInt; xType.val.w = 7;
                XLOPER12 xFormat;
                if (Excel12(xlfGetCell, &xFormat, 2, &xType, &xCaller) == xlretSuccess) {
                    if (xFormat.xltype == xltypeStr) {
                         callerFormat = ConvertExcelString(xFormat.val.str);
                    }
                    Excel12(xlFree, 0, 1, &xFormat);
                }
                caller_off = ConvertRange(&xCaller, builder, callerFormat);
                if (xCaller.xltype & (xlbitXLFree | xlbitDLLFree)) {
                    Excel12(xlFree, 0, 1, &xCaller);
                }
            }
        }
        {{end}}

        {{if .Async}}
        auto asyncHandle_vec = builder.CreateVector((const uint8_t*)asyncHandle, sizeof(XLOPER12));
        {{end}}

        ipc::{{.Name}}RequestBuilder reqBuilder(builder);
        {{range $j, $arg := .Args}}
        {{if or (eq .Type "int") (eq .Type "float") (eq .Type "bool")}}
        reqBuilder.add_{{.Name}}({{if eq .Type "bool"}}({{.Name}} != 0){{else}}{{.Name}}{{end}});
        {{else}}
        reqBuilder.add_{{.Name}}(arg{{$j}});
        {{end}}
        {{end}}

        {{if .Caller}}
        if (caller_off.o != 0) reqBuilder.add_caller(caller_off);
        {{end}}
        {{if .Async}}
        reqBuilder.add_async_handle(asyncHandle_vec);
        {{end}}

        auto req = reqBuilder.Finish();
        builder.Finish(req);

        {{if .Async}}
        // Async Send
        g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add 133 $i}}, nullptr, {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.AsyncAckTimeout 2000}}{{end}});
        return;
        {{else}}
        // Sync Send
        auto res = g_host.Send(nullptr, -((int)builder.GetSize()), (shm::MsgType){{add 133 $i}}, slot.GetRespBuffer(), {{if .Timeout}}{{parseTimeout .Timeout 2000}}{{else}}{{parseTimeout $.Server.Timeout 2000}}{{end}});

        if (res.HasError()) {
             return &g_xlErrValue;
        }

        auto resp = flatbuffers::GetRoot<ipc::{{.Name}}Response>(slot.GetRespBuffer());

        {{if and $cacheEnabled (not .Async)}}
        // Store in cache
        {
            const uint8_t* respData = slot.GetRespBuffer();
            int32_t respSize = res.Value();
            if (respSize > 0) {
                 std::vector<uint8_t> dataToCache(respData, respData + respSize);
                 xll::CacheManager::Instance().Put(cacheKey, dataToCache, cacheConfig);
            }
        }
        {{end}}

        {{if eq .Return "string"}}
        std::wstring wres = StringToWString(resp->result()->str());
        return NewExcelString(wres.c_str());
        {{else if eq .Return "int"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeInt;
        xRes.val.w = resp->result();
        return &xRes;
        {{else if eq .Return "float"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;
        {{else if eq .Return "bool"}}
        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeBool;
        xRes.val.xbool = resp->result() ? 1 : 0;
        return &xRes;
        {{else if eq .Return "any"}}
        return AnyToXLOPER12(resp->result());
        {{else if eq .Return "grid"}}
        return GridToXLOPER12(resp->result());
        {{else if eq .Return "numgrid"}}
        return NumGridToFP12(resp->result());
        {{else if eq .Return "range"}}
        return RangeToXLOPER12(resp->result());
        {{else}}
        return resp->result();
        {{end}}
        {{end}}
    {{if .Async}}XLL_SAFE_BLOCK_END_VOID{{else}}XLL_SAFE_BLOCK_END(&g_xlErrValue){{end}}
}
{{end}}
