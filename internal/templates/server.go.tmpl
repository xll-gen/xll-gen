// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"flag"
	"fmt"
	"math/rand"
	"sync"
	"time"
	"runtime"
	"runtime/debug"
	"{{.ModName}}/generated/ipc"
	"github.com/xll-gen/xll-gen/pkg/log"
	"github.com/xll-gen/xll-gen/pkg/server"
	"github.com/xll-gen/types/go/protocol"
	"github.com/xll-gen/shm/go"
	flatbuffers "github.com/google/flatbuffers/go"
)

// Force usage of time and protocol to avoid unused import error
var _ = time.Now
var _ = protocol.Bool{}

var (
	asyncBatcher   = server.NewAsyncBatcher()
	chunkManager   = server.NewChunkManager()
	commandBatcher = server.NewCommandBatcher()
    {{if .Rtd.Enabled}}
    // Global client pointer for RTD updates
    globalClient *shm.Client
    globalClientMutex sync.RWMutex
    {{end}}
)

func ScheduleSet(r *protocol.Range, v *protocol.Any) {
	commandBatcher.ScheduleSet(r, v)
}

func ScheduleFormat(r *protocol.Range, fmtStr string) {
	commandBatcher.ScheduleFormat(r, fmtStr)
}

{{if .Rtd.Enabled}}
func PushRtdUpdate(topicID int32, value interface{}) error {
    globalClientMutex.RLock()
    client := globalClient
    globalClientMutex.RUnlock()

    if client == nil {
        return fmt.Errorf("server not connected")
    }

    // Construct RtdUpdate message
    builder := flatbuffers.NewBuilder(128)

    var anyOff flatbuffers.UOffsetT
    var anyType protocol.AnyValue

    switch v := value.(type) {
    case string:
        sOff := builder.CreateString(v)
        protocol.StrStart(builder)
        protocol.StrAddVal(builder, sOff)
        valOff := protocol.StrEnd(builder)
        protocol.AnyStart(builder)
        protocol.AnyAddValType(builder, protocol.AnyValueStr)
        protocol.AnyAddVal(builder, valOff)
        anyOff = protocol.AnyEnd(builder)
        anyType = protocol.AnyValueStr
    case int, int32, int64:
        // Handle generic int, assume int32 for compatibility or cast
        // protocol.Int takes int32
        var iVal int32
        switch iv := v.(type) {
            case int: iVal = int32(iv)
            case int32: iVal = iv
            case int64: iVal = int32(iv)
        }
        protocol.IntStart(builder)
        protocol.IntAddVal(builder, iVal)
        valOff := protocol.IntEnd(builder)
        protocol.AnyStart(builder)
        protocol.AnyAddValType(builder, protocol.AnyValueInt)
        protocol.AnyAddVal(builder, valOff)
        anyOff = protocol.AnyEnd(builder)
        anyType = protocol.AnyValueInt
    case float64, float32:
        var fVal float64
        switch fv := v.(type) {
            case float64: fVal = fv
            case float32: fVal = float64(fv)
        }
        protocol.NumStart(builder)
        protocol.NumAddVal(builder, fVal)
        valOff := protocol.NumEnd(builder)
        protocol.AnyStart(builder)
        protocol.AnyAddValType(builder, protocol.AnyValueNum)
        protocol.AnyAddVal(builder, valOff)
        anyOff = protocol.AnyEnd(builder)
        anyType = protocol.AnyValueNum
    case bool:
        protocol.BoolStart(builder)
        protocol.BoolAddVal(builder, v)
        valOff := protocol.BoolEnd(builder)
        protocol.AnyStart(builder)
        protocol.AnyAddValType(builder, protocol.AnyValueBool)
        protocol.AnyAddVal(builder, valOff)
        anyOff = protocol.AnyEnd(builder)
        anyType = protocol.AnyValueBool
    default:
        return fmt.Errorf("unsupported type for RTD value")
    }
    _ = anyType // Avoid unused

    protocol.RtdUpdateStart(builder)
    protocol.RtdUpdateAddTopicId(builder, topicID)
    protocol.RtdUpdateAddVal(builder, anyOff)
    root := protocol.RtdUpdateEnd(builder)
    builder.Finish(root)

    data := builder.FinishedBytes()

    // We send using shm.Client.Send (if available) or queue it?
    // shm.Client in v0.5.4 might only support Send if it initiates?
    // Wait, Client is Guest. Host is Server.
    // Client.Send sends to Host.
    // We need to send MSG_RTD_UPDATE (ID 12).

    // Check if we can send unsolicited messages.
    // Yes, Send() is available.

    // We need to handle timeouts or fire-and-forget.
    // Send returns response.
    _, err := client.Send(data, 12, 1000)
    return err
}
{{end}}

func Serve(handler XllService) {
	// Parse command line flags to get SHM name
	shmName := flag.String("xll-shm", "{{.ProjectName}}", "Shared Memory Name")
	flag.Parse()

    if _, err := server.InitLog("{{.Logging.Dir}}", "{{.Logging.Level}}", "{{.ProjectName}}"); err != nil {
        fmt.Printf("Failed to initialize logger: %v\n", err)
    }

    log.Info("Connecting to SHM", "name", *shmName)
    client, err := server.ConnectSHM(*shmName)
    if err != nil {
        log.Error("Failed to connect to SHM", "error", err)
        panic(err)
    }
    defer client.Close()

    {{if .Rtd.Enabled}}
    globalClientMutex.Lock()
    globalClient = client
    globalClientMutex.Unlock()
    {{end}}

	var refCacheMutex sync.RWMutex
	refCache := make(map[string][]byte)

	asyncBatcher.StartWorker(func(batch []server.PendingAsyncResult) {
		server.FlushAsyncBatch(batch, client)
	})

	{{range .Functions}}
	{{if .Timeout}}
	timeout_{{.Name}}, _ := time.ParseDuration("{{.Timeout}}")
	{{end}}
	{{end}}

	workerCount := runtime.NumCPU()
	if n := {{.ServerWorkers}}; n > 0 {
		workerCount = n
	}

	jobQueue := make(chan func(), workerCount)
	for i := 0; i < workerCount; i++ {
		go func() {
			for job := range jobQueue {
				func() {
					defer func() {
						if r := recover(); r != nil {
							log.Error("Worker panic recovered", "error", r, "stack", string(debug.Stack()))
						}
					}()
					job()
				}()
			}
		}()
	}

	var dispatch func(data []byte, respBuf []byte, mType shm.MsgType) (int32, shm.MsgType)
	dispatch = func(data []byte, respBuf []byte, mType shm.MsgType) (int32, shm.MsgType) {
             builder := server.GetBuilder(respBuf)
             defer server.PutBuilder(builder)

             switch uint32(mType) {
             case server.MsgCalculationEnded:
                refCacheMutex.Lock()
                refCache = make(map[string][]byte)
                refCacheMutex.Unlock()

                {{if hasEvent "CalculationEnded" .Events}}
                var wg sync.WaitGroup
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    defer func() {
                        if r := recover(); r != nil {
                            log.Error("Panic in OnCalculationEnded", "error", r, "stack", string(debug.Stack()))
                        }
                    }()
                    if err := handler.OnCalculationEnded(context.Background()); err != nil {
                        log.Error("Event handler OnCalculationEnded failed", "error", err)
                    }
                }()
                wg.Wait()
                {{end}}

                builder.Reset()
                respBytes := commandBatcher.FlushCommands(builder)
                if len(respBytes) > 0 {
                    // Zero-Copy Return
                    if cap(builder.Bytes) == cap(respBuf) && len(respBytes) <= len(respBuf) {
                        return -int32(len(respBytes)), server.MsgCalculationEnded
                    }

                    if len(respBytes) > len(respBuf) {
                        log.Warn("CalculationEnded response too large", "size", len(respBytes))
                        return 0, 0
                    }
                    copy(respBuf, respBytes)
                    return int32(len(respBytes)), server.MsgCalculationEnded
                }
                return 0, 0

             case server.MsgCalculationCanceled:
                commandBatcher.Clear()

                {{if hasEvent "CalculationCanceled" .Events}}
                ctx := context.Background()
                go func() {
                    defer func() {
                        if r := recover(); r != nil {
                            log.Error("Panic in OnCalculationCanceled", "error", r, "stack", string(debug.Stack()))
                        }
                    }()
                    if err := handler.OnCalculationCanceled(ctx); err != nil {
                        log.Error("Event handler OnCalculationCanceled failed", "error", err)
                    }
                }()
                {{end}}
                return 0, 0

            {{if .Rtd.Enabled}}
            case 10: // MSG_RTD_CONNECT
                reqObj := protocol.GetRootAsRtdConnectRequest(data, 0)
                topicID := reqObj.TopicId()
                newVal := reqObj.NewValues()

                var strings []string
                if reqObj.StringsLength() > 0 {
                    for i := 0; i < reqObj.StringsLength(); i++ {
                        strings = append(strings, string(reqObj.Strings(i)))
                    }
                }

                ctx := context.Background()
                go func() {
                    defer func() {
                        if r := recover(); r != nil {
                            log.Error("Panic in OnRtdConnect", "error", r)
                        }
                    }()
                    if err := handler.OnRtdConnect(ctx, topicID, strings, newVal); err != nil {
                        log.Error("OnRtdConnect failed", "error", err)
                    }
                }()

                // Immediate ACK/Response?
                // For now, return empty RtdConnectResponse (no initial value)
                builder.Reset()
                protocol.RtdConnectResponseStart(builder)
                root := protocol.RtdConnectResponseEnd(builder)
                builder.Finish(root)
                payload := builder.FinishedBytes()

                if cap(builder.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
                    return -int32(len(payload)), 10
                }
                copy(respBuf, payload)
                return int32(len(payload)), 10

            case 11: // MSG_RTD_DISCONNECT
                reqObj := protocol.GetRootAsRtdDisconnectRequest(data, 0)
                topicID := reqObj.TopicId()

                ctx := context.Background()
                go func() {
                    defer func() {
                        if r := recover(); r != nil {
                            log.Error("Panic in OnRtdDisconnect", "error", r)
                        }
                    }()
                    if err := handler.OnRtdDisconnect(ctx, topicID); err != nil {
                        log.Error("OnRtdDisconnect failed", "error", err)
                    }
                }()
                return 0, 0
            {{end}}

             case server.MsgSetRefCache:
                reqObj := protocol.GetRootAsSetRefCacheRequest(data, 0)
                key := string(reqObj.Key())
                reqCopy := make([]byte, len(data))
                copy(reqCopy, data)

                refCacheMutex.Lock()
                refCache[key] = reqCopy
                refCacheMutex.Unlock()

                payload := server.BuildAckResponse(builder, 0, true)

                log.Debug("ACK sent", "func", "SetRefCache")

                if cap(builder.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
                    return -int32(len(payload)), server.MsgAck
                }
                if len(payload) > len(respBuf) { return 0, 0 }
                copy(respBuf, payload)
                return int32(len(payload)), server.MsgAck

             case server.MsgAck:
                reqObj := protocol.GetRootAsAck(data, 0)
                id := reqObj.Id()

                const chunkSize = 950 * 1024
                chunkData, msgType, totalSize, offset, found := chunkManager.GetNextChunk(id, chunkSize)

                if !found {
                    return 0, 0
                }

                if len(chunkData) == 0 {
                    return 0, 0
                }

                payload := server.BuildChunkResponse(builder, chunkData, id, totalSize, offset, msgType)

                if cap(builder.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
                    return -int32(len(payload)), server.MsgChunk
                }
                if len(payload) > len(respBuf) { return 0, 0 }
                copy(respBuf, payload)
                return int32(len(payload)), server.MsgChunk

             case server.MsgChunk:
                reqObj := protocol.GetRootAsChunk(data, 0)
                id := reqObj.Id()
                total := int(reqObj.TotalSize())
                offset := int(reqObj.Offset())
                dataLen := reqObj.DataLength()

                buf := chunkManager.GetChunkBuffer(id, total)

                buf.Mutex.Lock()
                if offset + dataLen <= len(buf.Data) {
                    copy(buf.Data[offset:], reqObj.DataBytes())
                    buf.Received += dataLen
                }
                isComplete := buf.Received >= buf.TotalSize
                buf.Mutex.Unlock()

                if isComplete {
                    chunkManager.RemoveChunkBuffer(id)
                    payloadMsgType := reqObj.MsgType()
                    return dispatch(buf.Data, respBuf, shm.MsgType(payloadMsgType))
                }

                payload := server.BuildAckResponse(builder, id, true)

                if cap(builder.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
                    return -int32(len(payload)), server.MsgChunk
                }
                if len(payload) > len(respBuf) { return 0, 0 }
                copy(respBuf, payload)
                return int32(len(payload)), server.MsgChunk

{{range .Events}}
             {{if and (ne .Type "CalculationEnded") (ne .Type "CalculationCanceled")}}
             case {{lookupEventId .Type}}:
                ctx := context.Background()
                select {
                case jobQueue <- func() {
                    if err := handler.{{.Name}}(ctx); err != nil {
                        log.Error("Event handler {{.Name}} failed", "error", err)
                    }
                }:
                default:
                    log.Warn("Event dropped due to server load", "event", "{{.Name}}")
                }
                return 0, 0
             {{end}}
{{end}}

{{range $i, $fn := .Functions}}             case {{add (MsgUserStart) $i}}: // {{.Name}}
                {{if .Timeout}}
                ctx, cancel := context.WithTimeout(context.Background(), timeout_{{.Name}})
                {{else}}
                ctx := context.Background()
                cancel := func() {}
                {{end}}

                {{if .Async}}
                reqCopy := make([]byte, len(data))
                copy(reqCopy, data)
                select {
                case jobQueue <- func() {
                    defer cancel()
                    handle{{.Name}}(ctx, reqCopy, nil, handler, nil, client, mType, refCache, &refCacheMutex)
                }:
                default:
                    log.Warn("Async worker pool full, returning Busy error", "func", "{{.Name}}")
                    // Fast-fail
                    reqObj := ipc.GetRootAs{{.Name}}Request(reqCopy, 0)
                    h := reqObj.AsyncHandleBytes()
                    queueAsyncResult(h, nil, protocol.AnyValue(0), "Server Busy")
                }

                payload := server.BuildAckResponse(builder, 0, true)
                log.Debug("Sending ACK", "func", "{{.Name}}")

                if cap(builder.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
                    return -int32(len(payload)), server.MsgAck
                }
                if len(payload) > len(respBuf) { return 0, 0 }
                copy(respBuf, payload)
                return int32(len(payload)), server.MsgAck
                {{else}}
                defer cancel()
                len, respId := handle{{.Name}}(ctx, data, respBuf, handler, builder, client, mType, refCache, &refCacheMutex)
                return len, respId
                {{end}}
{{end}}
             default:
                return 0, 0
             }
	}

	client.Handle(dispatch)

	client.Start()
	client.Wait()
}

// ... handle functions ...
{{range $i, $fn := .Functions}}
func handle{{.Name}}(ctx context.Context, req []byte, respBuf []byte, handler XllService, b *flatbuffers.Builder, client *shm.Client, msgType shm.MsgType, refCache map[string][]byte, refCacheMutex *sync.RWMutex) (int32, shm.MsgType) {
	request := ipc.GetRootAs{{.Name}}Request(req, 0)
	_ = request

	{{range .Args}}
	{{if eq .Type "string"}}
	arg_{{.Name}} := string(request.{{.Name|capitalize}}())
	{{else if eq .Type "int?"}}
	var arg_{{.Name}} *int32
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "float?"}}
	var arg_{{.Name}} *float64
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "bool?"}}
	var arg_{{.Name}} *bool
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "range"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "grid"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "numgrid"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "any"}}
	var arg_{{.Name}} *protocol.Any
	arg_{{.Name}}_raw := request.{{.Name|capitalize}}(nil)
	if arg_{{.Name}}_raw != nil {
		if arg_{{.Name}}_raw.ValType() == protocol.AnyValueRefCache {
			var rc protocol.RefCache
			init := new(flatbuffers.Table)
			if arg_{{.Name}}_raw.Val(init) {
				rc.Init(init.Bytes, init.Pos)
				key := string(rc.Key())
				refCacheMutex.RLock()
				if data, ok := refCache[key]; ok {
					cacheReq := protocol.GetRootAsSetRefCacheRequest(data, 0)
					arg_{{.Name}} = cacheReq.Val(nil)
				} else {
					arg_{{.Name}} = arg_{{.Name}}_raw
				}
				refCacheMutex.RUnlock()
			}
		} else {
			arg_{{.Name}} = arg_{{.Name}}_raw
		}
	}
	{{else}}
	arg_{{.Name}} := request.{{.Name|capitalize}}()
	{{end}}
	{{end}}

	{{if .Caller}}
	caller := request.Caller(nil)
	{{end}}

	{{if .Async}}
	handle := request.AsyncHandleBytes()

	log.Debug("Async function start", "func", "{{.Name}}")

	if ctx.Err() != nil {
		queueAsyncResult(handle, nil, protocol.AnyValue(0), ctx.Err().Error())
		return 0, 0
	}

	func() {
		defer func() {
			if r := recover(); r != nil {
				stack := debug.Stack()
				log.Error("Panic in async handler {{.Name}}", "error", r, "stack", string(stack))
				queueAsyncResult(handle, nil, protocol.AnyValue(0), fmt.Sprintf("panic: %v", r))
			}
			log.Debug("Async function end", "func", "{{.Name}}")
		}()

		log.Debug("Processing async request", "func", "{{.Name}}")

		res, err := handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})

		if err != nil {
			queueAsyncResult(handle, nil, protocol.AnyValue(0), err.Error())
		} else {
			{{if eq .Return "string"}}
			queueAsyncResult(handle, res, protocol.AnyValueStr, "")
			{{else if eq .Return "int"}}
			queueAsyncResult(handle, res, protocol.AnyValueInt, "")
			{{else if eq .Return "int?"}}
			if res != nil {
				queueAsyncResult(handle, *res, protocol.AnyValueInt, "")
			} else {
				queueAsyncResult(handle, nil, protocol.AnyValueNil, "")
			}
			{{else if eq .Return "float"}}
			queueAsyncResult(handle, res, protocol.AnyValueNum, "")
			{{else if eq .Return "float?"}}
			if res != nil {
				queueAsyncResult(handle, *res, protocol.AnyValueNum, "")
			} else {
				queueAsyncResult(handle, nil, protocol.AnyValueNil, "")
			}
			{{else if eq .Return "bool"}}
			queueAsyncResult(handle, res, protocol.AnyValueBool, "")
			{{else if eq .Return "bool?"}}
			if res != nil {
				queueAsyncResult(handle, *res, protocol.AnyValueBool, "")
			} else {
				queueAsyncResult(handle, nil, protocol.AnyValueNil, "")
			}
			{{end}}
		}
	}()

	return 0, 0
	{{else}}
	var res {{lookupGoType .Return}}
	var err error

	log.Debug("Sync function start", "func", "{{.Name}}")

	func() {
		defer func() {
			if r := recover(); r != nil {
				stack := debug.Stack()
				log.Error("Panic in sync handler {{.Name}}", "error", r, "stack", string(stack))
				err = fmt.Errorf("panic: %v", r)
			}
			log.Debug("Sync function end", "func", "{{.Name}}")
		}()
		res, err = handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})
	}()

	b.Reset()
	var errOffset flatbuffers.UOffsetT
	if err != nil {
		errOffset = b.CreateString(err.Error())
	}

	{{if eq .Return "string"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil {
		resOffset = b.CreateString(res)
	}
	{{else if eq .Return "int?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		protocol.IntStart(b)
		protocol.IntAddVal(b, *res)
		resOffset = protocol.IntEnd(b)
	}
	{{else if eq .Return "float?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		protocol.NumStart(b)
		protocol.NumAddVal(b, *res)
		resOffset = protocol.NumEnd(b)
	}
	{{else if eq .Return "bool?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		protocol.BoolStart(b)
		protocol.BoolAddVal(b, *res)
		resOffset = protocol.BoolEnd(b)
	}
	{{end}}

	ipc.{{.Name}}ResponseStart(b)
	if err != nil {
		ipc.{{.Name}}ResponseAddError(b, errOffset)
	} else {
		{{if or (eq .Return "string") (eq .Return "int?") (eq .Return "float?") (eq .Return "bool?")}}
		if resOffset > 0 {
			ipc.{{.Name}}ResponseAddResult(b, resOffset)
		}
		{{else}}
		ipc.{{.Name}}ResponseAddResult(b, res)
		{{end}}
	}
	root := ipc.{{.Name}}ResponseEnd(b)
	b.Finish(root)

	// Zero-Copy Return
	// cap(b.Bytes) == cap(respBuf) implies it is still the SHM buffer.
	// If so, data is end-aligned and we return negative size.
	payload := b.FinishedBytes()
	if cap(b.Bytes) == cap(respBuf) && len(payload) <= len(respBuf) {
		return -int32(len(payload)), msgType
	}

	if len(payload) > len(respBuf) {
		// Chunking needed
		transferId := uint64(rand.Int63())

        out := &server.OutgoingChunk{
            Data:       make([]byte, len(payload)),
            Id:         transferId,
            MsgType:    uint32(msgType),
            LastAccess: time.Now(),
        }
		copy(out.Data, payload)
        chunkManager.AddOutgoingChunk(transferId, out)

		const chunkSize = 950 * 1024
		currentSize := chunkSize
		if len(out.Data) < chunkSize {
			currentSize = len(out.Data)
		}

		payload = server.BuildChunkResponse(b, out.Data[0:currentSize], transferId, len(out.Data), 0, uint32(msgType))

		out.Offset = currentSize

		if len(payload) > len(respBuf) {
			return 0, 0 // Fatal: Chunk header overhead made it > 1MB?
		}
		copy(respBuf, payload)
		return int32(len(payload)), server.MsgChunk
	}
	copy(respBuf, payload)
	return int32(len(payload)), msgType
	{{end}}
}

{{end}}

{{if hasAsync .Functions}}
func queueAsyncResult(handle []byte, val interface{}, valType protocol.AnyValue, errStr string) {
	asyncBatcher.QueueResult(handle, val, valType, errStr)
}
{{end}}
