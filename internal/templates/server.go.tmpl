// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"os"
	"strings"
	"sync"
	"time"
	"{{.ModName}}/generated/ipc"
	"{{.ModName}}/generated/ipc/types"
	"github.com/xll-gen/shm/go"
	flatbuffers "github.com/google/flatbuffers/go"
)

// Force usage of time and ipc/types to avoid unused import error
var _ = time.Now
var _ = types.Bool{}

type chunkBuffer struct {
	data      []byte
	totalSize int
	received  int
	mutex     sync.Mutex
}

func Serve(handler XllService) {
	name := "{{.ProjectName}}"
	for _, arg := range os.Args {
		if strings.HasPrefix(arg, "-xll-shm=") {
			name = strings.TrimPrefix(arg, "-xll-shm=")
		}
	}

	client, err := shm.Connect(name)
	if err != nil {
		panic(fmt.Errorf("failed to connect to SHM: %w", err))
	}
	defer client.Close()

	// Global Ref Cache
	var refCacheMutex sync.RWMutex
	refCache := make(map[string][]byte)

	// Chunking Cache
	var chunkCacheMutex sync.Mutex
	chunkCache := make(map[uint64]*chunkBuffer)

	// Configuration
	{{range .Functions}}
	{{if .Timeout}}
	timeout_{{.Name}}, _ := time.ParseDuration("{{.Timeout}}")
	{{end}}
	{{end}}

	workerCount := 100
	if n := {{.ServerWorkers}}; n > 0 {
		workerCount = n
	}

	// Worker Pool
	jobQueue := make(chan func(), workerCount)
	for i := 0; i < workerCount; i++ {
		go func() {
			for job := range jobQueue {
				job()
			}
		}()
	}

	client.Handle(func(req []byte, respBuf []byte, msgId uint32) int32 {
		builder := flatbuffers.NewBuilder(0)
		builder.Reset()

		switch msgId {
		case shm.MsgIdUserStart + 1: // CalculationEnded
			refCacheMutex.Lock()
			refCache = make(map[string][]byte)
			refCacheMutex.Unlock()
			{{if hasEvent "CalculationEnded" .Events}}
			ctx := context.Background()
			jobQueue <- func() {
				if err := handler.OnCalculationEnded(ctx); err != nil {
					fmt.Printf("Event handler OnCalculationEnded failed: %v\n", err)
				}
			}
			{{end}}
			return 0

		case shm.MsgIdUserStart + 3: // SetRefCache
			reqObj := ipc.GetRootAsSetRefCacheRequest(req, 0)
			key := string(reqObj.Key())

			reqCopy := make([]byte, len(req))
			copy(reqCopy, req)

			refCacheMutex.Lock()
			refCache[key] = reqCopy
			refCacheMutex.Unlock()

			ipc.SetRefCacheResponseStart(builder)
			ipc.SetRefCacheResponseAddOk(builder, true)
			root := ipc.SetRefCacheResponseEnd(builder)
			builder.Finish(root)

			payload := builder.FinishedBytes()
			if len(payload) > len(respBuf) { return 0 }
			copy(respBuf, payload)
			return int32(len(payload))

		case shm.MsgIdUserStart + 4: // Chunk
			reqObj := ipc.GetRootAsChunk(req, 0)
			id := reqObj.Id()
			total := int(reqObj.TotalSize())
			offset := int(reqObj.Offset())
			dataLen := reqObj.DataLength()

			chunkCacheMutex.Lock()
			buf, exists := chunkCache[id]
			if !exists {
				buf = &chunkBuffer{
					data:      make([]byte, total),
					totalSize: total,
				}
				chunkCache[id] = buf
			}
			chunkCacheMutex.Unlock()

			buf.mutex.Lock()
			if offset + dataLen <= len(buf.data) {
				copy(buf.data[offset:], reqObj.DataBytes())
				buf.received += dataLen
			}

			isComplete := buf.received >= buf.totalSize
			buf.mutex.Unlock()

			if isComplete {
				chunkCacheMutex.Lock()
				delete(chunkCache, id)
				chunkCacheMutex.Unlock()

				// Assuming the reassembled payload is a SetRefCacheRequest (MsgID 3)
				// We process it directly here.
				cacheReq := ipc.GetRootAsSetRefCacheRequest(buf.data, 0)
				key := string(cacheReq.Key())

				refCacheMutex.Lock()
				refCache[key] = buf.data
				refCacheMutex.Unlock()

				ipc.SetRefCacheResponseStart(builder)
				ipc.SetRefCacheResponseAddOk(builder, true)
				root := ipc.SetRefCacheResponseEnd(builder)
				builder.Finish(root)

				payload := builder.FinishedBytes()
				if len(payload) > len(respBuf) { return 0 }
				copy(respBuf, payload)
				return int32(len(payload))
			}

			// Acknowledge chunk
			// Use SetRefCacheResponse with ok=false to mean "continue" or just empty?
			// Client expects a response to proceed. We can send empty or basic OK.
			// Reusing SetRefCacheResponse is convenient if C++ expects it, but
			// C++ SendChunked knows it's getting intermediate responses.
			// Let's just return a generic OK (true) but C++ will ignore it until the last one.
			// Or better: just return 0 length (void) for intermediate?
			// g_host.Send waits for response. If we return 0, it gets 0 bytes.
			// Let's send a minimal response to confirm receipt.
			ipc.SetRefCacheResponseStart(builder)
			ipc.SetRefCacheResponseAddOk(builder, true) // Ack
			root := ipc.SetRefCacheResponseEnd(builder)
			builder.Finish(root)

			payload := builder.FinishedBytes()
			if len(payload) > len(respBuf) { return 0 }
			copy(respBuf, payload)
			return int32(len(payload))


{{range .Events}}
		{{if ne .Type "CalculationEnded"}}
		case shm.MsgIdUserStart + {{lookupEventId .Type}}: // {{.Type}}
			ctx := context.Background()
			jobQueue <- func() {
				if err := handler.{{.Name}}(ctx); err != nil {
					fmt.Printf("Event handler {{.Name}} failed: %v\n", err)
				}
			}
			return 0
		{{end}}
{{end}}
{{range $i, $fn := .Functions}}		case shm.MsgIdUserStart + {{add 10 $i}}: // {{.Name}}
			{{if .Timeout}}
			ctx, cancel := context.WithTimeout(context.Background(), timeout_{{.Name}})
			{{else}}
			ctx := context.Background()
			cancel := func() {}
			{{end}}

			{{if .Async}}
			// Async: Hand off to worker
			reqCopy := make([]byte, len(req))
			copy(reqCopy, req)

			jobQueue <- func() {
				defer cancel()
				handle{{.Name}}(ctx, reqCopy, nil, handler, nil, client, msgId, refCache, &refCacheMutex)
			}
			return 0
			{{else}}
			// Sync: Run inline
			defer cancel()
			return handle{{.Name}}(ctx, req, respBuf, handler, builder, client, msgId, refCache, &refCacheMutex)
			{{end}}
{{end}}		default:
			return 0
		}
	})

	client.Start()
	client.Wait()
}

{{range $i, $fn := .Functions}}
func handle{{.Name}}(ctx context.Context, req []byte, respBuf []byte, handler XllService, b *flatbuffers.Builder, client *shm.Client, msgId uint32, refCache map[string][]byte, refCacheMutex *sync.RWMutex) int32 {
	request := ipc.GetRootAs{{.Name}}Request(req, 0)

	// Extract args
	{{range .Args}}
	{{if eq .Type "string"}}
	arg_{{.Name}} := string(request.{{.Name|capitalize}}())
	{{else if eq .Type "int?"}}
	var arg_{{.Name}} *int32
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "float?"}}
	var arg_{{.Name}} *float64
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "bool?"}}
	var arg_{{.Name}} *bool
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "string?"}}
	var arg_{{.Name}} *string
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := string(v.Val())
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "range"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "any"}}
	var arg_{{.Name}} *types.Any
	arg_{{.Name}}_raw := request.{{.Name|capitalize}}(nil)
	if arg_{{.Name}}_raw != nil {
		if arg_{{.Name}}_raw.ValType() == types.AnyValueRefCache {
			var rc types.RefCache
			init := new(flatbuffers.Table)
			if arg_{{.Name}}_raw.Val(init) {
				rc.Init(init.Bytes, init.Pos)
				key := string(rc.Key())
				refCacheMutex.RLock()
				if data, ok := refCache[key]; ok {
					cacheReq := ipc.GetRootAsSetRefCacheRequest(data, 0)
					arg_{{.Name}} = cacheReq.Val(nil)
				}
				refCacheMutex.RUnlock()
			}
		} else {
			arg_{{.Name}} = arg_{{.Name}}_raw
		}
	}
	{{else}}
	arg_{{.Name}} := request.{{.Name|capitalize}}()
	{{end}}
	{{end}}

	{{if .Caller}}
	caller := request.Caller(nil)
	{{end}}

	{{if .Async}}
	// Async execution
	handle := request.AsyncHandle()

	if ctx.Err() != nil {
		sendAsyncError{{.Name}}(client, msgId, handle, ctx.Err())
		return 0
	}

	// Call handler
	res, err := handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})

	b2 := flatbuffers.NewBuilder(0)
	var errOffset flatbuffers.UOffsetT
	if err != nil {
		errOffset = b2.CreateString(err.Error())
	}

	{{if eq .Return "string"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil {
		resOffset = b2.CreateString(res)
	}
	{{else if eq .Return "int?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.IntStart(b2)
		types.IntAddVal(b2, *res)
		resOffset = types.IntEnd(b2)
	}
	{{else if eq .Return "float?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.NumStart(b2)
		types.NumAddVal(b2, *res)
		resOffset = types.NumEnd(b2)
	}
	{{else if eq .Return "bool?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.BoolStart(b2)
		types.BoolAddVal(b2, *res)
		resOffset = types.BoolEnd(b2)
	}
	{{else if eq .Return "string?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		valOff := b2.CreateString(*res)
		types.StrStart(b2)
		types.StrAddVal(b2, valOff)
		resOffset = types.StrEnd(b2)
	}
	{{end}}

	ipc.{{.Name}}ResponseStart(b2)
	ipc.{{.Name}}ResponseAddAsyncHandle(b2, handle)
	if err != nil {
		ipc.{{.Name}}ResponseAddError(b2, errOffset)
	} else {
		{{if or (eq .Return "string") (eq .Return "int?") (eq .Return "float?") (eq .Return "bool?") (eq .Return "string?")}}
		if resOffset > 0 {
			ipc.{{.Name}}ResponseAddResult(b2, resOffset)
		}
		{{else}}
		ipc.{{.Name}}ResponseAddResult(b2, res)
		{{end}}
	}
	root := ipc.{{.Name}}ResponseEnd(b2)
	b2.Finish(root)

	// Send Guest Call
	if _, err := client.SendGuestCall(b2.FinishedBytes(), msgId); err != nil {
		fmt.Printf("Error sending guest call for {{.Name}}: %v\n", err)
	}
	return 0
	{{else}}
	// Sync execution
	// Call handler
	res, err := handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})

	b.Reset()
	var errOffset flatbuffers.UOffsetT
	if err != nil {
		errOffset = b.CreateString(err.Error())
	}

	{{if eq .Return "string"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil {
		resOffset = b.CreateString(res)
	}
	{{else if eq .Return "int?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.IntStart(b)
		types.IntAddVal(b, *res)
		resOffset = types.IntEnd(b)
	}
	{{else if eq .Return "float?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.NumStart(b)
		types.NumAddVal(b, *res)
		resOffset = types.NumEnd(b)
	}
	{{else if eq .Return "bool?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.BoolStart(b)
		types.BoolAddVal(b, *res)
		resOffset = types.BoolEnd(b)
	}
	{{else if eq .Return "string?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		valOff := b.CreateString(*res)
		types.StrStart(b)
		types.StrAddVal(b, valOff)
		resOffset = types.StrEnd(b)
	}
	{{end}}

	ipc.{{.Name}}ResponseStart(b)
	if err != nil {
		ipc.{{.Name}}ResponseAddError(b, errOffset)
	} else {
		{{if or (eq .Return "string") (eq .Return "int?") (eq .Return "float?") (eq .Return "bool?") (eq .Return "string?")}}
		if resOffset > 0 {
			ipc.{{.Name}}ResponseAddResult(b, resOffset)
		}
		{{else}}
		ipc.{{.Name}}ResponseAddResult(b, res)
		{{end}}
	}
	root := ipc.{{.Name}}ResponseEnd(b)
	b.Finish(root)

	// Copy to respBuf
	payload := b.FinishedBytes()
	if len(payload) > len(respBuf) {
		return 0 // Error: buffer too small
	}
	copy(respBuf, payload)
	return int32(len(payload))
	{{end}}
}

{{if .Async}}
func sendAsyncError{{.Name}}(client *shm.Client, msgId uint32, handle uint64, err error) {
	b := flatbuffers.NewBuilder(0)
	errOffset := b.CreateString(err.Error())
	ipc.{{.Name}}ResponseStart(b)
	ipc.{{.Name}}ResponseAddAsyncHandle(b, handle)
	ipc.{{.Name}}ResponseAddError(b, errOffset)
	root := ipc.{{.Name}}ResponseEnd(b)
	b.Finish(root)
	client.SendGuestCall(b.FinishedBytes(), msgId)
}
{{end}}
{{end}}
