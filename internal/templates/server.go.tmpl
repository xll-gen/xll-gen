// Code generated by xll-gen {{.Version}}. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"strings"
	"sync"
	"time"
	"runtime"
	"{{.ModName}}/generated/ipc"
	"{{.ModName}}/generated/ipc/types"
	"github.com/xll-gen/shm/go"
	flatbuffers "github.com/google/flatbuffers/go"
)

// Force usage of time and ipc/types to avoid unused import error
var _ = time.Now
var _ = types.Bool{}

const (
	MSG_ACK                  = 2
	MSG_CHUNK                = 128
	MSG_SETREFCACHE          = 129
	MSG_CALCULATION_ENDED    = 130
	MSG_CALCULATION_CANCELED = 131
	MSG_USER_START           = 132
)

type chunkBuffer struct {
	data       []byte
	totalSize  int
	received   int
	mutex      sync.Mutex
	lastAccess time.Time
}

type outgoingChunk struct {
	data       []byte
	offset     int
	id         uint64
	msgId      uint32
	lastAccess time.Time
}

// Command Queue
type queuedCommand struct {
	cmdType int // 0: Set, 1: Format
	data    []byte
}
var (
	cmdQueueLock sync.Mutex
	cmdQueue     []queuedCommand
)

func ScheduleSet(r *types.Range, v *types.Any) {
	b := flatbuffers.NewBuilder(0)
	rOff := cloneRange(b, r)
	vOff := cloneAny(b, v)

	ipc.SetCommandStart(b)
	ipc.SetCommandAddTarget(b, rOff)
	ipc.SetCommandAddValue(b, vOff)
	root := ipc.SetCommandEnd(b)
	b.Finish(root)

	cmdQueueLock.Lock()
	cmdQueue = append(cmdQueue, queuedCommand{0, b.FinishedBytes()})
	cmdQueueLock.Unlock()
}

func ScheduleFormat(r *types.Range, fmtStr string) {
	b := flatbuffers.NewBuilder(0)
	rOff := cloneRange(b, r)
	fOff := b.CreateString(fmtStr)

	ipc.FormatCommandStart(b)
	ipc.FormatCommandAddTarget(b, rOff)
	ipc.FormatCommandAddFormat(b, fOff)
	root := ipc.FormatCommandEnd(b)
	b.Finish(root)

	cmdQueueLock.Lock()
	cmdQueue = append(cmdQueue, queuedCommand{1, b.FinishedBytes()})
	cmdQueueLock.Unlock()
}

func Serve(handler XllService) {
	name := "{{.ProjectName}}"
	for _, arg := range os.Args {
		if strings.HasPrefix(arg, "-xll-shm=") {
			name = strings.TrimPrefix(arg, "-xll-shm=")
		}
	}

	client, err := shm.Connect(name)
	if err != nil {
		panic(fmt.Errorf("failed to connect to SHM: %w", err))
	}
	defer client.Close()

	// Global Ref Cache
	var refCacheMutex sync.RWMutex
	refCache := make(map[string][]byte)

	// Chunking Cache
	var chunkCacheMutex sync.Mutex
	chunkCache := make(map[uint64]*chunkBuffer)

	// Outgoing Chunks
	var outgoingChunksMutex sync.Mutex
	outgoingChunks := make(map[uint64]*outgoingChunk)

	// Cleanup Ticker
	go func() {
		ticker := time.NewTicker(30 * time.Second)
		for range ticker.C {
			now := time.Now()
			chunkCacheMutex.Lock()
			for id, buf := range chunkCache {
				if now.Sub(buf.lastAccess) > 60*time.Second {
					delete(chunkCache, id)
				}
			}
			chunkCacheMutex.Unlock()

			outgoingChunksMutex.Lock()
			for id, buf := range outgoingChunks {
				if now.Sub(buf.lastAccess) > 60*time.Second {
					delete(outgoingChunks, id)
				}
			}
			outgoingChunksMutex.Unlock()
		}
	}()

	// Configuration
	{{range .Functions}}
	{{if .Timeout}}
	timeout_{{.Name}}, _ := time.ParseDuration("{{.Timeout}}")
	{{end}}
	{{end}}

	workerCount := runtime.NumCPU()
	if n := {{.ServerWorkers}}; n > 0 {
		workerCount = n
	}

	// Worker Pool
	jobQueue := make(chan func(), workerCount)
	for i := 0; i < workerCount; i++ {
		go func() {
			for job := range jobQueue {
				job()
			}
		}()
	}

	client.Handle(func(req []byte, respBuf []byte, msgId shm.MsgType) (int32, shm.MsgType) {
		currentReq := req
		currentMsgId := msgId
		builder := flatbuffers.NewBuilder(0)

		for {
			builder.Reset()
			switch uint32(currentMsgId) {
			case MSG_CALCULATION_ENDED: // 130
				refCacheMutex.Lock()
				refCache = make(map[string][]byte)
				refCacheMutex.Unlock()

				{{if hasEvent "CalculationEnded" .Events}}
				var wg sync.WaitGroup
				wg.Add(1)
				jobQueue <- func() {
					defer wg.Done()
					if err := handler.OnCalculationEnded(context.Background()); err != nil {
						fmt.Printf("Event handler OnCalculationEnded failed: %v\n", err)
					}
				}
				wg.Wait()
				{{end}}

				respBytes := flushCommands()
				if len(respBytes) > 0 {
					if len(respBytes) > len(respBuf) {
						// Chunking for Commands?
						// Reuse logic?
						// For now, assume it fits or fail gracefully.
						// TODO: Implement chunking for responses > 1MB
						fmt.Printf("Warning: CalculationEnded response too large (%d)\n", len(respBytes))
						return 0, 0
					}
					copy(respBuf, respBytes)
					return int32(len(respBytes)), MSG_CALCULATION_ENDED
				}
				return 0, 0

			case MSG_CALCULATION_CANCELED: // 131
				// Clear queue
				cmdQueueLock.Lock()
				cmdQueue = nil
				cmdQueueLock.Unlock()

				{{if hasEvent "CalculationCanceled" .Events}}
				ctx := context.Background()
				jobQueue <- func() {
					if err := handler.OnCalculationCanceled(ctx); err != nil {
						fmt.Printf("Event handler OnCalculationCanceled failed: %v\n", err)
					}
				}
				{{end}}
				return 0, 0

			case MSG_SETREFCACHE: // 129
				reqObj := ipc.GetRootAsSetRefCacheRequest(currentReq, 0)
				key := string(reqObj.Key())

				reqCopy := make([]byte, len(currentReq))
				copy(reqCopy, currentReq)

				refCacheMutex.Lock()
				refCache[key] = reqCopy
				refCacheMutex.Unlock()

				// Send Ack (MsgID 2)
				ipc.AckStart(builder)
				ipc.AckAddOk(builder, true)
				root := ipc.AckEnd(builder)
				builder.Finish(root)

				payload := builder.FinishedBytes()
				if len(payload) > len(respBuf) { return 0, 0 }
				copy(respBuf, payload)
				return int32(len(payload)), MSG_ACK

			case MSG_ACK: // 2 (Ack for outgoing chunk)
				reqObj := ipc.GetRootAsAck(currentReq, 0)
				id := reqObj.Id()
				// ok := reqObj.Ok() // Assuming true means "give me next"

				outgoingChunksMutex.Lock()
				out, exists := outgoingChunks[id]
				if !exists {
					outgoingChunksMutex.Unlock()
					return 0, 0
				}
				out.lastAccess = time.Now()

				// Send next chunk
				const chunkSize = 950 * 1024
				remaining := len(out.data) - out.offset
				currentSize := chunkSize
				if remaining < chunkSize {
					currentSize = remaining
				}

				if currentSize <= 0 {
					// Done
					delete(outgoingChunks, id)
					outgoingChunksMutex.Unlock()
					return 0, 0
				}

				builder.Reset()
				dataOff := builder.CreateByteVector(out.data[out.offset : out.offset+currentSize])
				ipc.ChunkStart(builder)
				ipc.ChunkAddId(builder, id)
				ipc.ChunkAddTotalSize(builder, uint32(len(out.data)))
				ipc.ChunkAddOffset(builder, uint32(out.offset))
				ipc.ChunkAddData(builder, dataOff)
				ipc.ChunkAddMsgId(builder, out.msgId) // Original MsgID
				root := ipc.ChunkEnd(builder)
				builder.FinishWithFileIdentifier(root, []byte("XCHN"))

				out.offset += currentSize
				if out.offset >= len(out.data) {
					delete(outgoingChunks, id)
				}
				outgoingChunksMutex.Unlock()

				payload := builder.FinishedBytes()
				if len(payload) > len(respBuf) { return 0, 0 }
				copy(respBuf, payload)
				return int32(len(payload)), MSG_CHUNK

			case MSG_CHUNK: // 128 (Incoming Chunk)
				reqObj := ipc.GetRootAsChunk(currentReq, 0)
				id := reqObj.Id()
				total := int(reqObj.TotalSize())
				offset := int(reqObj.Offset())
				dataLen := reqObj.DataLength()

				chunkCacheMutex.Lock()
				buf, exists := chunkCache[id]
				if !exists {
					buf = &chunkBuffer{
						data:       make([]byte, total),
						totalSize:  total,
						lastAccess: time.Now(),
					}
					chunkCache[id] = buf
				}
				buf.lastAccess = time.Now()
				chunkCacheMutex.Unlock()

				buf.mutex.Lock()
				if offset + dataLen <= len(buf.data) {
					copy(buf.data[offset:], reqObj.DataBytes())
					buf.received += dataLen
				}

				isComplete := buf.received >= buf.totalSize
				buf.mutex.Unlock()

				if isComplete {
					chunkCacheMutex.Lock()
					delete(chunkCache, id)
					chunkCacheMutex.Unlock()

					// Reassembled - Update current request and restart loop
					currentMsgId = shm.MsgType(reqObj.MsgId())
					currentReq = buf.data
					continue
				}

				// Acknowledge this chunk to request next
				ipc.AckStart(builder)
				ipc.AckAddId(builder, id)
				ipc.AckAddOk(builder, true)
				root := ipc.AckEnd(builder)
				builder.Finish(root)

				payload := builder.FinishedBytes()
				if len(payload) > len(respBuf) { return 0, 0 }
				copy(respBuf, payload)
				return int32(len(payload)), MSG_ACK


	{{range .Events}}
			{{if and (ne .Type "CalculationEnded") (ne .Type "CalculationCanceled")}}
			case {{lookupEventId .Type}}: // {{.Type}}
				ctx := context.Background()
				jobQueue <- func() {
					if err := handler.{{.Name}}(ctx); err != nil {
						fmt.Printf("Event handler {{.Name}} failed: %v\n", err)
					}
				}
				return 0, 0
			{{end}}
	{{end}}
	{{range $i, $fn := .Functions}}		case {{add 132 $i}}: // {{.Name}}
				{{if .Timeout}}
				ctx, cancel := context.WithTimeout(context.Background(), timeout_{{.Name}})
				{{else}}
				ctx := context.Background()
				cancel := func() {}
				{{end}}

				{{if .Async}}
				// Async: Hand off to worker
				reqCopy := make([]byte, len(currentReq))
				copy(reqCopy, currentReq)

				jobQueue <- func() {
					defer cancel()
					handle{{.Name}}(ctx, reqCopy, nil, handler, nil, client, currentMsgId, refCache, &refCacheMutex, outgoingChunks, &outgoingChunksMutex)
				}
				return 0, 0
				{{else}}
				// Sync: Run inline
				defer cancel()
				len, respId := handle{{.Name}}(ctx, currentReq, respBuf, handler, builder, client, currentMsgId, refCache, &refCacheMutex, outgoingChunks, &outgoingChunksMutex)
				return len, respId
				{{end}}
	{{end}}		default:
				return 0, 0
			}
			break // Break out of loop if case returns or falls through
		}
		return 0, 0
	})

	client.Start()
	client.Wait()
}

// ... handle functions ...
{{range $i, $fn := .Functions}}
func handle{{.Name}}(ctx context.Context, req []byte, respBuf []byte, handler XllService, b *flatbuffers.Builder, client *shm.Client, msgId shm.MsgType, refCache map[string][]byte, refCacheMutex *sync.RWMutex, outgoingChunks map[uint64]*outgoingChunk, outgoingChunksMutex *sync.Mutex) (int32, shm.MsgType) {
	request := ipc.GetRootAs{{.Name}}Request(req, 0)
	_ = request

	// Extract args
	{{range .Args}}
	{{if eq .Type "string"}}
	arg_{{.Name}} := string(request.{{.Name|capitalize}}())
	{{else if eq .Type "int?"}}
	var arg_{{.Name}} *int32
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "float?"}}
	var arg_{{.Name}} *float64
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "bool?"}}
	var arg_{{.Name}} *bool
	if v := request.{{.Name|capitalize}}(nil); v != nil {
		val := v.Val()
		arg_{{.Name}} = &val
	}
	{{else if eq .Type "range"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "grid"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "numgrid"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "numgrid"}}
	arg_{{.Name}} := request.{{.Name|capitalize}}(nil)
	{{else if eq .Type "any"}}
	var arg_{{.Name}} *types.Any
	arg_{{.Name}}_raw := request.{{.Name|capitalize}}(nil)
	if arg_{{.Name}}_raw != nil {
		if arg_{{.Name}}_raw.ValType() == types.AnyValueRefCache {
			var rc types.RefCache
			init := new(flatbuffers.Table)
			if arg_{{.Name}}_raw.Val(init) {
				rc.Init(init.Bytes, init.Pos)
				key := string(rc.Key())
				refCacheMutex.RLock()
				if data, ok := refCache[key]; ok {
					cacheReq := ipc.GetRootAsSetRefCacheRequest(data, 0)
					arg_{{.Name}} = cacheReq.Val(nil)
				}
				refCacheMutex.RUnlock()
			}
		} else {
			arg_{{.Name}} = arg_{{.Name}}_raw
		}
	}
	{{else}}
	arg_{{.Name}} := request.{{.Name|capitalize}}()
	{{end}}
	{{end}}

	{{if .Caller}}
	caller := request.Caller(nil)
	{{end}}

	{{if .Async}}
	// Async execution
	handle := request.AsyncHandle()

	if ctx.Err() != nil {
		sendAsyncError{{.Name}}(client, msgId, handle, ctx.Err())
		return 0, 0
	}

	// Call handler
	res, err := handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})

	b2 := flatbuffers.NewBuilder(0)
	var errOffset flatbuffers.UOffsetT
	if err != nil {
		errOffset = b2.CreateString(err.Error())
	}

	{{if eq .Return "string"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil {
		resOffset = b2.CreateString(res)
	}
	{{else if eq .Return "int?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.IntStart(b2)
		types.IntAddVal(b2, *res)
		resOffset = types.IntEnd(b2)
	}
	{{else if eq .Return "float?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.NumStart(b2)
		types.NumAddVal(b2, *res)
		resOffset = types.NumEnd(b2)
	}
	{{else if eq .Return "bool?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.BoolStart(b2)
		types.BoolAddVal(b2, *res)
		resOffset = types.BoolEnd(b2)
	}
	{{end}}

	ipc.{{.Name}}ResponseStart(b2)
	ipc.{{.Name}}ResponseAddAsyncHandle(b2, handle)
	if err != nil {
		ipc.{{.Name}}ResponseAddError(b2, errOffset)
	} else {
		{{if or (eq .Return "string") (eq .Return "int?") (eq .Return "float?") (eq .Return "bool?")}}
		if resOffset > 0 {
			ipc.{{.Name}}ResponseAddResult(b2, resOffset)
		}
		{{else}}
		ipc.{{.Name}}ResponseAddResult(b2, res)
		{{end}}
	}
	root := ipc.{{.Name}}ResponseEnd(b2)
	b2.Finish(root)

	// Send Guest Call
	if _, err := client.SendGuestCall(b2.FinishedBytes(), msgId); err != nil {
		fmt.Printf("Error sending guest call for {{.Name}}: %v\n", err)
	}
	return 0, 0
	{{else}}
	// Sync execution
	// Call handler
	res, err := handler.{{.Name}}(ctx{{range .Args}}, arg_{{.Name}}{{end}}{{if .Caller}}, caller{{end}})

	b.Reset()
	var errOffset flatbuffers.UOffsetT
	if err != nil {
		errOffset = b.CreateString(err.Error())
	}

	{{if eq .Return "string"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil {
		resOffset = b.CreateString(res)
	}
	{{else if eq .Return "int?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.IntStart(b)
		types.IntAddVal(b, *res)
		resOffset = types.IntEnd(b)
	}
	{{else if eq .Return "float?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.NumStart(b)
		types.NumAddVal(b, *res)
		resOffset = types.NumEnd(b)
	}
	{{else if eq .Return "bool?"}}
	var resOffset flatbuffers.UOffsetT
	if err == nil && res != nil {
		types.BoolStart(b)
		types.BoolAddVal(b, *res)
		resOffset = types.BoolEnd(b)
	}
	{{end}}

	ipc.{{.Name}}ResponseStart(b)
	if err != nil {
		ipc.{{.Name}}ResponseAddError(b, errOffset)
	} else {
		{{if or (eq .Return "string") (eq .Return "int?") (eq .Return "float?") (eq .Return "bool?")}}
		if resOffset > 0 {
			ipc.{{.Name}}ResponseAddResult(b, resOffset)
		}
		{{else}}
		ipc.{{.Name}}ResponseAddResult(b, res)
		{{end}}
	}
	root := ipc.{{.Name}}ResponseEnd(b)
	b.Finish(root)

	// Copy to respBuf
	payload := b.FinishedBytes()
	if len(payload) > len(respBuf) {
		// Chunking needed
		transferId := uint64(rand.Int63())

		outgoingChunksMutex.Lock()
		outgoingChunks[transferId] = &outgoingChunk{
			data:       make([]byte, len(payload)),
			id:         transferId,
			msgId:      uint32(msgId),
			lastAccess: time.Now(),
		}
		copy(outgoingChunks[transferId].data, payload)

		out := outgoingChunks[transferId]
		const chunkSize = 950 * 1024
		currentSize := chunkSize
		if len(out.data) < chunkSize {
			currentSize = len(out.data)
		}

		b.Reset()
		dataOff := b.CreateByteVector(out.data[0:currentSize])
		ipc.ChunkStart(b)
		ipc.ChunkAddId(b, transferId)
		ipc.ChunkAddTotalSize(b, uint32(len(out.data)))
		ipc.ChunkAddOffset(b, 0)
		ipc.ChunkAddData(b, dataOff)
		ipc.ChunkAddMsgId(b, uint32(msgId))
		root := ipc.ChunkEnd(b)
		b.FinishWithFileIdentifier(root, []byte("XCHN"))

		out.offset = currentSize
		outgoingChunksMutex.Unlock()

		payload = b.FinishedBytes()
		if len(payload) > len(respBuf) {
			return 0, 0 // Fatal: Chunk header overhead made it > 1MB?
		}
		copy(respBuf, payload)
		return int32(len(payload)), MSG_CHUNK
	}
	copy(respBuf, payload)
	return int32(len(payload)), msgId
	{{end}}
}

{{if .Async}}
func sendAsyncError{{.Name}}(client *shm.Client, msgId shm.MsgType, handle uint64, err error) {
	b := flatbuffers.NewBuilder(0)
	errOffset := b.CreateString(err.Error())
	ipc.{{.Name}}ResponseStart(b)
	ipc.{{.Name}}ResponseAddAsyncHandle(b, handle)
	ipc.{{.Name}}ResponseAddError(b, errOffset)
	root := ipc.{{.Name}}ResponseEnd(b)
	b.Finish(root)
	client.SendGuestCall(b.FinishedBytes(), msgId)
}
{{end}}
{{end}}

func flushCommands() []byte {
	cmdQueueLock.Lock()
	defer cmdQueueLock.Unlock()

	if len(cmdQueue) == 0 {
		return nil
	}

	b := flatbuffers.NewBuilder(0)

	wrappers := make([]flatbuffers.UOffsetT, len(cmdQueue))

	for i, c := range cmdQueue {
		var uOff flatbuffers.UOffsetT
		var uType ipc.Command

		if c.cmdType == 0 {
			cmd := ipc.GetRootAsSetCommand(c.data, 0)
			rOff := cloneRange(b, cmd.Target(nil))
			vOff := cloneAny(b, cmd.Value(nil))

			ipc.SetCommandStart(b)
			ipc.SetCommandAddTarget(b, rOff)
			ipc.SetCommandAddValue(b, vOff)
			uOff = ipc.SetCommandEnd(b)
			uType = ipc.CommandSetCommand
		} else {
			cmd := ipc.GetRootAsFormatCommand(c.data, 0)
			rOff := cloneRange(b, cmd.Target(nil))
			fOff := b.CreateString(string(cmd.Format()))

			ipc.FormatCommandStart(b)
			ipc.FormatCommandAddTarget(b, rOff)
			ipc.FormatCommandAddFormat(b, fOff)
			uOff = ipc.FormatCommandEnd(b)
			uType = ipc.CommandFormatCommand
		}

		ipc.CommandWrapperStart(b)
		ipc.CommandWrapperAddCmdType(b, uType)
		ipc.CommandWrapperAddCmd(b, uOff)
		wrappers[i] = ipc.CommandWrapperEnd(b)
	}

	ipc.CalculationEndedResponseStartCommandsVector(b, len(wrappers))
	for i := len(wrappers) - 1; i >= 0; i-- {
		b.PrependUOffsetT(wrappers[i])
	}
	cmdsOff := b.EndVector(len(wrappers))

	ipc.CalculationEndedResponseStart(b)
	ipc.CalculationEndedResponseAddCommands(b, cmdsOff)
	root := ipc.CalculationEndedResponseEnd(b)
	b.Finish(root)

	cmdQueue = nil
	return b.FinishedBytes()
}

func cloneRange(b *flatbuffers.Builder, r *types.Range) flatbuffers.UOffsetT {
	if r == nil { return 0 }
	s := r.SheetName()
	sOff := b.CreateString(string(s))

	l := r.RefsLength()
	types.RangeStartRefsVector(b, l)
	for i := l - 1; i >= 0; i-- {
		obj := new(types.Rect)
		if r.Refs(obj, i) {
			types.CreateRect(b, obj.RowFirst(), obj.RowLast(), obj.ColFirst(), obj.ColLast())
		}
	}
	refsOff := b.EndVector(l)

	types.RangeStart(b)
	types.RangeAddSheetName(b, sOff)
	types.RangeAddRefs(b, refsOff)
	return types.RangeEnd(b)
}

func cloneAny(b *flatbuffers.Builder, a *types.Any) flatbuffers.UOffsetT {
	if a == nil { return 0 }
	var uOff flatbuffers.UOffsetT
	t := a.ValType()

    var tbl flatbuffers.Table
    if a.Val(&tbl) {
        switch t {
        case types.AnyValueNum:
            var val types.Num
            val.Init(tbl.Bytes, tbl.Pos)
            types.NumStart(b)
            types.NumAddVal(b, val.Val())
            uOff = types.NumEnd(b)
        case types.AnyValueInt:
            var val types.Int
            val.Init(tbl.Bytes, tbl.Pos)
            types.IntStart(b)
            types.IntAddVal(b, val.Val())
            uOff = types.IntEnd(b)
        case types.AnyValueBool:
            var val types.Bool
            val.Init(tbl.Bytes, tbl.Pos)
            types.BoolStart(b)
            types.BoolAddVal(b, val.Val())
            uOff = types.BoolEnd(b)
        case types.AnyValueStr:
            var val types.Str
            val.Init(tbl.Bytes, tbl.Pos)
            sOff := b.CreateString(string(val.Val()))
            types.StrStart(b)
            types.StrAddVal(b, sOff)
            uOff = types.StrEnd(b)
        case types.AnyValueErr:
            var val types.Err
            val.Init(tbl.Bytes, tbl.Pos)
            types.ErrStart(b)
            types.ErrAddVal(b, val.Val())
            uOff = types.ErrEnd(b)
        case types.AnyValueNumGrid:
            var val types.NumGrid
            val.Init(tbl.Bytes, tbl.Pos)
            l := val.DataLength()
            types.NumGridStartDataVector(b, l)
            for i := l - 1; i >= 0; i-- {
                b.PrependFloat64(val.Data(i))
            }
            dataOff := b.EndVector(l)

            types.NumGridStart(b)
            types.NumGridAddRows(b, val.Rows())
            types.NumGridAddCols(b, val.Cols())
            types.NumGridAddData(b, dataOff)
            uOff = types.NumGridEnd(b)
        // Missing: Grid, RefCache (simplified)
        default:
            // Nil
            types.NilStart(b)
            uOff = types.NilEnd(b)
        }
    } else {
        types.NilStart(b)
        uOff = types.NilEnd(b)
    }

	types.AnyStart(b)
	types.AnyAddValType(b, t)
	types.AnyAddVal(b, uOff)
	return types.AnyEnd(b)
}
