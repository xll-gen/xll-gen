// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace protocol {

struct Bool;
struct BoolBuilder;

struct Num;
struct NumBuilder;

struct Int;
struct IntBuilder;

struct Str;
struct StrBuilder;

struct Err;
struct ErrBuilder;

struct AsyncHandle;
struct AsyncHandleBuilder;

struct Nil;
struct NilBuilder;

struct RefCache;
struct RefCacheBuilder;

struct Rect;

struct Range;
struct RangeBuilder;

struct Scalar;
struct ScalarBuilder;

struct Grid;
struct GridBuilder;

struct NumGrid;
struct NumGridBuilder;

struct Any;
struct AnyBuilder;

struct Ack;
struct AckBuilder;

struct Chunk;
struct ChunkBuilder;

struct SetRefCacheRequest;
struct SetRefCacheRequestBuilder;

struct SetCommand;
struct SetCommandBuilder;

struct FormatCommand;
struct FormatCommandBuilder;

struct CommandWrapper;
struct CommandWrapperBuilder;

struct CalculationEndedResponse;
struct CalculationEndedResponseBuilder;

struct AsyncResult;
struct AsyncResultBuilder;

struct BatchAsyncResponse;
struct BatchAsyncResponseBuilder;

enum XlError : int16_t {
  XlError_Null = 2000,
  XlError_Div0 = 2007,
  XlError_Value = 2015,
  XlError_Ref = 2023,
  XlError_Name = 2029,
  XlError_Num = 2036,
  XlError_NA = 2042,
  XlError_GettingData = 2043,
  XlError_Spill = 2045,
  XlError_Connect = 2046,
  XlError_Blocked = 2047,
  XlError_Unknown = 2048,
  XlError_Field = 2049,
  XlError_Calc = 2050,
  XlError_MIN = XlError_Null,
  XlError_MAX = XlError_Calc
};

inline const XlError (&EnumValuesXlError())[14] {
  static const XlError values[] = {
    XlError_Null,
    XlError_Div0,
    XlError_Value,
    XlError_Ref,
    XlError_Name,
    XlError_Num,
    XlError_NA,
    XlError_GettingData,
    XlError_Spill,
    XlError_Connect,
    XlError_Blocked,
    XlError_Unknown,
    XlError_Field,
    XlError_Calc
  };
  return values;
}

inline const char * const *EnumNamesXlError() {
  static const char * const names[52] = {
    "Null",
    "",
    "",
    "",
    "",
    "",
    "",
    "Div0",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Value",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Ref",
    "",
    "",
    "",
    "",
    "",
    "Name",
    "",
    "",
    "",
    "",
    "",
    "",
    "Num",
    "",
    "",
    "",
    "",
    "",
    "NA",
    "GettingData",
    "",
    "Spill",
    "Connect",
    "Blocked",
    "Unknown",
    "Field",
    "Calc",
    nullptr
  };
  return names;
}

inline const char *EnumNameXlError(XlError e) {
  if (::flatbuffers::IsOutRange(e, XlError_Null, XlError_Calc)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(XlError_Null);
  return EnumNamesXlError()[index];
}

enum ScalarValue : uint8_t {
  ScalarValue_NONE = 0,
  ScalarValue_Bool = 1,
  ScalarValue_Num = 2,
  ScalarValue_Int = 3,
  ScalarValue_Str = 4,
  ScalarValue_Err = 5,
  ScalarValue_AsyncHandle = 6,
  ScalarValue_Nil = 7,
  ScalarValue_MIN = ScalarValue_NONE,
  ScalarValue_MAX = ScalarValue_Nil
};

inline const ScalarValue (&EnumValuesScalarValue())[8] {
  static const ScalarValue values[] = {
    ScalarValue_NONE,
    ScalarValue_Bool,
    ScalarValue_Num,
    ScalarValue_Int,
    ScalarValue_Str,
    ScalarValue_Err,
    ScalarValue_AsyncHandle,
    ScalarValue_Nil
  };
  return values;
}

inline const char * const *EnumNamesScalarValue() {
  static const char * const names[9] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarValue(ScalarValue e) {
  if (::flatbuffers::IsOutRange(e, ScalarValue_NONE, ScalarValue_Nil)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarValue()[index];
}

template<typename T> struct ScalarValueTraits {
  static const ScalarValue enum_value = ScalarValue_NONE;
};

template<> struct ScalarValueTraits<protocol::Bool> {
  static const ScalarValue enum_value = ScalarValue_Bool;
};

template<> struct ScalarValueTraits<protocol::Num> {
  static const ScalarValue enum_value = ScalarValue_Num;
};

template<> struct ScalarValueTraits<protocol::Int> {
  static const ScalarValue enum_value = ScalarValue_Int;
};

template<> struct ScalarValueTraits<protocol::Str> {
  static const ScalarValue enum_value = ScalarValue_Str;
};

template<> struct ScalarValueTraits<protocol::Err> {
  static const ScalarValue enum_value = ScalarValue_Err;
};

template<> struct ScalarValueTraits<protocol::AsyncHandle> {
  static const ScalarValue enum_value = ScalarValue_AsyncHandle;
};

template<> struct ScalarValueTraits<protocol::Nil> {
  static const ScalarValue enum_value = ScalarValue_Nil;
};

bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type);
bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum AnyValue : uint8_t {
  AnyValue_NONE = 0,
  AnyValue_Bool = 1,
  AnyValue_Num = 2,
  AnyValue_Int = 3,
  AnyValue_Str = 4,
  AnyValue_Err = 5,
  AnyValue_AsyncHandle = 6,
  AnyValue_Nil = 7,
  AnyValue_Grid = 8,
  AnyValue_NumGrid = 9,
  AnyValue_Range = 10,
  AnyValue_RefCache = 11,
  AnyValue_MIN = AnyValue_NONE,
  AnyValue_MAX = AnyValue_RefCache
};

inline const AnyValue (&EnumValuesAnyValue())[12] {
  static const AnyValue values[] = {
    AnyValue_NONE,
    AnyValue_Bool,
    AnyValue_Num,
    AnyValue_Int,
    AnyValue_Str,
    AnyValue_Err,
    AnyValue_AsyncHandle,
    AnyValue_Nil,
    AnyValue_Grid,
    AnyValue_NumGrid,
    AnyValue_Range,
    AnyValue_RefCache
  };
  return values;
}

inline const char * const *EnumNamesAnyValue() {
  static const char * const names[13] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    "Grid",
    "NumGrid",
    "Range",
    "RefCache",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyValue(AnyValue e) {
  if (::flatbuffers::IsOutRange(e, AnyValue_NONE, AnyValue_RefCache)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyValue()[index];
}

template<typename T> struct AnyValueTraits {
  static const AnyValue enum_value = AnyValue_NONE;
};

template<> struct AnyValueTraits<protocol::Bool> {
  static const AnyValue enum_value = AnyValue_Bool;
};

template<> struct AnyValueTraits<protocol::Num> {
  static const AnyValue enum_value = AnyValue_Num;
};

template<> struct AnyValueTraits<protocol::Int> {
  static const AnyValue enum_value = AnyValue_Int;
};

template<> struct AnyValueTraits<protocol::Str> {
  static const AnyValue enum_value = AnyValue_Str;
};

template<> struct AnyValueTraits<protocol::Err> {
  static const AnyValue enum_value = AnyValue_Err;
};

template<> struct AnyValueTraits<protocol::AsyncHandle> {
  static const AnyValue enum_value = AnyValue_AsyncHandle;
};

template<> struct AnyValueTraits<protocol::Nil> {
  static const AnyValue enum_value = AnyValue_Nil;
};

template<> struct AnyValueTraits<protocol::Grid> {
  static const AnyValue enum_value = AnyValue_Grid;
};

template<> struct AnyValueTraits<protocol::NumGrid> {
  static const AnyValue enum_value = AnyValue_NumGrid;
};

template<> struct AnyValueTraits<protocol::Range> {
  static const AnyValue enum_value = AnyValue_Range;
};

template<> struct AnyValueTraits<protocol::RefCache> {
  static const AnyValue enum_value = AnyValue_RefCache;
};

bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type);
bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Command : uint8_t {
  Command_NONE = 0,
  Command_SetCommand = 1,
  Command_FormatCommand = 2,
  Command_MIN = Command_NONE,
  Command_MAX = Command_FormatCommand
};

inline const Command (&EnumValuesCommand())[3] {
  static const Command values[] = {
    Command_NONE,
    Command_SetCommand,
    Command_FormatCommand
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[4] = {
    "NONE",
    "SetCommand",
    "FormatCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NONE, Command_FormatCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<protocol::SetCommand> {
  static const Command enum_value = Command_SetCommand;
};

template<> struct CommandTraits<protocol::FormatCommand> {
  static const Command enum_value = Command_FormatCommand;
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t row_first_;
  int32_t row_last_;
  int32_t col_first_;
  int32_t col_last_;

 public:
  Rect()
      : row_first_(0),
        row_last_(0),
        col_first_(0),
        col_last_(0) {
  }
  Rect(int32_t _row_first, int32_t _row_last, int32_t _col_first, int32_t _col_last)
      : row_first_(::flatbuffers::EndianScalar(_row_first)),
        row_last_(::flatbuffers::EndianScalar(_row_last)),
        col_first_(::flatbuffers::EndianScalar(_col_first)),
        col_last_(::flatbuffers::EndianScalar(_col_last)) {
  }
  int32_t row_first() const {
    return ::flatbuffers::EndianScalar(row_first_);
  }
  int32_t row_last() const {
    return ::flatbuffers::EndianScalar(row_last_);
  }
  int32_t col_first() const {
    return ::flatbuffers::EndianScalar(col_first_);
  }
  int32_t col_last() const {
    return ::flatbuffers::EndianScalar(col_last_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(Bool::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Num FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  double val() const {
    return GetField<double>(VT_VAL, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct NumBuilder {
  typedef Num Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(double val) {
    fbb_.AddElement<double>(Num::VT_VAL, val, 0.0);
  }
  explicit NumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Num> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Num>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Num> CreateNum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double val = 0.0) {
  NumBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(Int::VT_VAL, val, 0);
  }
  explicit IntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int> CreateInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Str FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  const ::flatbuffers::String *val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct StrBuilder {
  typedef Str Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(::flatbuffers::Offset<::flatbuffers::String> val) {
    fbb_.AddOffset(Str::VT_VAL, val);
  }
  explicit StrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Str> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Str>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Str> CreateStr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> val = 0) {
  StrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Str> CreateStrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *val = nullptr) {
  auto val__ = val ? _fbb.CreateString(val) : 0;
  return protocol::CreateStr(
      _fbb,
      val__);
}

struct Err FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  protocol::XlError val() const {
    return static_cast<protocol::XlError>(GetField<int16_t>(VT_VAL, 2000));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VAL, 2) &&
           verifier.EndTable();
  }
};

struct ErrBuilder {
  typedef Err Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(protocol::XlError val) {
    fbb_.AddElement<int16_t>(Err::VT_VAL, static_cast<int16_t>(val), 2000);
  }
  explicit ErrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Err> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Err>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Err> CreateErr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::XlError val = protocol::XlError_Null) {
  ErrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct AsyncHandle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncHandleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  uint64_t val() const {
    return GetField<uint64_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct AsyncHandleBuilder {
  typedef AsyncHandle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(uint64_t val) {
    fbb_.AddElement<uint64_t>(AsyncHandle::VT_VAL, val, 0);
  }
  explicit AsyncHandleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncHandle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncHandle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncHandle> CreateAsyncHandle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t val = 0) {
  AsyncHandleBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Nil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NilBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NilBuilder {
  typedef Nil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NilBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Nil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Nil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Nil> CreateNil(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RefCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RefCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct RefCacheBuilder {
  typedef RefCache Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(RefCache::VT_KEY, key);
  }
  explicit RefCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RefCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RefCache>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RefCache> CreateRefCache(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0) {
  RefCacheBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RefCache> CreateRefCacheDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateRefCache(
      _fbb,
      key__);
}

struct Range FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHEET_NAME = 4,
    VT_REFS = 6
  };
  const ::flatbuffers::String *sheet_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHEET_NAME);
  }
  const ::flatbuffers::Vector<const protocol::Rect *> *refs() const {
    return GetPointer<const ::flatbuffers::Vector<const protocol::Rect *> *>(VT_REFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHEET_NAME) &&
           verifier.VerifyString(sheet_name()) &&
           VerifyOffset(verifier, VT_REFS) &&
           verifier.VerifyVector(refs()) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  typedef Range Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sheet_name(::flatbuffers::Offset<::flatbuffers::String> sheet_name) {
    fbb_.AddOffset(Range::VT_SHEET_NAME, sheet_name);
  }
  void add_refs(::flatbuffers::Offset<::flatbuffers::Vector<const protocol::Rect *>> refs) {
    fbb_.AddOffset(Range::VT_REFS, refs);
  }
  explicit RangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Range> CreateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sheet_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const protocol::Rect *>> refs = 0) {
  RangeBuilder builder_(_fbb);
  builder_.add_refs(refs);
  builder_.add_sheet_name(sheet_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Range> CreateRangeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sheet_name = nullptr,
    const std::vector<protocol::Rect> *refs = nullptr) {
  auto sheet_name__ = sheet_name ? _fbb.CreateString(sheet_name) : 0;
  auto refs__ = refs ? _fbb.CreateVectorOfStructs<protocol::Rect>(*refs) : 0;
  return protocol::CreateRange(
      _fbb,
      sheet_name__,
      refs__);
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  protocol::ScalarValue val_type() const {
    return static_cast<protocol::ScalarValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const protocol::Bool *val_as_Bool() const {
    return val_type() == protocol::ScalarValue_Bool ? static_cast<const protocol::Bool *>(val()) : nullptr;
  }
  const protocol::Num *val_as_Num() const {
    return val_type() == protocol::ScalarValue_Num ? static_cast<const protocol::Num *>(val()) : nullptr;
  }
  const protocol::Int *val_as_Int() const {
    return val_type() == protocol::ScalarValue_Int ? static_cast<const protocol::Int *>(val()) : nullptr;
  }
  const protocol::Str *val_as_Str() const {
    return val_type() == protocol::ScalarValue_Str ? static_cast<const protocol::Str *>(val()) : nullptr;
  }
  const protocol::Err *val_as_Err() const {
    return val_type() == protocol::ScalarValue_Err ? static_cast<const protocol::Err *>(val()) : nullptr;
  }
  const protocol::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == protocol::ScalarValue_AsyncHandle ? static_cast<const protocol::AsyncHandle *>(val()) : nullptr;
  }
  const protocol::Nil *val_as_Nil() const {
    return val_type() == protocol::ScalarValue_Nil ? static_cast<const protocol::Nil *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyScalarValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::Bool *Scalar::val_as<protocol::Bool>() const {
  return val_as_Bool();
}

template<> inline const protocol::Num *Scalar::val_as<protocol::Num>() const {
  return val_as_Num();
}

template<> inline const protocol::Int *Scalar::val_as<protocol::Int>() const {
  return val_as_Int();
}

template<> inline const protocol::Str *Scalar::val_as<protocol::Str>() const {
  return val_as_Str();
}

template<> inline const protocol::Err *Scalar::val_as<protocol::Err>() const {
  return val_as_Err();
}

template<> inline const protocol::AsyncHandle *Scalar::val_as<protocol::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const protocol::Nil *Scalar::val_as<protocol::Nil>() const {
  return val_as_Nil();
}

struct ScalarBuilder {
  typedef Scalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(protocol::ScalarValue val_type) {
    fbb_.AddElement<uint8_t>(Scalar::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Scalar::VT_VAL, val);
  }
  explicit ScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scalar> CreateScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ScalarValue val_type = protocol::ScalarValue_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  ScalarBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Grid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct GridBuilder {
  typedef Grid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(Grid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(Grid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>>> data) {
    fbb_.AddOffset(Grid::VT_DATA, data);
  }
  explicit GridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Grid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Grid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Grid> CreateGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>>> data = 0) {
  GridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Grid> CreateGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<::flatbuffers::Offset<protocol::Scalar>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<protocol::Scalar>>(*data) : 0;
  return protocol::CreateGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct NumGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<double> *data() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NumGridBuilder {
  typedef NumGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(NumGrid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(NumGrid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(NumGrid::VT_DATA, data);
  }
  explicit NumGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumGrid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumGrid> CreateNumGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> data = 0) {
  NumGridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NumGrid> CreateNumGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return protocol::CreateNumGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct Any FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  protocol::AnyValue val_type() const {
    return static_cast<protocol::AnyValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const protocol::Bool *val_as_Bool() const {
    return val_type() == protocol::AnyValue_Bool ? static_cast<const protocol::Bool *>(val()) : nullptr;
  }
  const protocol::Num *val_as_Num() const {
    return val_type() == protocol::AnyValue_Num ? static_cast<const protocol::Num *>(val()) : nullptr;
  }
  const protocol::Int *val_as_Int() const {
    return val_type() == protocol::AnyValue_Int ? static_cast<const protocol::Int *>(val()) : nullptr;
  }
  const protocol::Str *val_as_Str() const {
    return val_type() == protocol::AnyValue_Str ? static_cast<const protocol::Str *>(val()) : nullptr;
  }
  const protocol::Err *val_as_Err() const {
    return val_type() == protocol::AnyValue_Err ? static_cast<const protocol::Err *>(val()) : nullptr;
  }
  const protocol::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == protocol::AnyValue_AsyncHandle ? static_cast<const protocol::AsyncHandle *>(val()) : nullptr;
  }
  const protocol::Nil *val_as_Nil() const {
    return val_type() == protocol::AnyValue_Nil ? static_cast<const protocol::Nil *>(val()) : nullptr;
  }
  const protocol::Grid *val_as_Grid() const {
    return val_type() == protocol::AnyValue_Grid ? static_cast<const protocol::Grid *>(val()) : nullptr;
  }
  const protocol::NumGrid *val_as_NumGrid() const {
    return val_type() == protocol::AnyValue_NumGrid ? static_cast<const protocol::NumGrid *>(val()) : nullptr;
  }
  const protocol::Range *val_as_Range() const {
    return val_type() == protocol::AnyValue_Range ? static_cast<const protocol::Range *>(val()) : nullptr;
  }
  const protocol::RefCache *val_as_RefCache() const {
    return val_type() == protocol::AnyValue_RefCache ? static_cast<const protocol::RefCache *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyAnyValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::Bool *Any::val_as<protocol::Bool>() const {
  return val_as_Bool();
}

template<> inline const protocol::Num *Any::val_as<protocol::Num>() const {
  return val_as_Num();
}

template<> inline const protocol::Int *Any::val_as<protocol::Int>() const {
  return val_as_Int();
}

template<> inline const protocol::Str *Any::val_as<protocol::Str>() const {
  return val_as_Str();
}

template<> inline const protocol::Err *Any::val_as<protocol::Err>() const {
  return val_as_Err();
}

template<> inline const protocol::AsyncHandle *Any::val_as<protocol::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const protocol::Nil *Any::val_as<protocol::Nil>() const {
  return val_as_Nil();
}

template<> inline const protocol::Grid *Any::val_as<protocol::Grid>() const {
  return val_as_Grid();
}

template<> inline const protocol::NumGrid *Any::val_as<protocol::NumGrid>() const {
  return val_as_NumGrid();
}

template<> inline const protocol::Range *Any::val_as<protocol::Range>() const {
  return val_as_Range();
}

template<> inline const protocol::RefCache *Any::val_as<protocol::RefCache>() const {
  return val_as_RefCache();
}

struct AnyBuilder {
  typedef Any Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(protocol::AnyValue val_type) {
    fbb_.AddElement<uint8_t>(Any::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Any::VT_VAL, val);
  }
  explicit AnyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Any> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Any>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Any> CreateAny(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::AnyValue val_type = protocol::AnyValue_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  AnyBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OK = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Ack::VT_ID, id, 0);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Ack::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    bool ok = false) {
  AckBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOTAL_SIZE = 6,
    VT_OFFSET = 8,
    VT_DATA = 10,
    VT_MSG_TYPE = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint32_t total_size() const {
    return GetField<uint32_t>(VT_TOTAL_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint32_t msg_type() const {
    return GetField<uint32_t>(VT_MSG_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_MSG_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Chunk::VT_ID, id, 0);
  }
  void add_total_size(uint32_t total_size) {
    fbb_.AddElement<uint32_t>(Chunk::VT_TOTAL_SIZE, total_size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Chunk::VT_OFFSET, offset, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Chunk::VT_DATA, data);
  }
  void add_msg_type(uint32_t msg_type) {
    fbb_.AddElement<uint32_t>(Chunk::VT_MSG_TYPE, msg_type, 0);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t msg_type = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg_type(msg_type);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_total_size(total_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chunk> CreateChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t msg_type = 0) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return protocol::CreateChunk(
      _fbb,
      id,
      total_size,
      offset,
      data__,
      msg_type);
}

struct SetRefCacheRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRefCacheRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const protocol::Any *val() const {
    return GetPointer<const protocol::Any *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyTable(val()) &&
           verifier.EndTable();
  }
};

struct SetRefCacheRequestBuilder {
  typedef SetRefCacheRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(SetRefCacheRequest::VT_KEY, key);
  }
  void add_val(::flatbuffers::Offset<protocol::Any> val) {
    fbb_.AddOffset(SetRefCacheRequest::VT_VAL, val);
  }
  explicit SetRefCacheRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRefCacheRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRefCacheRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<protocol::Any> val = 0) {
  SetRefCacheRequestBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    ::flatbuffers::Offset<protocol::Any> val = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateSetRefCacheRequest(
      _fbb,
      key__,
      val);
}

struct SetCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_VALUE = 6
  };
  const protocol::Range *target() const {
    return GetPointer<const protocol::Range *>(VT_TARGET);
  }
  const protocol::Any *value() const {
    return GetPointer<const protocol::Any *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct SetCommandBuilder {
  typedef SetCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<protocol::Range> target) {
    fbb_.AddOffset(SetCommand::VT_TARGET, target);
  }
  void add_value(::flatbuffers::Offset<protocol::Any> value) {
    fbb_.AddOffset(SetCommand::VT_VALUE, value);
  }
  explicit SetCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCommand> CreateSetCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    ::flatbuffers::Offset<protocol::Any> value = 0) {
  SetCommandBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_target(target);
  return builder_.Finish();
}

struct FormatCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FormatCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_FORMAT = 6
  };
  const protocol::Range *target() const {
    return GetPointer<const protocol::Range *>(VT_TARGET);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           verifier.EndTable();
  }
};

struct FormatCommandBuilder {
  typedef FormatCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<protocol::Range> target) {
    fbb_.AddOffset(FormatCommand::VT_TARGET, target);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(FormatCommand::VT_FORMAT, format);
  }
  explicit FormatCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FormatCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FormatCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0) {
  FormatCommandBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    const char *format = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  return protocol::CreateFormatCommand(
      _fbb,
      target,
      format__);
}

struct CommandWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD_TYPE = 4,
    VT_CMD = 6
  };
  protocol::Command cmd_type() const {
    return static_cast<protocol::Command>(GetField<uint8_t>(VT_CMD_TYPE, 0));
  }
  const void *cmd() const {
    return GetPointer<const void *>(VT_CMD);
  }
  template<typename T> const T *cmd_as() const;
  const protocol::SetCommand *cmd_as_SetCommand() const {
    return cmd_type() == protocol::Command_SetCommand ? static_cast<const protocol::SetCommand *>(cmd()) : nullptr;
  }
  const protocol::FormatCommand *cmd_as_FormatCommand() const {
    return cmd_type() == protocol::Command_FormatCommand ? static_cast<const protocol::FormatCommand *>(cmd()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CMD_TYPE, 1) &&
           VerifyOffset(verifier, VT_CMD) &&
           VerifyCommand(verifier, cmd(), cmd_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::SetCommand *CommandWrapper::cmd_as<protocol::SetCommand>() const {
  return cmd_as_SetCommand();
}

template<> inline const protocol::FormatCommand *CommandWrapper::cmd_as<protocol::FormatCommand>() const {
  return cmd_as_FormatCommand();
}

struct CommandWrapperBuilder {
  typedef CommandWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cmd_type(protocol::Command cmd_type) {
    fbb_.AddElement<uint8_t>(CommandWrapper::VT_CMD_TYPE, static_cast<uint8_t>(cmd_type), 0);
  }
  void add_cmd(::flatbuffers::Offset<void> cmd) {
    fbb_.AddOffset(CommandWrapper::VT_CMD, cmd);
  }
  explicit CommandWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandWrapper> CreateCommandWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::Command cmd_type = protocol::Command_NONE,
    ::flatbuffers::Offset<void> cmd = 0) {
  CommandWrapperBuilder builder_(_fbb);
  builder_.add_cmd(cmd);
  builder_.add_cmd_type(cmd_type);
  return builder_.Finish();
}

struct CalculationEndedResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalculationEndedResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct CalculationEndedResponseBuilder {
  typedef CalculationEndedResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>>> commands) {
    fbb_.AddOffset(CalculationEndedResponse::VT_COMMANDS, commands);
  }
  explicit CalculationEndedResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalculationEndedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalculationEndedResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>>> commands = 0) {
  CalculationEndedResponseBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<protocol::CommandWrapper>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<protocol::CommandWrapper>>(*commands) : 0;
  return protocol::CreateCalculationEndedResponse(
      _fbb,
      commands__);
}

struct AsyncResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLE = 4,
    VT_RESULT = 6,
    VT_ERROR = 8
  };
  uint64_t handle() const {
    return GetField<uint64_t>(VT_HANDLE, 0);
  }
  const protocol::Any *result() const {
    return GetPointer<const protocol::Any *>(VT_RESULT);
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_HANDLE, 8) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct AsyncResultBuilder {
  typedef AsyncResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_handle(uint64_t handle) {
    fbb_.AddElement<uint64_t>(AsyncResult::VT_HANDLE, handle, 0);
  }
  void add_result(::flatbuffers::Offset<protocol::Any> result) {
    fbb_.AddOffset(AsyncResult::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(AsyncResult::VT_ERROR, error);
  }
  explicit AsyncResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t handle = 0,
    ::flatbuffers::Offset<protocol::Any> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  AsyncResultBuilder builder_(_fbb);
  builder_.add_handle(handle);
  builder_.add_error(error);
  builder_.add_result(result);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t handle = 0,
    ::flatbuffers::Offset<protocol::Any> result = 0,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return protocol::CreateAsyncResult(
      _fbb,
      handle,
      result,
      error__);
}

struct BatchAsyncResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchAsyncResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
};

struct BatchAsyncResponseBuilder {
  typedef BatchAsyncResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>>> results) {
    fbb_.AddOffset(BatchAsyncResponse::VT_RESULTS, results);
  }
  explicit BatchAsyncResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchAsyncResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchAsyncResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>>> results = 0) {
  BatchAsyncResponseBuilder builder_(_fbb);
  builder_.add_results(results);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<protocol::AsyncResult>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<protocol::AsyncResult>>(*results) : 0;
  return protocol::CreateBatchAsyncResponse(
      _fbb,
      results__);
}

inline bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type) {
  switch (type) {
    case ScalarValue_NONE: {
      return true;
    }
    case ScalarValue_Bool: {
      auto ptr = reinterpret_cast<const protocol::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Num: {
      auto ptr = reinterpret_cast<const protocol::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Int: {
      auto ptr = reinterpret_cast<const protocol::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Str: {
      auto ptr = reinterpret_cast<const protocol::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Err: {
      auto ptr = reinterpret_cast<const protocol::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_AsyncHandle: {
      auto ptr = reinterpret_cast<const protocol::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Nil: {
      auto ptr = reinterpret_cast<const protocol::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarValue(
        verifier,  values->Get(i), types->GetEnum<ScalarValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type) {
  switch (type) {
    case AnyValue_NONE: {
      return true;
    }
    case AnyValue_Bool: {
      auto ptr = reinterpret_cast<const protocol::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Num: {
      auto ptr = reinterpret_cast<const protocol::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Int: {
      auto ptr = reinterpret_cast<const protocol::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Str: {
      auto ptr = reinterpret_cast<const protocol::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Err: {
      auto ptr = reinterpret_cast<const protocol::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_AsyncHandle: {
      auto ptr = reinterpret_cast<const protocol::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Nil: {
      auto ptr = reinterpret_cast<const protocol::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Grid: {
      auto ptr = reinterpret_cast<const protocol::Grid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_NumGrid: {
      auto ptr = reinterpret_cast<const protocol::NumGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Range: {
      auto ptr = reinterpret_cast<const protocol::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_RefCache: {
      auto ptr = reinterpret_cast<const protocol::RefCache *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyValue(
        verifier,  values->Get(i), types->GetEnum<AnyValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_SetCommand: {
      auto ptr = reinterpret_cast<const protocol::SetCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_FormatCommand: {
      auto ptr = reinterpret_cast<const protocol::FormatCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace protocol

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
