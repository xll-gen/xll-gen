// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace protocol {

struct Bool;
struct BoolBuilder;

struct Num;
struct NumBuilder;

struct Int;
struct IntBuilder;

struct Str;
struct StrBuilder;

struct Err;
struct ErrBuilder;

struct AsyncHandle;
struct AsyncHandleBuilder;

struct Nil;
struct NilBuilder;

struct RefCache;
struct RefCacheBuilder;

struct Rect;

struct Range;
struct RangeBuilder;

struct Scalar;
struct ScalarBuilder;

struct Grid;
struct GridBuilder;

struct NumGrid;
struct NumGridBuilder;

struct Any;
struct AnyBuilder;

struct Ack;
struct AckBuilder;

struct Chunk;
struct ChunkBuilder;

struct SetRefCacheRequest;
struct SetRefCacheRequestBuilder;

struct SetCommand;
struct SetCommandBuilder;

struct FormatCommand;
struct FormatCommandBuilder;

struct CommandWrapper;
struct CommandWrapperBuilder;

struct CalculationEndedResponse;
struct CalculationEndedResponseBuilder;

struct AsyncResult;
struct AsyncResultBuilder;

struct BatchAsyncResponse;
struct BatchAsyncResponseBuilder;

enum class XlError : int16_t {
  Null = 2000,
  Div0 = 2007,
  Value = 2015,
  Ref = 2023,
  Name = 2029,
  Num = 2036,
  NA = 2042,
  GettingData = 2043,
  Spill = 2045,
  Connect = 2046,
  Blocked = 2047,
  Unknown = 2048,
  Field = 2049,
  Calc = 2050,
  MIN = Null,
  MAX = Calc
};

inline const XlError (&EnumValuesXlError())[14] {
  static const XlError values[] = {
    XlError::Null,
    XlError::Div0,
    XlError::Value,
    XlError::Ref,
    XlError::Name,
    XlError::Num,
    XlError::NA,
    XlError::GettingData,
    XlError::Spill,
    XlError::Connect,
    XlError::Blocked,
    XlError::Unknown,
    XlError::Field,
    XlError::Calc
  };
  return values;
}

inline const char * const *EnumNamesXlError() {
  static const char * const names[52] = {
    "Null",
    "",
    "",
    "",
    "",
    "",
    "",
    "Div0",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Value",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Ref",
    "",
    "",
    "",
    "",
    "",
    "Name",
    "",
    "",
    "",
    "",
    "",
    "",
    "Num",
    "",
    "",
    "",
    "",
    "",
    "NA",
    "GettingData",
    "",
    "Spill",
    "Connect",
    "Blocked",
    "Unknown",
    "Field",
    "Calc",
    nullptr
  };
  return names;
}

inline const char *EnumNameXlError(XlError e) {
  if (::flatbuffers::IsOutRange(e, XlError::Null, XlError::Calc)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(XlError::Null);
  return EnumNamesXlError()[index];
}

enum class ScalarValue : uint8_t {
  NONE = 0,
  Bool = 1,
  Num = 2,
  Int = 3,
  Str = 4,
  Err = 5,
  AsyncHandle = 6,
  Nil = 7,
  MIN = NONE,
  MAX = Nil
};

inline const ScalarValue (&EnumValuesScalarValue())[8] {
  static const ScalarValue values[] = {
    ScalarValue::NONE,
    ScalarValue::Bool,
    ScalarValue::Num,
    ScalarValue::Int,
    ScalarValue::Str,
    ScalarValue::Err,
    ScalarValue::AsyncHandle,
    ScalarValue::Nil
  };
  return values;
}

inline const char * const *EnumNamesScalarValue() {
  static const char * const names[9] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarValue(ScalarValue e) {
  if (::flatbuffers::IsOutRange(e, ScalarValue::NONE, ScalarValue::Nil)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarValue()[index];
}

template<typename T> struct ScalarValueTraits {
  static const ScalarValue enum_value = ScalarValue::NONE;
};

template<> struct ScalarValueTraits<protocol::Bool> {
  static const ScalarValue enum_value = ScalarValue::Bool;
};

template<> struct ScalarValueTraits<protocol::Num> {
  static const ScalarValue enum_value = ScalarValue::Num;
};

template<> struct ScalarValueTraits<protocol::Int> {
  static const ScalarValue enum_value = ScalarValue::Int;
};

template<> struct ScalarValueTraits<protocol::Str> {
  static const ScalarValue enum_value = ScalarValue::Str;
};

template<> struct ScalarValueTraits<protocol::Err> {
  static const ScalarValue enum_value = ScalarValue::Err;
};

template<> struct ScalarValueTraits<protocol::AsyncHandle> {
  static const ScalarValue enum_value = ScalarValue::AsyncHandle;
};

template<> struct ScalarValueTraits<protocol::Nil> {
  static const ScalarValue enum_value = ScalarValue::Nil;
};

bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type);
bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ScalarValue> *types);

enum class AnyValue : uint8_t {
  NONE = 0,
  Bool = 1,
  Num = 2,
  Int = 3,
  Str = 4,
  Err = 5,
  AsyncHandle = 6,
  Nil = 7,
  Grid = 8,
  NumGrid = 9,
  Range = 10,
  RefCache = 11,
  MIN = NONE,
  MAX = RefCache
};

inline const AnyValue (&EnumValuesAnyValue())[12] {
  static const AnyValue values[] = {
    AnyValue::NONE,
    AnyValue::Bool,
    AnyValue::Num,
    AnyValue::Int,
    AnyValue::Str,
    AnyValue::Err,
    AnyValue::AsyncHandle,
    AnyValue::Nil,
    AnyValue::Grid,
    AnyValue::NumGrid,
    AnyValue::Range,
    AnyValue::RefCache
  };
  return values;
}

inline const char * const *EnumNamesAnyValue() {
  static const char * const names[13] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    "Grid",
    "NumGrid",
    "Range",
    "RefCache",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyValue(AnyValue e) {
  if (::flatbuffers::IsOutRange(e, AnyValue::NONE, AnyValue::RefCache)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyValue()[index];
}

template<typename T> struct AnyValueTraits {
  static const AnyValue enum_value = AnyValue::NONE;
};

template<> struct AnyValueTraits<protocol::Bool> {
  static const AnyValue enum_value = AnyValue::Bool;
};

template<> struct AnyValueTraits<protocol::Num> {
  static const AnyValue enum_value = AnyValue::Num;
};

template<> struct AnyValueTraits<protocol::Int> {
  static const AnyValue enum_value = AnyValue::Int;
};

template<> struct AnyValueTraits<protocol::Str> {
  static const AnyValue enum_value = AnyValue::Str;
};

template<> struct AnyValueTraits<protocol::Err> {
  static const AnyValue enum_value = AnyValue::Err;
};

template<> struct AnyValueTraits<protocol::AsyncHandle> {
  static const AnyValue enum_value = AnyValue::AsyncHandle;
};

template<> struct AnyValueTraits<protocol::Nil> {
  static const AnyValue enum_value = AnyValue::Nil;
};

template<> struct AnyValueTraits<protocol::Grid> {
  static const AnyValue enum_value = AnyValue::Grid;
};

template<> struct AnyValueTraits<protocol::NumGrid> {
  static const AnyValue enum_value = AnyValue::NumGrid;
};

template<> struct AnyValueTraits<protocol::Range> {
  static const AnyValue enum_value = AnyValue::Range;
};

template<> struct AnyValueTraits<protocol::RefCache> {
  static const AnyValue enum_value = AnyValue::RefCache;
};

bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type);
bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnyValue> *types);

enum class Command : uint8_t {
  NONE = 0,
  SetCommand = 1,
  FormatCommand = 2,
  MIN = NONE,
  MAX = FormatCommand
};

inline const Command (&EnumValuesCommand())[3] {
  static const Command values[] = {
    Command::NONE,
    Command::SetCommand,
    Command::FormatCommand
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[4] = {
    "NONE",
    "SetCommand",
    "FormatCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command::NONE, Command::FormatCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command::NONE;
};

template<> struct CommandTraits<protocol::SetCommand> {
  static const Command enum_value = Command::SetCommand;
};

template<> struct CommandTraits<protocol::FormatCommand> {
  static const Command enum_value = Command::FormatCommand;
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Command> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t row_first_;
  int32_t row_last_;
  int32_t col_first_;
  int32_t col_last_;

 public:
  Rect()
      : row_first_(0),
        row_last_(0),
        col_first_(0),
        col_last_(0) {
  }
  Rect(int32_t _row_first, int32_t _row_last, int32_t _col_first, int32_t _col_last)
      : row_first_(::flatbuffers::EndianScalar(_row_first)),
        row_last_(::flatbuffers::EndianScalar(_row_last)),
        col_first_(::flatbuffers::EndianScalar(_col_first)),
        col_last_(::flatbuffers::EndianScalar(_col_last)) {
  }
  int32_t row_first() const {
    return ::flatbuffers::EndianScalar(row_first_);
  }
  int32_t row_last() const {
    return ::flatbuffers::EndianScalar(row_last_);
  }
  int32_t col_first() const {
    return ::flatbuffers::EndianScalar(col_first_);
  }
  int32_t col_last() const {
    return ::flatbuffers::EndianScalar(col_last_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(Bool::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Num FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  double val() const {
    return GetField<double>(VT_VAL, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct NumBuilder {
  typedef Num Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(double val) {
    fbb_.AddElement<double>(Num::VT_VAL, val, 0.0);
  }
  explicit NumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Num> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Num>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Num> CreateNum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double val = 0.0) {
  NumBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(Int::VT_VAL, val, 0);
  }
  explicit IntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int> CreateInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Str FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  const ::flatbuffers::String *val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct StrBuilder {
  typedef Str Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(::flatbuffers::Offset<::flatbuffers::String> val) {
    fbb_.AddOffset(Str::VT_VAL, val);
  }
  explicit StrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Str> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Str>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Str> CreateStr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> val = 0) {
  StrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Str> CreateStrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *val = nullptr) {
  auto val__ = val ? _fbb.CreateString(val) : 0;
  return protocol::CreateStr(
      _fbb,
      val__);
}

struct Err FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  protocol::XlError val() const {
    return static_cast<protocol::XlError>(GetField<int16_t>(VT_VAL, 2000));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VAL, 2) &&
           verifier.EndTable();
  }
};

struct ErrBuilder {
  typedef Err Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(protocol::XlError val) {
    fbb_.AddElement<int16_t>(Err::VT_VAL, static_cast<int16_t>(val), 2000);
  }
  explicit ErrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Err> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Err>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Err> CreateErr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::XlError val = protocol::XlError::Null) {
  ErrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct AsyncHandle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncHandleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  const ::flatbuffers::Vector<uint8_t> *val() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyVector(val()) &&
           verifier.EndTable();
  }
};

struct AsyncHandleBuilder {
  typedef AsyncHandle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> val) {
    fbb_.AddOffset(AsyncHandle::VT_VAL, val);
  }
  explicit AsyncHandleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncHandle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncHandle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncHandle> CreateAsyncHandle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> val = 0) {
  AsyncHandleBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AsyncHandle> CreateAsyncHandleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *val = nullptr) {
  auto val__ = val ? _fbb.CreateVector<uint8_t>(*val) : 0;
  return protocol::CreateAsyncHandle(
      _fbb,
      val__);
}

struct Nil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NilBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NilBuilder {
  typedef Nil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NilBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Nil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Nil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Nil> CreateNil(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RefCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RefCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct RefCacheBuilder {
  typedef RefCache Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(RefCache::VT_KEY, key);
  }
  explicit RefCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RefCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RefCache>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RefCache> CreateRefCache(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0) {
  RefCacheBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RefCache> CreateRefCacheDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateRefCache(
      _fbb,
      key__);
}

struct Range FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHEET_NAME = 4,
    VT_REFS = 6,
    VT_FORMAT = 8
  };
  const ::flatbuffers::String *sheet_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHEET_NAME);
  }
  const ::flatbuffers::Vector<const protocol::Rect *> *refs() const {
    return GetPointer<const ::flatbuffers::Vector<const protocol::Rect *> *>(VT_REFS);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHEET_NAME) &&
           verifier.VerifyString(sheet_name()) &&
           VerifyOffset(verifier, VT_REFS) &&
           verifier.VerifyVector(refs()) &&
           VerifyOffset(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  typedef Range Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sheet_name(::flatbuffers::Offset<::flatbuffers::String> sheet_name) {
    fbb_.AddOffset(Range::VT_SHEET_NAME, sheet_name);
  }
  void add_refs(::flatbuffers::Offset<::flatbuffers::Vector<const protocol::Rect *>> refs) {
    fbb_.AddOffset(Range::VT_REFS, refs);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(Range::VT_FORMAT, format);
  }
  explicit RangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Range> CreateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sheet_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const protocol::Rect *>> refs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0) {
  RangeBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_refs(refs);
  builder_.add_sheet_name(sheet_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Range> CreateRangeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sheet_name = nullptr,
    const std::vector<protocol::Rect> *refs = nullptr,
    const char *format = nullptr) {
  auto sheet_name__ = sheet_name ? _fbb.CreateString(sheet_name) : 0;
  auto refs__ = refs ? _fbb.CreateVectorOfStructs<protocol::Rect>(*refs) : 0;
  auto format__ = format ? _fbb.CreateString(format) : 0;
  return protocol::CreateRange(
      _fbb,
      sheet_name__,
      refs__,
      format__);
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  protocol::ScalarValue val_type() const {
    return static_cast<protocol::ScalarValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const protocol::Bool *val_as_Bool() const {
    return val_type() == protocol::ScalarValue::Bool ? static_cast<const protocol::Bool *>(val()) : nullptr;
  }
  const protocol::Num *val_as_Num() const {
    return val_type() == protocol::ScalarValue::Num ? static_cast<const protocol::Num *>(val()) : nullptr;
  }
  const protocol::Int *val_as_Int() const {
    return val_type() == protocol::ScalarValue::Int ? static_cast<const protocol::Int *>(val()) : nullptr;
  }
  const protocol::Str *val_as_Str() const {
    return val_type() == protocol::ScalarValue::Str ? static_cast<const protocol::Str *>(val()) : nullptr;
  }
  const protocol::Err *val_as_Err() const {
    return val_type() == protocol::ScalarValue::Err ? static_cast<const protocol::Err *>(val()) : nullptr;
  }
  const protocol::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == protocol::ScalarValue::AsyncHandle ? static_cast<const protocol::AsyncHandle *>(val()) : nullptr;
  }
  const protocol::Nil *val_as_Nil() const {
    return val_type() == protocol::ScalarValue::Nil ? static_cast<const protocol::Nil *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyScalarValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::Bool *Scalar::val_as<protocol::Bool>() const {
  return val_as_Bool();
}

template<> inline const protocol::Num *Scalar::val_as<protocol::Num>() const {
  return val_as_Num();
}

template<> inline const protocol::Int *Scalar::val_as<protocol::Int>() const {
  return val_as_Int();
}

template<> inline const protocol::Str *Scalar::val_as<protocol::Str>() const {
  return val_as_Str();
}

template<> inline const protocol::Err *Scalar::val_as<protocol::Err>() const {
  return val_as_Err();
}

template<> inline const protocol::AsyncHandle *Scalar::val_as<protocol::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const protocol::Nil *Scalar::val_as<protocol::Nil>() const {
  return val_as_Nil();
}

struct ScalarBuilder {
  typedef Scalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(protocol::ScalarValue val_type) {
    fbb_.AddElement<uint8_t>(Scalar::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Scalar::VT_VAL, val);
  }
  explicit ScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scalar> CreateScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ScalarValue val_type = protocol::ScalarValue::NONE,
    ::flatbuffers::Offset<void> val = 0) {
  ScalarBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Grid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct GridBuilder {
  typedef Grid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(Grid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(Grid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>>> data) {
    fbb_.AddOffset(Grid::VT_DATA, data);
  }
  explicit GridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Grid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Grid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Grid> CreateGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::Scalar>>> data = 0) {
  GridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Grid> CreateGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<::flatbuffers::Offset<protocol::Scalar>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<protocol::Scalar>>(*data) : 0;
  return protocol::CreateGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct NumGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<double> *data() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NumGridBuilder {
  typedef NumGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(NumGrid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(NumGrid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(NumGrid::VT_DATA, data);
  }
  explicit NumGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumGrid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumGrid> CreateNumGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> data = 0) {
  NumGridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NumGrid> CreateNumGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return protocol::CreateNumGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct Any FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  protocol::AnyValue val_type() const {
    return static_cast<protocol::AnyValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const protocol::Bool *val_as_Bool() const {
    return val_type() == protocol::AnyValue::Bool ? static_cast<const protocol::Bool *>(val()) : nullptr;
  }
  const protocol::Num *val_as_Num() const {
    return val_type() == protocol::AnyValue::Num ? static_cast<const protocol::Num *>(val()) : nullptr;
  }
  const protocol::Int *val_as_Int() const {
    return val_type() == protocol::AnyValue::Int ? static_cast<const protocol::Int *>(val()) : nullptr;
  }
  const protocol::Str *val_as_Str() const {
    return val_type() == protocol::AnyValue::Str ? static_cast<const protocol::Str *>(val()) : nullptr;
  }
  const protocol::Err *val_as_Err() const {
    return val_type() == protocol::AnyValue::Err ? static_cast<const protocol::Err *>(val()) : nullptr;
  }
  const protocol::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == protocol::AnyValue::AsyncHandle ? static_cast<const protocol::AsyncHandle *>(val()) : nullptr;
  }
  const protocol::Nil *val_as_Nil() const {
    return val_type() == protocol::AnyValue::Nil ? static_cast<const protocol::Nil *>(val()) : nullptr;
  }
  const protocol::Grid *val_as_Grid() const {
    return val_type() == protocol::AnyValue::Grid ? static_cast<const protocol::Grid *>(val()) : nullptr;
  }
  const protocol::NumGrid *val_as_NumGrid() const {
    return val_type() == protocol::AnyValue::NumGrid ? static_cast<const protocol::NumGrid *>(val()) : nullptr;
  }
  const protocol::Range *val_as_Range() const {
    return val_type() == protocol::AnyValue::Range ? static_cast<const protocol::Range *>(val()) : nullptr;
  }
  const protocol::RefCache *val_as_RefCache() const {
    return val_type() == protocol::AnyValue::RefCache ? static_cast<const protocol::RefCache *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyAnyValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::Bool *Any::val_as<protocol::Bool>() const {
  return val_as_Bool();
}

template<> inline const protocol::Num *Any::val_as<protocol::Num>() const {
  return val_as_Num();
}

template<> inline const protocol::Int *Any::val_as<protocol::Int>() const {
  return val_as_Int();
}

template<> inline const protocol::Str *Any::val_as<protocol::Str>() const {
  return val_as_Str();
}

template<> inline const protocol::Err *Any::val_as<protocol::Err>() const {
  return val_as_Err();
}

template<> inline const protocol::AsyncHandle *Any::val_as<protocol::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const protocol::Nil *Any::val_as<protocol::Nil>() const {
  return val_as_Nil();
}

template<> inline const protocol::Grid *Any::val_as<protocol::Grid>() const {
  return val_as_Grid();
}

template<> inline const protocol::NumGrid *Any::val_as<protocol::NumGrid>() const {
  return val_as_NumGrid();
}

template<> inline const protocol::Range *Any::val_as<protocol::Range>() const {
  return val_as_Range();
}

template<> inline const protocol::RefCache *Any::val_as<protocol::RefCache>() const {
  return val_as_RefCache();
}

struct AnyBuilder {
  typedef Any Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(protocol::AnyValue val_type) {
    fbb_.AddElement<uint8_t>(Any::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Any::VT_VAL, val);
  }
  explicit AnyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Any> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Any>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Any> CreateAny(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::AnyValue val_type = protocol::AnyValue::NONE,
    ::flatbuffers::Offset<void> val = 0) {
  AnyBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OK = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Ack::VT_ID, id, 0);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Ack::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    bool ok = false) {
  AckBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOTAL_SIZE = 6,
    VT_OFFSET = 8,
    VT_DATA = 10,
    VT_MSG_TYPE = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint32_t total_size() const {
    return GetField<uint32_t>(VT_TOTAL_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint32_t msg_type() const {
    return GetField<uint32_t>(VT_MSG_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_MSG_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Chunk::VT_ID, id, 0);
  }
  void add_total_size(uint32_t total_size) {
    fbb_.AddElement<uint32_t>(Chunk::VT_TOTAL_SIZE, total_size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Chunk::VT_OFFSET, offset, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Chunk::VT_DATA, data);
  }
  void add_msg_type(uint32_t msg_type) {
    fbb_.AddElement<uint32_t>(Chunk::VT_MSG_TYPE, msg_type, 0);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t msg_type = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg_type(msg_type);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_total_size(total_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chunk> CreateChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t msg_type = 0) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return protocol::CreateChunk(
      _fbb,
      id,
      total_size,
      offset,
      data__,
      msg_type);
}

struct SetRefCacheRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRefCacheRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const protocol::Any *val() const {
    return GetPointer<const protocol::Any *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyTable(val()) &&
           verifier.EndTable();
  }
};

struct SetRefCacheRequestBuilder {
  typedef SetRefCacheRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(SetRefCacheRequest::VT_KEY, key);
  }
  void add_val(::flatbuffers::Offset<protocol::Any> val) {
    fbb_.AddOffset(SetRefCacheRequest::VT_VAL, val);
  }
  explicit SetRefCacheRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRefCacheRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRefCacheRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<protocol::Any> val = 0) {
  SetRefCacheRequestBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    ::flatbuffers::Offset<protocol::Any> val = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return protocol::CreateSetRefCacheRequest(
      _fbb,
      key__,
      val);
}

struct SetCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_VALUE = 6
  };
  const protocol::Range *target() const {
    return GetPointer<const protocol::Range *>(VT_TARGET);
  }
  const protocol::Any *value() const {
    return GetPointer<const protocol::Any *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct SetCommandBuilder {
  typedef SetCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<protocol::Range> target) {
    fbb_.AddOffset(SetCommand::VT_TARGET, target);
  }
  void add_value(::flatbuffers::Offset<protocol::Any> value) {
    fbb_.AddOffset(SetCommand::VT_VALUE, value);
  }
  explicit SetCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCommand> CreateSetCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    ::flatbuffers::Offset<protocol::Any> value = 0) {
  SetCommandBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_target(target);
  return builder_.Finish();
}

struct FormatCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FormatCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_FORMAT = 6
  };
  const protocol::Range *target() const {
    return GetPointer<const protocol::Range *>(VT_TARGET);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           verifier.EndTable();
  }
};

struct FormatCommandBuilder {
  typedef FormatCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<protocol::Range> target) {
    fbb_.AddOffset(FormatCommand::VT_TARGET, target);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(FormatCommand::VT_FORMAT, format);
  }
  explicit FormatCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FormatCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FormatCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0) {
  FormatCommandBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<protocol::Range> target = 0,
    const char *format = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  return protocol::CreateFormatCommand(
      _fbb,
      target,
      format__);
}

struct CommandWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD_TYPE = 4,
    VT_CMD = 6
  };
  protocol::Command cmd_type() const {
    return static_cast<protocol::Command>(GetField<uint8_t>(VT_CMD_TYPE, 0));
  }
  const void *cmd() const {
    return GetPointer<const void *>(VT_CMD);
  }
  template<typename T> const T *cmd_as() const;
  const protocol::SetCommand *cmd_as_SetCommand() const {
    return cmd_type() == protocol::Command::SetCommand ? static_cast<const protocol::SetCommand *>(cmd()) : nullptr;
  }
  const protocol::FormatCommand *cmd_as_FormatCommand() const {
    return cmd_type() == protocol::Command::FormatCommand ? static_cast<const protocol::FormatCommand *>(cmd()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CMD_TYPE, 1) &&
           VerifyOffset(verifier, VT_CMD) &&
           VerifyCommand(verifier, cmd(), cmd_type()) &&
           verifier.EndTable();
  }
};

template<> inline const protocol::SetCommand *CommandWrapper::cmd_as<protocol::SetCommand>() const {
  return cmd_as_SetCommand();
}

template<> inline const protocol::FormatCommand *CommandWrapper::cmd_as<protocol::FormatCommand>() const {
  return cmd_as_FormatCommand();
}

struct CommandWrapperBuilder {
  typedef CommandWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cmd_type(protocol::Command cmd_type) {
    fbb_.AddElement<uint8_t>(CommandWrapper::VT_CMD_TYPE, static_cast<uint8_t>(cmd_type), 0);
  }
  void add_cmd(::flatbuffers::Offset<void> cmd) {
    fbb_.AddOffset(CommandWrapper::VT_CMD, cmd);
  }
  explicit CommandWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandWrapper> CreateCommandWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    protocol::Command cmd_type = protocol::Command::NONE,
    ::flatbuffers::Offset<void> cmd = 0) {
  CommandWrapperBuilder builder_(_fbb);
  builder_.add_cmd(cmd);
  builder_.add_cmd_type(cmd_type);
  return builder_.Finish();
}

struct CalculationEndedResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalculationEndedResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct CalculationEndedResponseBuilder {
  typedef CalculationEndedResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>>> commands) {
    fbb_.AddOffset(CalculationEndedResponse::VT_COMMANDS, commands);
  }
  explicit CalculationEndedResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalculationEndedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalculationEndedResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::CommandWrapper>>> commands = 0) {
  CalculationEndedResponseBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<protocol::CommandWrapper>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<protocol::CommandWrapper>>(*commands) : 0;
  return protocol::CreateCalculationEndedResponse(
      _fbb,
      commands__);
}

struct AsyncResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLE = 4,
    VT_RESULT = 6,
    VT_ERROR = 8
  };
  const ::flatbuffers::Vector<uint8_t> *handle() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_HANDLE);
  }
  const protocol::Any *result() const {
    return GetPointer<const protocol::Any *>(VT_RESULT);
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HANDLE) &&
           verifier.VerifyVector(handle()) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct AsyncResultBuilder {
  typedef AsyncResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_handle(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> handle) {
    fbb_.AddOffset(AsyncResult::VT_HANDLE, handle);
  }
  void add_result(::flatbuffers::Offset<protocol::Any> result) {
    fbb_.AddOffset(AsyncResult::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(AsyncResult::VT_ERROR, error);
  }
  explicit AsyncResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> handle = 0,
    ::flatbuffers::Offset<protocol::Any> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  AsyncResultBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_handle(handle);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *handle = nullptr,
    ::flatbuffers::Offset<protocol::Any> result = 0,
    const char *error = nullptr) {
  auto handle__ = handle ? _fbb.CreateVector<uint8_t>(*handle) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return protocol::CreateAsyncResult(
      _fbb,
      handle__,
      result,
      error__);
}

struct BatchAsyncResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchAsyncResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
};

struct BatchAsyncResponseBuilder {
  typedef BatchAsyncResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>>> results) {
    fbb_.AddOffset(BatchAsyncResponse::VT_RESULTS, results);
  }
  explicit BatchAsyncResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchAsyncResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchAsyncResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<protocol::AsyncResult>>> results = 0) {
  BatchAsyncResponseBuilder builder_(_fbb);
  builder_.add_results(results);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<protocol::AsyncResult>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<protocol::AsyncResult>>(*results) : 0;
  return protocol::CreateBatchAsyncResponse(
      _fbb,
      results__);
}

inline bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type) {
  switch (type) {
    case ScalarValue::NONE: {
      return true;
    }
    case ScalarValue::Bool: {
      auto ptr = reinterpret_cast<const protocol::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::Num: {
      auto ptr = reinterpret_cast<const protocol::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::Int: {
      auto ptr = reinterpret_cast<const protocol::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::Str: {
      auto ptr = reinterpret_cast<const protocol::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::Err: {
      auto ptr = reinterpret_cast<const protocol::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::AsyncHandle: {
      auto ptr = reinterpret_cast<const protocol::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue::Nil: {
      auto ptr = reinterpret_cast<const protocol::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ScalarValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarValue(
        verifier,  values->Get(i), types->GetEnum<ScalarValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type) {
  switch (type) {
    case AnyValue::NONE: {
      return true;
    }
    case AnyValue::Bool: {
      auto ptr = reinterpret_cast<const protocol::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Num: {
      auto ptr = reinterpret_cast<const protocol::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Int: {
      auto ptr = reinterpret_cast<const protocol::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Str: {
      auto ptr = reinterpret_cast<const protocol::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Err: {
      auto ptr = reinterpret_cast<const protocol::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::AsyncHandle: {
      auto ptr = reinterpret_cast<const protocol::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Nil: {
      auto ptr = reinterpret_cast<const protocol::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Grid: {
      auto ptr = reinterpret_cast<const protocol::Grid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::NumGrid: {
      auto ptr = reinterpret_cast<const protocol::NumGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::Range: {
      auto ptr = reinterpret_cast<const protocol::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue::RefCache: {
      auto ptr = reinterpret_cast<const protocol::RefCache *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnyValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyValue(
        verifier,  values->Get(i), types->GetEnum<AnyValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command::NONE: {
      return true;
    }
    case Command::SetCommand: {
      auto ptr = reinterpret_cast<const protocol::SetCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command::FormatCommand: {
      auto ptr = reinterpret_cast<const protocol::FormatCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Command> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace protocol

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
