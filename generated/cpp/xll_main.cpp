
// Code generated by xll-gen v0.2.0. DO NOT EDIT.
#include <windows.h>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <map>
#include <mutex>
#include <sstream>
#include <wchar.h>
#include <random>
#include <iostream>
#include <fstream>
#include <cstring>
#include "include/xlcall.h"
#include "include/xll_mem.h"
#include "include/xll_utility.h"
#include "include/xll_ipc.h"
#include "include/xll_converters.h"
#include "include/PascalString.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"

#include "include/xll_embed.h"


std::thread g_worker;
std::thread g_monitor;
std::atomic<bool> g_running{false};

// Global Process Handle (for auto-launched server)
HANDLE g_hChildProcess = NULL;
HANDLE g_hJob = NULL;
HINSTANCE g_hModule = NULL;

// Global Error Value for Returns
static XLOPER12 g_xlErrValue;

// Logging
static std::string g_logPath;

void LogError(const std::string& msg) {
    if (g_logPath.empty()) return;
    std::ofstream logFile(g_logPath, std::ios_base::app);
    if (logFile.is_open()) {
        auto now = std::chrono::system_clock::now();
        auto in_time_t = std::chrono::system_clock::to_time_t(now);
        struct tm buf;
        localtime_s(&buf, &in_time_t);
        char timeStr[32];
        std::strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", &buf);

        logFile << "[" << timeStr << "] [ERROR] " << msg << std::endl;
    }
}

// Custom Allocator for FlatBuffers to use Shared Memory
class SHMAllocator : public flatbuffers::Allocator {
private:
    uint8_t* buffer_;
    size_t size_;

public:
    SHMAllocator(uint8_t* buffer, size_t size)
        : buffer_(buffer), size_(size) {}

    uint8_t* allocate(size_t size) override {
        if (size > size_) {
            return nullptr;
        }
        return buffer_;
    }

    void deallocate(uint8_t* p, size_t size) override {
        // Shared Memory, do nothing
    }
};

// Helper for creating string XLOPER12 without pool (for batching)
// We cannot use the global ObjectPool because xlAsyncReturn with xltypeMulti
// requires a contiguous array of XLOPER12 structs, while the pool provides
// pointers to scattered individual objects.
XLOPER12 CreateStringXLOPER(const std::wstring& str) {
    XLOPER12 x;
    x.xltype = xltypeStr;
    std::vector<wchar_t> pstr = WStringToPascalString(str);
    x.val.str = new wchar_t[pstr.size()];
    std::memcpy(x.val.str, pstr.data(), pstr.size() * sizeof(wchar_t));
    return x;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);

        // Initialize global error
        g_xlErrValue.xltype = xltypeErr;
        g_xlErrValue.val.err = xlerrValue;
    }
    return TRUE;
}

bool IsSingleCell(LPXLOPER12 xRef) {
    if (!xRef) return false;
    int type = xRef->xltype & ~(xlbitXLFree | xlbitDLLFree);
    if (type == xltypeSRef) {
         const auto& r = xRef->val.sref.ref;
         return (r.rwFirst == r.rwLast && r.colFirst == r.colLast);
    } else if (type == xltypeRef) {
         const auto* m = xRef->val.mref.lpmref;
         if (m && m->count == 1) {
             const auto& r = m->reftbl[0];
             return (r.rwFirst == r.rwLast && r.colFirst == r.colLast);
         }
    }
    return false;
}

void ExecuteCommands(const ipc::CalculationEndedResponse* resp) {
    if (!resp || !resp->commands()) return;
    auto wrappers = resp->commands();
    for (auto it = wrappers->begin(); it != wrappers->end(); ++it) {
        if (it->cmd_type() == ipc::Command_SetCommand) {
            auto cmd = static_cast<const ipc::SetCommand*>(it->cmd());
            LPXLOPER12 xRef = RangeToXLOPER12(cmd->target());
            LPXLOPER12 xVal = AnyToXLOPER12(cmd->value());
            if (xRef && xVal) {
                Excel12(xlSet, 0, 2, xRef, xVal);
            }
            if (xRef) xlAutoFree12(xRef);
            if (xVal) xlAutoFree12(xVal);
        } else if (it->cmd_type() == ipc::Command_FormatCommand) {
            auto cmd = static_cast<const ipc::FormatCommand*>(it->cmd());
            LPXLOPER12 xRef = RangeToXLOPER12(cmd->target());
            if (xRef) {
                bool doFormat = true;
                std::string fmt = cmd->format()->str();
                std::wstring wfmt = StringToWString(fmt);

                if (IsSingleCell(xRef)) {
                    XLOPER12 xFmt;
                    if (Excel12(xlfGetCell, &xFmt, 2, TempInt12(7), xRef) == xlretSuccess) {
                        if (xFmt.xltype == xltypeStr && xFmt.val.str) {
                            size_t len = (size_t)xFmt.val.str[0];
                            if (len == wfmt.length()) {
                                if (wcsncmp(xFmt.val.str + 1, wfmt.c_str(), len) == 0) {
                                    doFormat = false;
                                }
                            }
                        }
                        Excel12(xlFree, 0, 1, &xFmt);
                    }
                }

                if (doFormat) {
                    XLOPER12 xOldSel;
                    if (Excel12(xlfSelection, &xOldSel, 0) == xlretSuccess) {
                        Excel12(xlcSelect, 0, 1, xRef);
                        Excel12(xlcFormatNumber, 0, 1, TempStr12(wfmt.c_str()));
                        Excel12(xlcSelect, 0, 1, &xOldSel);
                        Excel12(xlFree, 0, 1, &xOldSel);
                    }
                }
                xlAutoFree12(xRef);
            }
        }
    }
}

// Helper to replace all occurrences of a substring
void ReplaceAll(std::wstring& str, const std::wstring& from, const std::wstring& to) {
    if(from.empty()) return;
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::wstring::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
}

bool FileExists(const std::wstring& path) {
    DWORD dwAttrib = GetFileAttributesW(path.c_str());
    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

extern "C" {

__declspec(dllexport) int __stdcall xlAutoOpen() {

    // Setup Native Logging
    std::wstring xllDir = GetXllDir();
    std::wstring logDir = xllDir;


    // In singlefile mode, we want logs in the temp directory
    std::string tempPattern = "${TEMP}";
    std::string projName = "";
    std::string expandedTemp = embed::ExpandEnvVars(tempPattern);
    if (!expandedTemp.empty()) {
        std::string targetDir = expandedTemp + "\\" + projName;
        // Ensure dir exists
        CreateDirectoryA(targetDir.c_str(), NULL);
        logDir = StringToWString(targetDir);
    }


    std::wstring wLogName = StringToWString("server_native.log");
    g_logPath = WideToUtf8(logDir + L"\\" + wLogName);


    // Determine worker count
    int workers = 0;
    if (workers <= 0) {
        workers = std::thread::hardware_concurrency();
        if (workers == 0) workers = 16; // Fallback
    }

    // 1024 queue items, 1MB buffer size per slot

    std::string shmName = "_" + std::to_string(GetCurrentProcessId());


    if (!g_host.Init(shmName.c_str(), 1024, 1024*1024, workers + 2)) {
        LogError("Failed to initialize Shared Memory with name: " + shmName);
        return 0;
    }

    g_running = true;
    g_worker = std::thread([]{
        // Reusable vectors for batch processing
        std::vector<XLOPER12> handles;
        std::vector<XLOPER12> values;
        handles.reserve(256);
        values.reserve(256);

        int spin = 0;
        while(g_running) {
             handles.clear();
             values.clear();

             int n = g_host.ProcessGuestCalls([&handles, &values](const uint8_t* req, int32_t size, uint8_t* resp, uint32_t capacity, shm::MsgType msgId) -> int32_t {
                 try {
                     switch (msgId) {
                     case (shm::MsgType)127: { // MSG_BATCH_ASYNC_RESPONSE
                         auto batch = flatbuffers::GetRoot<ipc::BatchAsyncResponse>(req);
                         if (batch->results()) {
                             for (auto res : *batch->results()) {
                                 XLOPER12 h;
                                 h.xltype = xltypeBigData | xlbitXLFree;
                                 LPXLOPER12 originalHandle = (LPXLOPER12)res->handle();
                                 if (originalHandle) {
                                     h = *originalHandle; // Copy the struct content (xltypeBigData, val, etc.)

                                     XLOPER12 val;
                                     std::memset(&val, 0, sizeof(XLOPER12));

                                     if (res->error() && res->error()->size() > 0) {
                                         val.xltype = xltypeErr; val.val.err = xlerrValue;
                                         // LogError("Async batch error: " + res->error()->str()); // Optional
                                     } else {
                                         // Convert AnyValue to XLOPER12
                                         auto anyType = res->result_type();
                                         if (anyType == ipc::types::AnyValue_Int) {
                                             val.xltype = xltypeInt;
                                             val.val.w = static_cast<const ipc::types::Int*>(res->result())->val();
                                         } else if (anyType == ipc::types::AnyValue_Num) {
                                             val.xltype = xltypeNum;
                                             val.val.num = static_cast<const ipc::types::Num*>(res->result())->val();
                                         } else if (anyType == ipc::types::AnyValue_Bool) {
                                             val.xltype = xltypeBool;
                                             val.val.xbool = static_cast<const ipc::types::Bool*>(res->result())->val() ? 1 : 0;
                                         } else if (anyType == ipc::types::AnyValue_Str) {
                                             auto s = static_cast<const ipc::types::Str*>(res->result())->val();
                                             std::wstring wres = StringToWString(s->str());
                                             val = CreateStringXLOPER(wres);
                                         } else {
                                              val.xltype = xltypeErr; val.val.err = xlerrValue;
                                         }
                                     }
                                     handles.push_back(h);
                                     values.push_back(val);
                                 }
                             }
                         }
                         return 0;
                     }



                         default:
                             return 0;
                     }
                 } catch (const std::exception& e) {
                     LogError("Exception in guest call handler: " + std::string(e.what()));
                     return 0;
                 } catch (...) {
                     LogError("Unknown exception in guest call handler");
                     return 0;
                 }
              });

              if (!handles.empty()) {
                  if (handles.size() == 1) {
                      Excel12(xlAsyncReturn, 0, 2, &handles[0], &values[0]);
                  } else {
                      int N = (int)handles.size();

                      XLOPER12 arrH, arrV;
                      arrH.xltype = xltypeMulti; arrH.val.array.rows = 1; arrH.val.array.columns = N; arrH.val.array.lparray = handles.data();
                      arrV.xltype = xltypeMulti; arrV.val.array.rows = 1; arrV.val.array.columns = N; arrV.val.array.lparray = values.data();

                      Excel12(xlAsyncReturn, 0, 2, &arrH, &arrV);
                  }

                  // Cleanup allocated strings
                  for(auto& v : values) {
                      if ((v.xltype & xltypeStr) && v.val.str) {
                          delete[] v.val.str;
                          v.val.str = nullptr;
                      }
                  }
              }

              if (n == 0) {
                  if (spin < 1000) {
                      std::this_thread::yield();
                      spin++;
                  } else {
                      Sleep(1);
                      spin = 0;
                  }
              } else {
                  spin = 0;
              }
        }
    });

    static XLOPER12 xDll;
    Excel12(xlGetName, &xDll, 0);



    bool needCalcEnded = false;

    if (needCalcEnded) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }



    {
        Excel12(xlfRegister, 0, 12,
            &xDll,
            TempStr12(L"Add"),
            TempStr12(L"QBB$"),
            TempStr12(L"Add"),
            TempStr12(L"a,b"),
            TempStr12(L"1"),
            TempStr12(L""),
            TempStr12(L""),
            TempStr12(L""),
            TempStr12(L"Adds two numbers"),
            TempStr12(L""),TempStr12(L"")

        );
    }




    Excel12(xlFree, 0, 1, &xDll);
    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    g_running = false;
    if (g_worker.joinable()) g_worker.join();
    g_host.Shutdown();

    if (g_hChildProcess) {
        TerminateProcess(g_hChildProcess, 0);
        // This will signal the monitor thread to wake up
    }

    if (g_monitor.joinable()) g_monitor.join();

    if (g_hChildProcess) {
        CloseHandle(g_hChildProcess);
        g_hChildProcess = NULL;
    }
    if (g_hJob) {
        CloseHandle(g_hJob);
        g_hJob = NULL;
    }
    return 1;
}



__declspec(dllexport) void __stdcall CalculationEnded() {
    try {
        {
            std::lock_guard<std::mutex> lock(g_refCacheMutex);
            g_sentRefCache.clear();
        }
        std::vector<uint8_t> respBuf;
        auto res = g_host.Send(nullptr, 0, (shm::MsgType)MSG_CALCULATION_ENDED, respBuf, 2000);
        if (res && res.Value() > 0) {
             auto resp = flatbuffers::GetRoot<ipc::CalculationEndedResponse>(respBuf.data());
             ExecuteCommands(resp);
        }
    } catch (const std::exception& e) {
        LogError("Exception in CalculationEnded: " + std::string(e.what()));
    } catch (...) {
        LogError("Unknown exception in CalculationEnded");
    }
}



__declspec(dllexport) LPXLOPER12 __stdcall Add(double a, double b) {
    try {
        auto slot = g_host.GetZeroCopySlot();
        SHMAllocator allocator(slot.GetReqBuffer(), slot.GetMaxReqSize());
        flatbuffers::FlatBufferBuilder builder(slot.GetMaxReqSize(), &allocator, false);









        ipc::AddRequestBuilder reqBuilder(builder);


        reqBuilder.add_a(a);



        reqBuilder.add_b(b);




        auto req = reqBuilder.Finish();
        builder.Finish(req);

        // Zero-Copy Send (Size, MsgId, Timeout)
        // We send negative size to indicate the data is at the end of the buffer (Zero-Copy).
        int32_t reqSize = -((int32_t)builder.GetSize());


        // Sync Calculation Timeout: Function override OR Global Timeout (default 2000)


        auto res = slot.Send(reqSize, (shm::MsgType)(132), 2000);
        if (res.HasError()) {
            LogError("Failed to send request for Add");
            return &g_xlErrValue;
        }

        auto resp = flatbuffers::GetRoot<ipc::AddResponse>(slot.GetRespBuffer());
        if (resp->error() && resp->error()->size() > 0) {
            LogError("Error executing Add: " + resp->error()->str());
            return &g_xlErrValue;
        }


        static thread_local XLOPER12 xRes;
        xRes.xltype = xltypeNum;
        xRes.val.num = resp->result();
        return &xRes;


    } catch (const std::exception& e) {
        LogError("Exception in Add: " + std::string(e.what()));
        return &g_xlErrValue;
    } catch (...) {
        LogError("Unknown exception in Add");
        return &g_xlErrValue;
    }
}


} // extern "C"
