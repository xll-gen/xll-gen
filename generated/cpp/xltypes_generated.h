// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_XLTYPES_IPC_TYPES_H_
#define FLATBUFFERS_GENERATED_XLTYPES_IPC_TYPES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace ipc {
namespace types {

struct Bool;
struct BoolBuilder;

struct Num;
struct NumBuilder;

struct Int;
struct IntBuilder;

struct Str;
struct StrBuilder;

struct Err;
struct ErrBuilder;

struct AsyncHandle;
struct AsyncHandleBuilder;

struct Nil;
struct NilBuilder;

struct RefCache;
struct RefCacheBuilder;

struct Rect;

struct Range;
struct RangeBuilder;

struct Scalar;
struct ScalarBuilder;

struct Grid;
struct GridBuilder;

struct NumGrid;
struct NumGridBuilder;

struct Any;
struct AnyBuilder;

enum XlError : int16_t {
  XlError_Null = 2000,
  XlError_Div0 = 2007,
  XlError_Value = 2015,
  XlError_Ref = 2023,
  XlError_Name = 2029,
  XlError_Num = 2036,
  XlError_NA = 2042,
  XlError_GettingData = 2043,
  XlError_Spill = 2045,
  XlError_Connect = 2046,
  XlError_Blocked = 2047,
  XlError_Unknown = 2048,
  XlError_Field = 2049,
  XlError_Calc = 2050,
  XlError_MIN = XlError_Null,
  XlError_MAX = XlError_Calc
};

inline const XlError (&EnumValuesXlError())[14] {
  static const XlError values[] = {
    XlError_Null,
    XlError_Div0,
    XlError_Value,
    XlError_Ref,
    XlError_Name,
    XlError_Num,
    XlError_NA,
    XlError_GettingData,
    XlError_Spill,
    XlError_Connect,
    XlError_Blocked,
    XlError_Unknown,
    XlError_Field,
    XlError_Calc
  };
  return values;
}

inline const char * const *EnumNamesXlError() {
  static const char * const names[52] = {
    "Null",
    "",
    "",
    "",
    "",
    "",
    "",
    "Div0",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Value",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Ref",
    "",
    "",
    "",
    "",
    "",
    "Name",
    "",
    "",
    "",
    "",
    "",
    "",
    "Num",
    "",
    "",
    "",
    "",
    "",
    "NA",
    "GettingData",
    "",
    "Spill",
    "Connect",
    "Blocked",
    "Unknown",
    "Field",
    "Calc",
    nullptr
  };
  return names;
}

inline const char *EnumNameXlError(XlError e) {
  if (::flatbuffers::IsOutRange(e, XlError_Null, XlError_Calc)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(XlError_Null);
  return EnumNamesXlError()[index];
}

enum ScalarValue : uint8_t {
  ScalarValue_NONE = 0,
  ScalarValue_Bool = 1,
  ScalarValue_Num = 2,
  ScalarValue_Int = 3,
  ScalarValue_Str = 4,
  ScalarValue_Err = 5,
  ScalarValue_AsyncHandle = 6,
  ScalarValue_Nil = 7,
  ScalarValue_MIN = ScalarValue_NONE,
  ScalarValue_MAX = ScalarValue_Nil
};

inline const ScalarValue (&EnumValuesScalarValue())[8] {
  static const ScalarValue values[] = {
    ScalarValue_NONE,
    ScalarValue_Bool,
    ScalarValue_Num,
    ScalarValue_Int,
    ScalarValue_Str,
    ScalarValue_Err,
    ScalarValue_AsyncHandle,
    ScalarValue_Nil
  };
  return values;
}

inline const char * const *EnumNamesScalarValue() {
  static const char * const names[9] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    nullptr
  };
  return names;
}

inline const char *EnumNameScalarValue(ScalarValue e) {
  if (::flatbuffers::IsOutRange(e, ScalarValue_NONE, ScalarValue_Nil)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScalarValue()[index];
}

template<typename T> struct ScalarValueTraits {
  static const ScalarValue enum_value = ScalarValue_NONE;
};

template<> struct ScalarValueTraits<ipc::types::Bool> {
  static const ScalarValue enum_value = ScalarValue_Bool;
};

template<> struct ScalarValueTraits<ipc::types::Num> {
  static const ScalarValue enum_value = ScalarValue_Num;
};

template<> struct ScalarValueTraits<ipc::types::Int> {
  static const ScalarValue enum_value = ScalarValue_Int;
};

template<> struct ScalarValueTraits<ipc::types::Str> {
  static const ScalarValue enum_value = ScalarValue_Str;
};

template<> struct ScalarValueTraits<ipc::types::Err> {
  static const ScalarValue enum_value = ScalarValue_Err;
};

template<> struct ScalarValueTraits<ipc::types::AsyncHandle> {
  static const ScalarValue enum_value = ScalarValue_AsyncHandle;
};

template<> struct ScalarValueTraits<ipc::types::Nil> {
  static const ScalarValue enum_value = ScalarValue_Nil;
};

bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type);
bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum AnyValue : uint8_t {
  AnyValue_NONE = 0,
  AnyValue_Bool = 1,
  AnyValue_Num = 2,
  AnyValue_Int = 3,
  AnyValue_Str = 4,
  AnyValue_Err = 5,
  AnyValue_AsyncHandle = 6,
  AnyValue_Nil = 7,
  AnyValue_Grid = 8,
  AnyValue_NumGrid = 9,
  AnyValue_Range = 10,
  AnyValue_RefCache = 11,
  AnyValue_MIN = AnyValue_NONE,
  AnyValue_MAX = AnyValue_RefCache
};

inline const AnyValue (&EnumValuesAnyValue())[12] {
  static const AnyValue values[] = {
    AnyValue_NONE,
    AnyValue_Bool,
    AnyValue_Num,
    AnyValue_Int,
    AnyValue_Str,
    AnyValue_Err,
    AnyValue_AsyncHandle,
    AnyValue_Nil,
    AnyValue_Grid,
    AnyValue_NumGrid,
    AnyValue_Range,
    AnyValue_RefCache
  };
  return values;
}

inline const char * const *EnumNamesAnyValue() {
  static const char * const names[13] = {
    "NONE",
    "Bool",
    "Num",
    "Int",
    "Str",
    "Err",
    "AsyncHandle",
    "Nil",
    "Grid",
    "NumGrid",
    "Range",
    "RefCache",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyValue(AnyValue e) {
  if (::flatbuffers::IsOutRange(e, AnyValue_NONE, AnyValue_RefCache)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyValue()[index];
}

template<typename T> struct AnyValueTraits {
  static const AnyValue enum_value = AnyValue_NONE;
};

template<> struct AnyValueTraits<ipc::types::Bool> {
  static const AnyValue enum_value = AnyValue_Bool;
};

template<> struct AnyValueTraits<ipc::types::Num> {
  static const AnyValue enum_value = AnyValue_Num;
};

template<> struct AnyValueTraits<ipc::types::Int> {
  static const AnyValue enum_value = AnyValue_Int;
};

template<> struct AnyValueTraits<ipc::types::Str> {
  static const AnyValue enum_value = AnyValue_Str;
};

template<> struct AnyValueTraits<ipc::types::Err> {
  static const AnyValue enum_value = AnyValue_Err;
};

template<> struct AnyValueTraits<ipc::types::AsyncHandle> {
  static const AnyValue enum_value = AnyValue_AsyncHandle;
};

template<> struct AnyValueTraits<ipc::types::Nil> {
  static const AnyValue enum_value = AnyValue_Nil;
};

template<> struct AnyValueTraits<ipc::types::Grid> {
  static const AnyValue enum_value = AnyValue_Grid;
};

template<> struct AnyValueTraits<ipc::types::NumGrid> {
  static const AnyValue enum_value = AnyValue_NumGrid;
};

template<> struct AnyValueTraits<ipc::types::Range> {
  static const AnyValue enum_value = AnyValue_Range;
};

template<> struct AnyValueTraits<ipc::types::RefCache> {
  static const AnyValue enum_value = AnyValue_RefCache;
};

bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type);
bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t row_first_;
  int32_t row_last_;
  int32_t col_first_;
  int32_t col_last_;

 public:
  Rect()
      : row_first_(0),
        row_last_(0),
        col_first_(0),
        col_last_(0) {
  }
  Rect(int32_t _row_first, int32_t _row_last, int32_t _col_first, int32_t _col_last)
      : row_first_(::flatbuffers::EndianScalar(_row_first)),
        row_last_(::flatbuffers::EndianScalar(_row_last)),
        col_first_(::flatbuffers::EndianScalar(_col_first)),
        col_last_(::flatbuffers::EndianScalar(_col_last)) {
  }
  int32_t row_first() const {
    return ::flatbuffers::EndianScalar(row_first_);
  }
  int32_t row_last() const {
    return ::flatbuffers::EndianScalar(row_last_);
  }
  int32_t col_first() const {
    return ::flatbuffers::EndianScalar(col_first_);
  }
  int32_t col_last() const {
    return ::flatbuffers::EndianScalar(col_last_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

struct Bool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
};

struct BoolBuilder {
  typedef Bool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(Bool::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Bool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Bool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Bool> CreateBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Num FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  double val() const {
    return GetField<double>(VT_VAL, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct NumBuilder {
  typedef Num Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(double val) {
    fbb_.AddElement<double>(Num::VT_VAL, val, 0.0);
  }
  explicit NumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Num> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Num>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Num> CreateNum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double val = 0.0) {
  NumBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Int FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
};

struct IntBuilder {
  typedef Int Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(Int::VT_VAL, val, 0);
  }
  explicit IntBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int> CreateInt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Str FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  const ::flatbuffers::String *val() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct StrBuilder {
  typedef Str Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(::flatbuffers::Offset<::flatbuffers::String> val) {
    fbb_.AddOffset(Str::VT_VAL, val);
  }
  explicit StrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Str> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Str>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Str> CreateStr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> val = 0) {
  StrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Str> CreateStrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *val = nullptr) {
  auto val__ = val ? _fbb.CreateString(val) : 0;
  return ipc::types::CreateStr(
      _fbb,
      val__);
}

struct Err FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  ipc::types::XlError val() const {
    return static_cast<ipc::types::XlError>(GetField<int16_t>(VT_VAL, 2000));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VAL, 2) &&
           verifier.EndTable();
  }
};

struct ErrBuilder {
  typedef Err Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(ipc::types::XlError val) {
    fbb_.AddElement<int16_t>(Err::VT_VAL, static_cast<int16_t>(val), 2000);
  }
  explicit ErrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Err> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Err>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Err> CreateErr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ipc::types::XlError val = ipc::types::XlError_Null) {
  ErrBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct AsyncHandle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncHandleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  uint64_t val() const {
    return GetField<uint64_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VAL, 8) &&
           verifier.EndTable();
  }
};

struct AsyncHandleBuilder {
  typedef AsyncHandle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(uint64_t val) {
    fbb_.AddElement<uint64_t>(AsyncHandle::VT_VAL, val, 0);
  }
  explicit AsyncHandleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncHandle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncHandle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncHandle> CreateAsyncHandle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t val = 0) {
  AsyncHandleBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct Nil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NilBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NilBuilder {
  typedef Nil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NilBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Nil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Nil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Nil> CreateNil(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RefCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RefCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct RefCacheBuilder {
  typedef RefCache Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(RefCache::VT_KEY, key);
  }
  explicit RefCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RefCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RefCache>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RefCache> CreateRefCache(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0) {
  RefCacheBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RefCache> CreateRefCacheDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return ipc::types::CreateRefCache(
      _fbb,
      key__);
}

struct Range FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHEET_NAME = 4,
    VT_REFS = 6
  };
  const ::flatbuffers::String *sheet_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHEET_NAME);
  }
  const ::flatbuffers::Vector<const ipc::types::Rect *> *refs() const {
    return GetPointer<const ::flatbuffers::Vector<const ipc::types::Rect *> *>(VT_REFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHEET_NAME) &&
           verifier.VerifyString(sheet_name()) &&
           VerifyOffset(verifier, VT_REFS) &&
           verifier.VerifyVector(refs()) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  typedef Range Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sheet_name(::flatbuffers::Offset<::flatbuffers::String> sheet_name) {
    fbb_.AddOffset(Range::VT_SHEET_NAME, sheet_name);
  }
  void add_refs(::flatbuffers::Offset<::flatbuffers::Vector<const ipc::types::Rect *>> refs) {
    fbb_.AddOffset(Range::VT_REFS, refs);
  }
  explicit RangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Range> CreateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> sheet_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const ipc::types::Rect *>> refs = 0) {
  RangeBuilder builder_(_fbb);
  builder_.add_refs(refs);
  builder_.add_sheet_name(sheet_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Range> CreateRangeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *sheet_name = nullptr,
    const std::vector<ipc::types::Rect> *refs = nullptr) {
  auto sheet_name__ = sheet_name ? _fbb.CreateString(sheet_name) : 0;
  auto refs__ = refs ? _fbb.CreateVectorOfStructs<ipc::types::Rect>(*refs) : 0;
  return ipc::types::CreateRange(
      _fbb,
      sheet_name__,
      refs__);
}

struct Scalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  ipc::types::ScalarValue val_type() const {
    return static_cast<ipc::types::ScalarValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const ipc::types::Bool *val_as_Bool() const {
    return val_type() == ipc::types::ScalarValue_Bool ? static_cast<const ipc::types::Bool *>(val()) : nullptr;
  }
  const ipc::types::Num *val_as_Num() const {
    return val_type() == ipc::types::ScalarValue_Num ? static_cast<const ipc::types::Num *>(val()) : nullptr;
  }
  const ipc::types::Int *val_as_Int() const {
    return val_type() == ipc::types::ScalarValue_Int ? static_cast<const ipc::types::Int *>(val()) : nullptr;
  }
  const ipc::types::Str *val_as_Str() const {
    return val_type() == ipc::types::ScalarValue_Str ? static_cast<const ipc::types::Str *>(val()) : nullptr;
  }
  const ipc::types::Err *val_as_Err() const {
    return val_type() == ipc::types::ScalarValue_Err ? static_cast<const ipc::types::Err *>(val()) : nullptr;
  }
  const ipc::types::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == ipc::types::ScalarValue_AsyncHandle ? static_cast<const ipc::types::AsyncHandle *>(val()) : nullptr;
  }
  const ipc::types::Nil *val_as_Nil() const {
    return val_type() == ipc::types::ScalarValue_Nil ? static_cast<const ipc::types::Nil *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyScalarValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ipc::types::Bool *Scalar::val_as<ipc::types::Bool>() const {
  return val_as_Bool();
}

template<> inline const ipc::types::Num *Scalar::val_as<ipc::types::Num>() const {
  return val_as_Num();
}

template<> inline const ipc::types::Int *Scalar::val_as<ipc::types::Int>() const {
  return val_as_Int();
}

template<> inline const ipc::types::Str *Scalar::val_as<ipc::types::Str>() const {
  return val_as_Str();
}

template<> inline const ipc::types::Err *Scalar::val_as<ipc::types::Err>() const {
  return val_as_Err();
}

template<> inline const ipc::types::AsyncHandle *Scalar::val_as<ipc::types::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const ipc::types::Nil *Scalar::val_as<ipc::types::Nil>() const {
  return val_as_Nil();
}

struct ScalarBuilder {
  typedef Scalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(ipc::types::ScalarValue val_type) {
    fbb_.AddElement<uint8_t>(Scalar::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Scalar::VT_VAL, val);
  }
  explicit ScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scalar> CreateScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ipc::types::ScalarValue val_type = ipc::types::ScalarValue_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  ScalarBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

struct Grid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::types::Scalar>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::types::Scalar>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct GridBuilder {
  typedef Grid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(Grid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(Grid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::types::Scalar>>> data) {
    fbb_.AddOffset(Grid::VT_DATA, data);
  }
  explicit GridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Grid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Grid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Grid> CreateGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::types::Scalar>>> data = 0) {
  GridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Grid> CreateGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<::flatbuffers::Offset<ipc::types::Scalar>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<ipc::types::Scalar>>(*data) : 0;
  return ipc::types::CreateGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct NumGrid FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumGridBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4,
    VT_COLS = 6,
    VT_DATA = 8
  };
  int32_t rows() const {
    return GetField<int32_t>(VT_ROWS, 0);
  }
  int32_t cols() const {
    return GetField<int32_t>(VT_COLS, 0);
  }
  const ::flatbuffers::Vector<double> *data() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ROWS, 4) &&
           VerifyField<int32_t>(verifier, VT_COLS, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct NumGridBuilder {
  typedef NumGrid Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rows(int32_t rows) {
    fbb_.AddElement<int32_t>(NumGrid::VT_ROWS, rows, 0);
  }
  void add_cols(int32_t cols) {
    fbb_.AddElement<int32_t>(NumGrid::VT_COLS, cols, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(NumGrid::VT_DATA, data);
  }
  explicit NumGridBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumGrid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumGrid>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumGrid> CreateNumGrid(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> data = 0) {
  NumGridBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_cols(cols);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NumGrid> CreateNumGridDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rows = 0,
    int32_t cols = 0,
    const std::vector<double> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  return ipc::types::CreateNumGrid(
      _fbb,
      rows,
      cols,
      data__);
}

struct Any FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL_TYPE = 4,
    VT_VAL = 6
  };
  ipc::types::AnyValue val_type() const {
    return static_cast<ipc::types::AnyValue>(GetField<uint8_t>(VT_VAL_TYPE, 0));
  }
  const void *val() const {
    return GetPointer<const void *>(VT_VAL);
  }
  template<typename T> const T *val_as() const;
  const ipc::types::Bool *val_as_Bool() const {
    return val_type() == ipc::types::AnyValue_Bool ? static_cast<const ipc::types::Bool *>(val()) : nullptr;
  }
  const ipc::types::Num *val_as_Num() const {
    return val_type() == ipc::types::AnyValue_Num ? static_cast<const ipc::types::Num *>(val()) : nullptr;
  }
  const ipc::types::Int *val_as_Int() const {
    return val_type() == ipc::types::AnyValue_Int ? static_cast<const ipc::types::Int *>(val()) : nullptr;
  }
  const ipc::types::Str *val_as_Str() const {
    return val_type() == ipc::types::AnyValue_Str ? static_cast<const ipc::types::Str *>(val()) : nullptr;
  }
  const ipc::types::Err *val_as_Err() const {
    return val_type() == ipc::types::AnyValue_Err ? static_cast<const ipc::types::Err *>(val()) : nullptr;
  }
  const ipc::types::AsyncHandle *val_as_AsyncHandle() const {
    return val_type() == ipc::types::AnyValue_AsyncHandle ? static_cast<const ipc::types::AsyncHandle *>(val()) : nullptr;
  }
  const ipc::types::Nil *val_as_Nil() const {
    return val_type() == ipc::types::AnyValue_Nil ? static_cast<const ipc::types::Nil *>(val()) : nullptr;
  }
  const ipc::types::Grid *val_as_Grid() const {
    return val_type() == ipc::types::AnyValue_Grid ? static_cast<const ipc::types::Grid *>(val()) : nullptr;
  }
  const ipc::types::NumGrid *val_as_NumGrid() const {
    return val_type() == ipc::types::AnyValue_NumGrid ? static_cast<const ipc::types::NumGrid *>(val()) : nullptr;
  }
  const ipc::types::Range *val_as_Range() const {
    return val_type() == ipc::types::AnyValue_Range ? static_cast<const ipc::types::Range *>(val()) : nullptr;
  }
  const ipc::types::RefCache *val_as_RefCache() const {
    return val_type() == ipc::types::AnyValue_RefCache ? static_cast<const ipc::types::RefCache *>(val()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL_TYPE, 1) &&
           VerifyOffset(verifier, VT_VAL) &&
           VerifyAnyValue(verifier, val(), val_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ipc::types::Bool *Any::val_as<ipc::types::Bool>() const {
  return val_as_Bool();
}

template<> inline const ipc::types::Num *Any::val_as<ipc::types::Num>() const {
  return val_as_Num();
}

template<> inline const ipc::types::Int *Any::val_as<ipc::types::Int>() const {
  return val_as_Int();
}

template<> inline const ipc::types::Str *Any::val_as<ipc::types::Str>() const {
  return val_as_Str();
}

template<> inline const ipc::types::Err *Any::val_as<ipc::types::Err>() const {
  return val_as_Err();
}

template<> inline const ipc::types::AsyncHandle *Any::val_as<ipc::types::AsyncHandle>() const {
  return val_as_AsyncHandle();
}

template<> inline const ipc::types::Nil *Any::val_as<ipc::types::Nil>() const {
  return val_as_Nil();
}

template<> inline const ipc::types::Grid *Any::val_as<ipc::types::Grid>() const {
  return val_as_Grid();
}

template<> inline const ipc::types::NumGrid *Any::val_as<ipc::types::NumGrid>() const {
  return val_as_NumGrid();
}

template<> inline const ipc::types::Range *Any::val_as<ipc::types::Range>() const {
  return val_as_Range();
}

template<> inline const ipc::types::RefCache *Any::val_as<ipc::types::RefCache>() const {
  return val_as_RefCache();
}

struct AnyBuilder {
  typedef Any Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val_type(ipc::types::AnyValue val_type) {
    fbb_.AddElement<uint8_t>(Any::VT_VAL_TYPE, static_cast<uint8_t>(val_type), 0);
  }
  void add_val(::flatbuffers::Offset<void> val) {
    fbb_.AddOffset(Any::VT_VAL, val);
  }
  explicit AnyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Any> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Any>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Any> CreateAny(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ipc::types::AnyValue val_type = ipc::types::AnyValue_NONE,
    ::flatbuffers::Offset<void> val = 0) {
  AnyBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_val_type(val_type);
  return builder_.Finish();
}

inline bool VerifyScalarValue(::flatbuffers::Verifier &verifier, const void *obj, ScalarValue type) {
  switch (type) {
    case ScalarValue_NONE: {
      return true;
    }
    case ScalarValue_Bool: {
      auto ptr = reinterpret_cast<const ipc::types::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Num: {
      auto ptr = reinterpret_cast<const ipc::types::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Int: {
      auto ptr = reinterpret_cast<const ipc::types::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Str: {
      auto ptr = reinterpret_cast<const ipc::types::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Err: {
      auto ptr = reinterpret_cast<const ipc::types::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_AsyncHandle: {
      auto ptr = reinterpret_cast<const ipc::types::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScalarValue_Nil: {
      auto ptr = reinterpret_cast<const ipc::types::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScalarValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScalarValue(
        verifier,  values->Get(i), types->GetEnum<ScalarValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyValue(::flatbuffers::Verifier &verifier, const void *obj, AnyValue type) {
  switch (type) {
    case AnyValue_NONE: {
      return true;
    }
    case AnyValue_Bool: {
      auto ptr = reinterpret_cast<const ipc::types::Bool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Num: {
      auto ptr = reinterpret_cast<const ipc::types::Num *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Int: {
      auto ptr = reinterpret_cast<const ipc::types::Int *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Str: {
      auto ptr = reinterpret_cast<const ipc::types::Str *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Err: {
      auto ptr = reinterpret_cast<const ipc::types::Err *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_AsyncHandle: {
      auto ptr = reinterpret_cast<const ipc::types::AsyncHandle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Nil: {
      auto ptr = reinterpret_cast<const ipc::types::Nil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Grid: {
      auto ptr = reinterpret_cast<const ipc::types::Grid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_NumGrid: {
      auto ptr = reinterpret_cast<const ipc::types::NumGrid *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_Range: {
      auto ptr = reinterpret_cast<const ipc::types::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyValue_RefCache: {
      auto ptr = reinterpret_cast<const ipc::types::RefCache *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyValue(
        verifier,  values->Get(i), types->GetEnum<AnyValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace types
}  // namespace ipc

#endif  // FLATBUFFERS_GENERATED_XLTYPES_IPC_TYPES_H_
