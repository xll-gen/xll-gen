// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_IPC_H_
#define FLATBUFFERS_GENERATED_SCHEMA_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "xltypes_generated.h"

namespace ipc {

struct Ack;
struct AckBuilder;

struct Chunk;
struct ChunkBuilder;

struct SetRefCacheRequest;
struct SetRefCacheRequestBuilder;

struct SetCommand;
struct SetCommandBuilder;

struct FormatCommand;
struct FormatCommandBuilder;

struct CommandWrapper;
struct CommandWrapperBuilder;

struct CalculationEndedResponse;
struct CalculationEndedResponseBuilder;

struct AsyncResult;
struct AsyncResultBuilder;

struct BatchAsyncResponse;
struct BatchAsyncResponseBuilder;

struct AddRequest;
struct AddRequestBuilder;

struct AddResponse;
struct AddResponseBuilder;

enum Command : uint8_t {
  Command_NONE = 0,
  Command_SetCommand = 1,
  Command_FormatCommand = 2,
  Command_MIN = Command_NONE,
  Command_MAX = Command_FormatCommand
};

inline const Command (&EnumValuesCommand())[3] {
  static const Command values[] = {
    Command_NONE,
    Command_SetCommand,
    Command_FormatCommand
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[4] = {
    "NONE",
    "SetCommand",
    "FormatCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NONE, Command_FormatCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

template<typename T> struct CommandTraits {
  static const Command enum_value = Command_NONE;
};

template<> struct CommandTraits<ipc::SetCommand> {
  static const Command enum_value = Command_SetCommand;
};

template<> struct CommandTraits<ipc::FormatCommand> {
  static const Command enum_value = Command_FormatCommand;
};

bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type);
bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OK = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Ack::VT_ID, id, 0);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Ack::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    bool ok = false) {
  AckBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOTAL_SIZE = 6,
    VT_OFFSET = 8,
    VT_DATA = 10,
    VT_MSG_TYPE = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint32_t total_size() const {
    return GetField<uint32_t>(VT_TOTAL_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint32_t msg_type() const {
    return GetField<uint32_t>(VT_MSG_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_MSG_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Chunk::VT_ID, id, 0);
  }
  void add_total_size(uint32_t total_size) {
    fbb_.AddElement<uint32_t>(Chunk::VT_TOTAL_SIZE, total_size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Chunk::VT_OFFSET, offset, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Chunk::VT_DATA, data);
  }
  void add_msg_type(uint32_t msg_type) {
    fbb_.AddElement<uint32_t>(Chunk::VT_MSG_TYPE, msg_type, 0);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t msg_type = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg_type(msg_type);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_total_size(total_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chunk> CreateChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t msg_type = 0) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return ipc::CreateChunk(
      _fbb,
      id,
      total_size,
      offset,
      data__,
      msg_type);
}

struct SetRefCacheRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRefCacheRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ipc::types::Any *val() const {
    return GetPointer<const ipc::types::Any *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyTable(val()) &&
           verifier.EndTable();
  }
};

struct SetRefCacheRequestBuilder {
  typedef SetRefCacheRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(SetRefCacheRequest::VT_KEY, key);
  }
  void add_val(::flatbuffers::Offset<ipc::types::Any> val) {
    fbb_.AddOffset(SetRefCacheRequest::VT_VAL, val);
  }
  explicit SetRefCacheRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRefCacheRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRefCacheRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<ipc::types::Any> val = 0) {
  SetRefCacheRequestBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    ::flatbuffers::Offset<ipc::types::Any> val = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return ipc::CreateSetRefCacheRequest(
      _fbb,
      key__,
      val);
}

struct SetCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_VALUE = 6
  };
  const ipc::types::Range *target() const {
    return GetPointer<const ipc::types::Range *>(VT_TARGET);
  }
  const ipc::types::Any *value() const {
    return GetPointer<const ipc::types::Any *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct SetCommandBuilder {
  typedef SetCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<ipc::types::Range> target) {
    fbb_.AddOffset(SetCommand::VT_TARGET, target);
  }
  void add_value(::flatbuffers::Offset<ipc::types::Any> value) {
    fbb_.AddOffset(SetCommand::VT_VALUE, value);
  }
  explicit SetCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetCommand> CreateSetCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ipc::types::Range> target = 0,
    ::flatbuffers::Offset<ipc::types::Any> value = 0) {
  SetCommandBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_target(target);
  return builder_.Finish();
}

struct FormatCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FormatCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_FORMAT = 6
  };
  const ipc::types::Range *target() const {
    return GetPointer<const ipc::types::Range *>(VT_TARGET);
  }
  const ::flatbuffers::String *format() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_FORMAT) &&
           verifier.VerifyString(format()) &&
           verifier.EndTable();
  }
};

struct FormatCommandBuilder {
  typedef FormatCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<ipc::types::Range> target) {
    fbb_.AddOffset(FormatCommand::VT_TARGET, target);
  }
  void add_format(::flatbuffers::Offset<::flatbuffers::String> format) {
    fbb_.AddOffset(FormatCommand::VT_FORMAT, format);
  }
  explicit FormatCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FormatCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FormatCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ipc::types::Range> target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> format = 0) {
  FormatCommandBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FormatCommand> CreateFormatCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ipc::types::Range> target = 0,
    const char *format = nullptr) {
  auto format__ = format ? _fbb.CreateString(format) : 0;
  return ipc::CreateFormatCommand(
      _fbb,
      target,
      format__);
}

struct CommandWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CMD_TYPE = 4,
    VT_CMD = 6
  };
  ipc::Command cmd_type() const {
    return static_cast<ipc::Command>(GetField<uint8_t>(VT_CMD_TYPE, 0));
  }
  const void *cmd() const {
    return GetPointer<const void *>(VT_CMD);
  }
  template<typename T> const T *cmd_as() const;
  const ipc::SetCommand *cmd_as_SetCommand() const {
    return cmd_type() == ipc::Command_SetCommand ? static_cast<const ipc::SetCommand *>(cmd()) : nullptr;
  }
  const ipc::FormatCommand *cmd_as_FormatCommand() const {
    return cmd_type() == ipc::Command_FormatCommand ? static_cast<const ipc::FormatCommand *>(cmd()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CMD_TYPE, 1) &&
           VerifyOffset(verifier, VT_CMD) &&
           VerifyCommand(verifier, cmd(), cmd_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ipc::SetCommand *CommandWrapper::cmd_as<ipc::SetCommand>() const {
  return cmd_as_SetCommand();
}

template<> inline const ipc::FormatCommand *CommandWrapper::cmd_as<ipc::FormatCommand>() const {
  return cmd_as_FormatCommand();
}

struct CommandWrapperBuilder {
  typedef CommandWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cmd_type(ipc::Command cmd_type) {
    fbb_.AddElement<uint8_t>(CommandWrapper::VT_CMD_TYPE, static_cast<uint8_t>(cmd_type), 0);
  }
  void add_cmd(::flatbuffers::Offset<void> cmd) {
    fbb_.AddOffset(CommandWrapper::VT_CMD, cmd);
  }
  explicit CommandWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandWrapper> CreateCommandWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ipc::Command cmd_type = ipc::Command_NONE,
    ::flatbuffers::Offset<void> cmd = 0) {
  CommandWrapperBuilder builder_(_fbb);
  builder_.add_cmd(cmd);
  builder_.add_cmd_type(cmd_type);
  return builder_.Finish();
}

struct CalculationEndedResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CalculationEndedResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::CommandWrapper>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::CommandWrapper>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct CalculationEndedResponseBuilder {
  typedef CalculationEndedResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::CommandWrapper>>> commands) {
    fbb_.AddOffset(CalculationEndedResponse::VT_COMMANDS, commands);
  }
  explicit CalculationEndedResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CalculationEndedResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CalculationEndedResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::CommandWrapper>>> commands = 0) {
  CalculationEndedResponseBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CalculationEndedResponse> CreateCalculationEndedResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ipc::CommandWrapper>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<ipc::CommandWrapper>>(*commands) : 0;
  return ipc::CreateCalculationEndedResponse(
      _fbb,
      commands__);
}

struct AsyncResult FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsyncResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HANDLE = 4,
    VT_RESULT_TYPE = 6,
    VT_RESULT = 8,
    VT_ERROR = 10
  };
  uint64_t handle() const {
    return GetField<uint64_t>(VT_HANDLE, 0);
  }
  ipc::types::AnyValue result_type() const {
    return static_cast<ipc::types::AnyValue>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const ipc::types::Bool *result_as_Bool() const {
    return result_type() == ipc::types::AnyValue_Bool ? static_cast<const ipc::types::Bool *>(result()) : nullptr;
  }
  const ipc::types::Num *result_as_Num() const {
    return result_type() == ipc::types::AnyValue_Num ? static_cast<const ipc::types::Num *>(result()) : nullptr;
  }
  const ipc::types::Int *result_as_Int() const {
    return result_type() == ipc::types::AnyValue_Int ? static_cast<const ipc::types::Int *>(result()) : nullptr;
  }
  const ipc::types::Str *result_as_Str() const {
    return result_type() == ipc::types::AnyValue_Str ? static_cast<const ipc::types::Str *>(result()) : nullptr;
  }
  const ipc::types::Err *result_as_Err() const {
    return result_type() == ipc::types::AnyValue_Err ? static_cast<const ipc::types::Err *>(result()) : nullptr;
  }
  const ipc::types::AsyncHandle *result_as_AsyncHandle() const {
    return result_type() == ipc::types::AnyValue_AsyncHandle ? static_cast<const ipc::types::AsyncHandle *>(result()) : nullptr;
  }
  const ipc::types::Nil *result_as_Nil() const {
    return result_type() == ipc::types::AnyValue_Nil ? static_cast<const ipc::types::Nil *>(result()) : nullptr;
  }
  const ipc::types::Grid *result_as_Grid() const {
    return result_type() == ipc::types::AnyValue_Grid ? static_cast<const ipc::types::Grid *>(result()) : nullptr;
  }
  const ipc::types::NumGrid *result_as_NumGrid() const {
    return result_type() == ipc::types::AnyValue_NumGrid ? static_cast<const ipc::types::NumGrid *>(result()) : nullptr;
  }
  const ipc::types::Range *result_as_Range() const {
    return result_type() == ipc::types::AnyValue_Range ? static_cast<const ipc::types::Range *>(result()) : nullptr;
  }
  const ipc::types::RefCache *result_as_RefCache() const {
    return result_type() == ipc::types::AnyValue_RefCache ? static_cast<const ipc::types::RefCache *>(result()) : nullptr;
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_HANDLE, 8) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyAnyValue(verifier, result(), result_type()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

template<> inline const ipc::types::Bool *AsyncResult::result_as<ipc::types::Bool>() const {
  return result_as_Bool();
}

template<> inline const ipc::types::Num *AsyncResult::result_as<ipc::types::Num>() const {
  return result_as_Num();
}

template<> inline const ipc::types::Int *AsyncResult::result_as<ipc::types::Int>() const {
  return result_as_Int();
}

template<> inline const ipc::types::Str *AsyncResult::result_as<ipc::types::Str>() const {
  return result_as_Str();
}

template<> inline const ipc::types::Err *AsyncResult::result_as<ipc::types::Err>() const {
  return result_as_Err();
}

template<> inline const ipc::types::AsyncHandle *AsyncResult::result_as<ipc::types::AsyncHandle>() const {
  return result_as_AsyncHandle();
}

template<> inline const ipc::types::Nil *AsyncResult::result_as<ipc::types::Nil>() const {
  return result_as_Nil();
}

template<> inline const ipc::types::Grid *AsyncResult::result_as<ipc::types::Grid>() const {
  return result_as_Grid();
}

template<> inline const ipc::types::NumGrid *AsyncResult::result_as<ipc::types::NumGrid>() const {
  return result_as_NumGrid();
}

template<> inline const ipc::types::Range *AsyncResult::result_as<ipc::types::Range>() const {
  return result_as_Range();
}

template<> inline const ipc::types::RefCache *AsyncResult::result_as<ipc::types::RefCache>() const {
  return result_as_RefCache();
}

struct AsyncResultBuilder {
  typedef AsyncResult Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_handle(uint64_t handle) {
    fbb_.AddElement<uint64_t>(AsyncResult::VT_HANDLE, handle, 0);
  }
  void add_result_type(ipc::types::AnyValue result_type) {
    fbb_.AddElement<uint8_t>(AsyncResult::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(::flatbuffers::Offset<void> result) {
    fbb_.AddOffset(AsyncResult::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(AsyncResult::VT_ERROR, error);
  }
  explicit AsyncResultBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsyncResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsyncResult>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResult(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t handle = 0,
    ipc::types::AnyValue result_type = ipc::types::AnyValue_NONE,
    ::flatbuffers::Offset<void> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  AsyncResultBuilder builder_(_fbb);
  builder_.add_handle(handle);
  builder_.add_error(error);
  builder_.add_result(result);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AsyncResult> CreateAsyncResultDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t handle = 0,
    ipc::types::AnyValue result_type = ipc::types::AnyValue_NONE,
    ::flatbuffers::Offset<void> result = 0,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return ipc::CreateAsyncResult(
      _fbb,
      handle,
      result_type,
      result,
      error__);
}

struct BatchAsyncResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchAsyncResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::AsyncResult>> *results() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ipc::AsyncResult>> *>(VT_RESULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULTS) &&
           verifier.VerifyVector(results()) &&
           verifier.VerifyVectorOfTables(results()) &&
           verifier.EndTable();
  }
};

struct BatchAsyncResponseBuilder {
  typedef BatchAsyncResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_results(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::AsyncResult>>> results) {
    fbb_.AddOffset(BatchAsyncResponse::VT_RESULTS, results);
  }
  explicit BatchAsyncResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchAsyncResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchAsyncResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ipc::AsyncResult>>> results = 0) {
  BatchAsyncResponseBuilder builder_(_fbb);
  builder_.add_results(results);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchAsyncResponse> CreateBatchAsyncResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ipc::AsyncResult>> *results = nullptr) {
  auto results__ = results ? _fbb.CreateVector<::flatbuffers::Offset<ipc::AsyncResult>>(*results) : 0;
  return ipc::CreateBatchAsyncResponse(
      _fbb,
      results__);
}

struct AddRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6
  };
  double a() const {
    return GetField<double>(VT_A, 0.0);
  }
  double b() const {
    return GetField<double>(VT_B, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_A, 8) &&
           VerifyField<double>(verifier, VT_B, 8) &&
           verifier.EndTable();
  }
};

struct AddRequestBuilder {
  typedef AddRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(double a) {
    fbb_.AddElement<double>(AddRequest::VT_A, a, 0.0);
  }
  void add_b(double b) {
    fbb_.AddElement<double>(AddRequest::VT_B, b, 0.0);
  }
  explicit AddRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddRequest> CreateAddRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double a = 0.0,
    double b = 0.0) {
  AddRequestBuilder builder_(_fbb);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct AddResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_ERROR = 6
  };
  double result() const {
    return GetField<double>(VT_RESULT, 0.0);
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RESULT, 8) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct AddResponseBuilder {
  typedef AddResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(double result) {
    fbb_.AddElement<double>(AddResponse::VT_RESULT, result, 0.0);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(AddResponse::VT_ERROR, error);
  }
  explicit AddResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddResponse> CreateAddResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  AddResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_error(error);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AddResponse> CreateAddResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0,
    const char *error = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return ipc::CreateAddResponse(
      _fbb,
      result,
      error__);
}

inline bool VerifyCommand(::flatbuffers::Verifier &verifier, const void *obj, Command type) {
  switch (type) {
    case Command_NONE: {
      return true;
    }
    case Command_SetCommand: {
      auto ptr = reinterpret_cast<const ipc::SetCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Command_FormatCommand: {
      auto ptr = reinterpret_cast<const ipc::FormatCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCommandVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommand(
        verifier,  values->Get(i), types->GetEnum<Command>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace ipc

#endif  // FLATBUFFERS_GENERATED_SCHEMA_IPC_H_
