# xll-gen Design Document

## 1. Overview
`xll-gen` is a CLI tool designed to facilitate the creation of Excel Add-ins (XLL) using languages that are traditionally difficult to compile into DLLs or have runtime limitations in that context, such as Go.

### Core Philosophy
- **Language Agnostic Architecture**: Uses an out-of-process model. Excel (via a C++ shim) communicates with a standalone server process (e.g., written in Go) using Shared Memory.
- **Wails-like Experience**: Provides a seamless developer experience with commands like `init`, `build`, and `dev`. The complexity of C++ compilation and IPC is wrapped but remains transparent.
- **Non-Intrusive**: User logic resides in `main` code. The tool generates boilerplate in separate directories/packages that the user imports. Re-generation does not overwrite user logic.

## 2. Architecture

### Components
1.  **Excel Process**: Loads the generated XLL (C++).
2.  **XLL (C++ Shim)**:
    -   Auto-generated.
    -   Registers functions with Excel.
    -   Manages the lifecycle of the sidecar process (the User Server).
    -   Serializes Excel arguments to **Flatbuffers**.
    -   Writes to **Shared Memory** (`xll-gen/shm`).
    -   Signals the server and waits for a response.
3.  **User Server (Go)**:
    -   Standalone executable.
    -   Uses generated IPC handling code.
    -   Listens on Shared Memory.
    -   Deserializes requests, routes them to the User's Implementation (Handler).
    -   Serializes responses and signals back to Excel.

### IPC Protocol
-   **Transport**: Shared Memory (Low latency, high throughput).
-   **Serialization**: Google Flatbuffers.
-   **Schema**: Dynamically generated based on user configuration.

## 3. Configuration (`xll.yaml`)

The project is defined by a `xll.yaml` file. This is the source of truth for code generation.

```yaml
project:
  name: "my-quant-lib"
  version: "0.1.0"

# Code generation settings
gen:
  go:
    package: "generated"

# Function Definitions
functions:
  - name: "Add"
    description: "Adds two integers"
    args:
      - name: "a"
        type: "int"
        description: "First number"
      - name: "b"
        type: "int"
        description: "Second number"
    return: "int"
    volatile: false

  - name: "GetPrice"
    description: "Fetches price for a ticker"
    args:
      - name: "ticker"
        type: "string"
    return: "float"
    async: true  # Future support for async/calc
```

## 4. Project Structure

Running `xll-gen init` creates:

```text
my-project/
├── xll.yaml            # Configuration
├── main.go             # User entry point
├── go.mod
├── generated/          # [DO NOT EDIT] Generated by xll-gen
│   ├── xltypes.fbs     # Generated Excel type definitions
│   ├── schema.fbs      # Generated Flatbuffers schema
│   ├── types.go        # Generated Go types
│   ├── server.go       # Generated Go server logic
│   ├── interface.go    # Generated Go interface
│   └── cpp/            # Generated C++ XLL source
│       ├── xll_main.cpp
│       └── flatbuffers/
└── build/              # Output directory
```

## 5. Developer Experience (CLI)

The CLI is written in Go and uses `cobra`.

### Commands

#### `init`
Scaffolds a new project.
```bash
xll-gen init my-project
```

#### `generate`
Reads `xll.yaml` and updates the `generated/` directory.
1.  Parses `xll.yaml`.
2.  Generates `xltypes.fbs` (Standard Excel types).
3.  Generates `schema.fbs`.
4.  Runs `flatc` (embedded or managed) to generate Go and C++ serialization code.
4.  Generates `interface.go` (Go interface for user to implement).
5.  Generates `xll_main.cpp` (C++ Excel registration and IPC logic).

#### `build`
Wraps the build process for both the Go server and the C++ XLL.
1.  Runs `generate`.
2.  **Go Build**: Compiles `main.go` -> `build/my-project.exe`.
3.  **C++ Build**: Detects available compiler (MSVC, MinGW) and compiles `generated/cpp` -> `build/my-project.xll`.
    -   *Transparency*: Displays the actual commands being executed (like `cl.exe ...` or `go build ...`).

#### `clean`
Removes `build/` and `generated/`.

#### `doctor`
Diagnoses the environment, specifically checking for the presence of a C++ compiler.
1. Checks for `cl.exe` (MSVC).
2. Checks for `g++` or `gcc` (MinGW).
3. If no compiler is found, it suggests installation via `winget`.
4. Checks for the presence of `flatc`. If missing, attempts to download the correct version.

## 6. Implementation Details

### User Code Integration (Go)

The user works in `main.go`. The CLI generates an interface in the generated package.

**Generated Interface (`generated/interface.go`):**
```go
package generated

type XllService interface {
    Add(a int32, b int32) (int32, error)
    GetPrice(ticker string) (float64, error)
}

func Serve(handler XllService) {
    // IPC loop implementation
}
```

**User Main (`main.go`):**
```go
package main

import (
    "my-project/generated"
)

type MyService struct{}

func (s *MyService) Add(a int32, b int32) (int32, error) {
    return a + b, nil
}

func (s *MyService) GetPrice(ticker string) (float64, error) {
    return 100.50, nil // Mock
}

func main() {
    // Connects to SHM and starts processing
    generated.Serve(&MyService{})
}
```

### C++ Generation Strategy
The C++ code must bridge Excel's `XLOPER12` types to Flatbuffers.
-   The generator creates a static C++ mapping based on types defined in `xll.yaml`.
-   Uses `xll-gen/shm` C++ library to write to the shared memory buffer.

### Build System
-   The CLI mimics `make` or `task` logic internally.
-   **Flatbuffers Compiler (`flatc`)**:
    -   The CLI automatically manages `flatc`.
    -   It detects the latest release from [Google Flatbuffers Releases](https://github.com/google/flatbuffers/releases) (e.g., v25.9.23).
    -   Downloads and caches the binary if not present on the system.
-   **C++ Compiler**:
    -   It must locate C++ compilers.
    -   Priority: MSVC (cl.exe) -> MinGW (g++) -> Clang.
    -   **Recommendation**: Users can easily install a compatible MinGW toolchain using `winget`:
        ```bash
        winget install -e --id BrechtSanders.WinLibs.POSIX.UCRT
        ```
-   Outputs explicit build steps to stdout for debugging/transparency.

## 7. Future Considerations
-   Support for Java/Node.js by adding `gen.java` or `gen.js` in `xll.yaml`.
-   Hot reloading (Go server restart without unloading XLL).
-   Async function support in Excel (handling long-running Go tasks).

## 8. Reference: Excel Internals

This section details the specific C API constructs used by the generated C++ code. It serves as the primary reference for agents generating registration and memory management logic.

### 8.1 xlfRegister & Data Types (`pxTypeText`)

When registering functions using `xlfRegister`, the `pxTypeText` string defines the return type and argument types. We exclusively use **XLOPER12** (Excel 2007+) types.

**Canonical Type Codes**
For types with multiple representation options, we stick to the following canonical choices to ensure consistency.

| Data Type | Code | C type | Description |
| :--- | :--- | :--- | :--- |
| **Boolean** | `A` | `short` | 0=false, 1=true. |
| **Double** | `B` | `double` | IEEE 8-byte floating point. |
| **Int** | `J` | `int32_t` | 32-bit signed integer. |
| **String** | `D%` | `const wchar_t *` | Counted Unicode wide-character string (Pascal). |
| **Array (FP)** | `K%` | `FP12 *` | Floating-point array structure. Efficient for math. |
| **Any (Value)** | `Q` | `XLOPER12 *` | Pointer to XLOPER12. Dereferences references (Pass by Value). |
| **Any (Ref)** | `U` | `XLOPER12 *` | Pointer to XLOPER12. Allows references (Range). |
| **Async** | `X` | `void *` | Async handle (Excel 2010+). |

**Strict Value Policy:**
We do **not** use optional/nullable scalar pointer types (e.g., `int?` -> `N` (int*), `float?` -> `E` (double*), `bool?` -> `L` (short*)).
*   **Reason**: Excel passes a valid pointer to a zero value (0, 0.0, false) for empty cells, making it impossible to distinguish between an explicit zero and a missing argument.
*   **Solution**: Users requiring optional inputs must use `any` (or `scalar`), which receives the raw `XLOPER12`. The generated code or user logic can then check `xltypeMissing` or empty variants.

**Note**: Do not use the legacy 8-bit string types (`C`, `D`, `F`, `G`), `XLOPER` (`P`, `R`), or legacy `FP` (`K`). Always use the wide-char / `12` variants (e.g., `FP12` / `K%`).

**Thread Safety (`$`)**
Starting in Excel 2007, Excel can perform multithreaded workbook recalculation. Unless there is a specific reason to not support it, **all generated functions should be registered as thread-safe**.
To do this, append a `$` character to the end of the `pxTypeText` string.
*   Example: `QJJ$` (Returns Value, takes two Ints, Thread-Safe).

**Registration Arguments (Form 1)**
The generator implements `xlfRegister` (Form 1) fully, passing:
1.  `module_text` (DLL name)
2.  `procedure` (Export name)
3.  `type_text` (Type string, e.g., `QJJ$`)
4.  `function_text` (Function name)
5.  `argument_text` (Comma-separated argument names)
6.  `macro_type` (1 = Function)
7.  `category` (Default: Project Name)
8.  `shortcut_text` (Optional)
9.  `help_topic` (Optional)
10. `function_help` (Description)
11. `argument_help1` (Arg 1 Description)
...

### 8.2 Memory Management

Proper memory management is critical to prevent Excel crashes.

**Rules:**
1.  **Inputs are Read-Only**: Arguments passed to the XLL function must never be freed or modified.
2.  **Returning DLL-Allocated Memory**: When the XLL returns an `XLOPER12` that points to memory allocated by the DLL (e.g., a string):
    -   Set `xltype` to `type | xlbitDLLFree`.
    -   Implement the `xlAutoFree12` callback.
    -   Use the provided `xll_mem` library helpers (`NewExcelString`, `NewXLOPER12`) which use a thread-safe object pool and `xlAutoFree12` implementation.
3.  **Pascal Strings**: We use `D%` for string inputs (counted wide string). For returns, we use `Q` (XLOPER12) wrapping a counted wide string with `xlbitDLLFree`.


### 8.3 Error Codes (`xlCVError`)

When returning errors from the XLL (e.g., if the Go server is unreachable), return an `XLOPER12` with `xltype = xltypeErr` and one of the following integer codes.

| Error Name | Value | Description |
| :--- | :--- | :--- |
| `xlErrNull` | `2000` | Null intersection |
| `xlErrDiv0` | `2007` | Division by zero |
| `xlErrValue` | `2015` | Invalid value |
| `xlErrRef` | `2023` | Invalid reference |
| `xlErrName` | `2029` | Invalid name |
| `xlErrNum` | `2036` | Invalid number |
| `xlErrNA` | `2042` | Value not available |
| `xlErrGettingData` | `2043` | Getting Data (Async) |
| `xlErrSpill` | `2045` | Spill error |
| `xlErrConnect` | `2046` | Connection error |
| `xlErrBlocked` | `2047` | Blocked error |
| `xlErrUnknown` | `2048` | Unknown error |
| `xlErrField` | `2049` | Field error |
| `xlErrCalc` | `2050` | Calculation error |

### 8.4 Event Handlers

Starting with Excel 2010, `xlEventRegister` allows XLLs to register for specific system events, primarily to manage the lifecycle of asynchronous user-defined functions (UDFs).

**Supported Events:**
*   `CalculationEnded` (Code 1): Raised when Excel completes a calculation cycle. Useful for freeing resources allocated during async calculations.
*   `CalculationCanceled` (Code 2): Raised when the user interrupts the calculation (e.g., via ESC). The XLL should abort pending async activities.

**Configuration (`xll.yaml`):**
```yaml
events:
  - type: "CalculationEnded"
    name: "OnCalculationEnded"
```
This generates a corresponding C++ handler that forwards the event to the Go server.

**Command Scheduling**:
The Go server allows scheduling Excel commands to be executed by the C++ XLL during the `CalculationEnded` event.
*   The Go server maintains a queue of commands (`ScheduleSet`, `ScheduleFormat`).
*   When `CalculationEnded` is triggered, the Go server serializes these commands into the response.
*   The C++ XLL receives the response and executes the commands using `xlSet` and `xlcFormatNumber`.

## 9. Reference: Shared Memory (IPC)

The `xll-gen/shm` library provides low-latency IPC. For maximum performance, we use **Zero-Copy** operations where possible, especially for FlatBuffers.

### 9.1 Zero-Copy (C++ Host)

Instead of building a FlatBuffer on the heap and copying it to the shared memory slot, we construct it directly in the slot's request buffer.

```cpp
// 1. Acquire a Zero-Copy Slot
auto slot = host.GetZeroCopySlot();

// 2. Build FlatBuffer directly in shared memory
// slot.GetReqBuffer() returns the pointer to the buffer.
// We pass it to the builder as the initial buffer.
flatbuffers::FlatBufferBuilder builder(
    slot.GetMaxReqSize(),
    nullptr,
    false,
    slot.GetReqBuffer()
);

// ... build your object ...
// auto offset = CreateMyRequest(builder, ...);
// builder.Finish(offset);

// 3. Send Request
// Signals MSG_ID_FLATBUFFER (or user ID) and handles size internally.
slot.SendFlatBuffer(builder.GetSize());

// 4. Access Response Directly (Zero-Copy)
// The response is available in the response buffer immediately after Send returns.
uint8_t* respData = slot.GetRespBuffer();
int32_t respSize = slot.GetRespSize();
```

### 9.2 Zero-Copy (Go Guest)

The Go client handler receives a slice that points directly to the shared memory region. Reading from `req` is zero-copy.

```go
client.Handle(func(req []byte, respBuf []byte, msgId uint32) int32 {
    // 'req' points to the shared memory slot payload.
    // It is safe to read directly (e.g., using FlatBuffers GetRootAs...).

    if msgId == shm.MsgIdFlatbuffer {
        // processFlatBuffer(req)
    }

    // Write response to respBuf
    // ...
    return bytesWritten
})
```

## 10. Agent Guidelines

*   **Documentation Updates**: When modifying features or adding new capabilities, you must update the relevant documentation (e.g., `README.md`, `AGENTS.md`) to reflect the changes.
*   **Language Policy**: All documentation, code comments, commit messages, and other project-related text must be in English.
*   **Versioning**: The version of `xll-gen` is defined in `version/version.go`. All generated files (C++, Go, CMake, etc.) must include a header comment indicating the version of `xll-gen` that created them. This helps in debugging and ensures users know when their artifacts are out of date.
*   **Testing**: When applying changes due to upstream library updates (e.g., `shm` API changes), ensure that any outdated or incompatible tests are updated or deleted if they are no longer relevant.

## 11. Development Workflow

*   **Temporary Projects**: Use directories starting with `temp_` (e.g., `temp_verify`, `temp_test`) for creating temporary test projects. These are git-ignored to prevent accidental commits of artifacts.

## 12. Tag Message Guidelines

When creating a tag message, adhere to the following format:

1.  **Major Changes Summary**: Group major changes by category (e.g., Performance, Feature, Fix). Summarize the change and include the commit hash.
2.  **Detailed Commit List**: List all commits (including those not in the summary) with their commit message and hash.
3.  **Hyperlinks**: Ensure every commit hash is a hyperlink.

**Example:**

```text
### Features
* Added async support ([1a2b3c](http://url...))

### Performance
* Optimized IPC ([4d5e6f](http://url...))

### All Commits
* [1a2b3c](http://url...) Added async support
* [4d5e6f](http://url...) Optimized IPC
* [7g8h9i](http://url...) Fixed typo in README
```