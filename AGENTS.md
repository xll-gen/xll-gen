# xll-gen Design Document

## 1. Overview
`xll-gen` is a CLI tool designed to facilitate the creation of Excel Add-ins (XLL) using languages that are traditionally difficult to compile into DLLs or have runtime limitations in that context, such as Go.

### Core Philosophy
- **Language Agnostic Architecture**: Uses an out-of-process model. Excel (via a C++ shim) communicates with a standalone server process (e.g., written in Go) using Shared Memory.
- **Wails-like Experience**: Provides a seamless developer experience with commands like `init`, `build`, and `dev`. The complexity of C++ compilation and IPC is wrapped but remains transparent.
- **Non-Intrusive**: User logic resides in `main` code. The tool generates boilerplate in separate directories/packages that the user imports. Re-generation does not overwrite user logic.

## 2. Architecture

### Components
1.  **Excel Process**: Loads the generated XLL (C++).
2.  **XLL (C++ Shim)**:
    -   Auto-generated.
    -   Registers functions with Excel.
    -   Manages the lifecycle of the sidecar process (the User Server).
    -   Serializes Excel arguments to **Flatbuffers**.
    -   Writes to **Shared Memory** (`xll-gen/shm`).
    -   Signals the server and waits for a response.
3.  **User Server (Go)**:
    -   Standalone executable.
    -   Uses generated IPC handling code.
    -   Listens on Shared Memory.
    -   Deserializes requests, routes them to the User's Implementation (Handler).
    -   Serializes responses and signals back to Excel.

### IPC Protocol
-   **Transport**: Shared Memory (Low latency, high throughput).
-   **Serialization**: Google Flatbuffers.
-   **Schema**: Dynamically generated based on user configuration.

## 3. Configuration (`xll.yaml`)

The project is defined by a `xll.yaml` file. This is the source of truth for code generation.

```yaml
project:
  name: "my-quant-lib"
  version: "0.1.0"

# Code generation settings
gen:
  go:
    package: "generated"

# Function Definitions
functions:
  - name: "Add"
    description: "Adds two integers"
    args:
      - name: "a"
        type: "int"
        description: "First number"
      - name: "b"
        type: "int"
        description: "Second number"
    return: "int"
    volatile: false

  - name: "GetPrice"
    description: "Fetches price for a ticker"
    args:
      - name: "ticker"
        type: "string"
    return: "float"
    async: true  # Future support for async/calc
```

## 4. Project Structure

Running `xll-gen init` creates:

```text
my-project/
├── xll.yaml            # Configuration
├── main.go             # User entry point
├── go.mod
├── generated/          # [DO NOT EDIT] Generated by xll-gen
│   ├── schema.fbs      # Generated Flatbuffers schema
│   ├── types.go        # Generated Go types
│   ├── server.go       # Generated Go server logic
│   ├── interface.go    # Generated Go interface
│   └── cpp/            # Generated C++ XLL source
│       ├── xll_main.cpp
│       └── flatbuffers/
└── build/              # Output directory
```

## 5. Developer Experience (CLI)

The CLI is written in Go and uses `cobra`.

### Commands

#### `init`
Scaffolds a new project.
```bash
xll-gen init my-project
```

#### `generate`
Reads `xll.yaml` and updates the `generated/` directory.
1.  Parses `xll.yaml`.
2.  Generates `schema.fbs`.
3.  Runs `flatc` (embedded or managed) to generate Go and C++ serialization code.
4.  Generates `interface.go` (Go interface for user to implement).
5.  Generates `xll_main.cpp` (C++ Excel registration and IPC logic).

#### `build`
Wraps the build process for both the Go server and the C++ XLL.
1.  Runs `generate`.
2.  **Go Build**: Compiles `main.go` -> `build/my-project.exe`.
3.  **C++ Build**: Detects available compiler (MSVC, MinGW) and compiles `generated/cpp` -> `build/my-project.xll`.
    -   *Transparency*: Displays the actual commands being executed (like `cl.exe ...` or `go build ...`).

#### `clean`
Removes `build/` and `generated/`.

#### `doctor`
Diagnoses the environment, specifically checking for the presence of a C++ compiler.
1. Checks for `cl.exe` (MSVC).
2. Checks for `g++` or `gcc` (MinGW).
3. If no compiler is found, it suggests installation via `winget`.
4. Checks for the presence of `flatc`. If missing, attempts to download the correct version.

## 6. Implementation Details

### User Code Integration (Go)

The user works in `main.go`. The CLI generates an interface in the generated package.

**Generated Interface (`generated/interface.go`):**
```go
package generated

type XllService interface {
    Add(a int32, b int32) (int32, error)
    GetPrice(ticker string) (float64, error)
}

func Serve(handler XllService) {
    // IPC loop implementation
}
```

**User Main (`main.go`):**
```go
package main

import (
    "my-project/generated"
)

type MyService struct{}

func (s *MyService) Add(a int32, b int32) (int32, error) {
    return a + b, nil
}

func (s *MyService) GetPrice(ticker string) (float64, error) {
    return 100.50, nil // Mock
}

func main() {
    // Connects to SHM and starts processing
    generated.Serve(&MyService{})
}
```

### C++ Generation Strategy
The C++ code must bridge Excel's `XLOPER12` types to Flatbuffers.
-   The generator creates a static C++ mapping based on types defined in `xll.yaml`.
-   Uses `xll-gen/shm` C++ library to write to the shared memory buffer.

### Build System
-   The CLI mimics `make` or `task` logic internally.
-   **Flatbuffers Compiler (`flatc`)**:
    -   The CLI automatically manages `flatc`.
    -   It detects the latest release from [Google Flatbuffers Releases](https://github.com/google/flatbuffers/releases) (e.g., v25.9.23).
    -   Downloads and caches the binary if not present on the system.
-   **C++ Compiler**:
    -   It must locate C++ compilers.
    -   Priority: MSVC (cl.exe) -> MinGW (g++) -> Clang.
    -   **Recommendation**: Users can easily install a compatible MinGW toolchain using `winget`:
        ```bash
        winget install -e --id BrechtSanders.WinLibs.POSIX.UCRT
        ```
-   Outputs explicit build steps to stdout for debugging/transparency.

## 7. Future Considerations
-   Support for Java/Node.js by adding `gen.java` or `gen.js` in `xll.yaml`.
-   Hot reloading (Go server restart without unloading XLL).
-   Async function support in Excel (handling long-running Go tasks).

## 8. Reference: Excel Internals

This section details the specific C API constructs used by the generated C++ code. It serves as the primary reference for agents generating registration and memory management logic.

### 8.1 xlfRegister & Data Types (`pxTypeText`)

When registering functions using `xlfRegister`, the `pxTypeText` string defines the return type and argument types. We exclusively use **XLOPER12** (Excel 2007+) types.

**Canonical Type Codes**
For types with multiple representation options, we stick to the following canonical choices to ensure consistency.

| Data Type | Code | C type | Description |
| :--- | :--- | :--- | :--- |
| **Boolean** | `A` | `short` | 0=false, 1=true. |
| **Double** | `B` | `double` | IEEE 8-byte floating point. |
| **Int** | `J` | `int32_t` | 32-bit signed integer. |
| **String** | `C%` | `const wchar_t *` | Null-terminated Unicode wide-character string. |
| **Array (FP)** | `K%` | `FP12 *` | Floating-point array structure. Efficient for math. |
| **Any (Value)** | `Q` | `XLOPER12 *` | Pointer to XLOPER12. Dereferences references (Pass by Value). |
| **Any (Ref)** | `U` | `XLOPER12 *` | Pointer to XLOPER12. Allows references (Range). |
| **Async** | `X` | `void *` | Async handle (Excel 2010+). |

**Note**: Do not use the legacy 8-bit string types (`C`, `D`, `F`, `G`), `XLOPER` (`P`, `R`), or legacy `FP` (`K`). Always use the wide-char / `12` variants (e.g., `FP12` / `K%`).

### 8.2 Memory Management

Proper memory management is critical to prevent Excel crashes.

**Rules:**
1.  **Inputs are Read-Only**: Arguments passed to the XLL function must never be freed or modified (unless registered as modify-in-place, which we avoid for general safety).
2.  **Returning DLL-Allocated Memory**: When the XLL returns an `XLOPER12` that points to memory allocated by the DLL (e.g., a string or array created via `malloc`/`new`):
    -   Set `xltype` to `type | xlbitDLLFree`.
    -   Implement the `xlAutoFree12` callback in the XLL.
    -   Excel will call `xlAutoFree12` when it is done with the return value.
3.  **xlAutoFree12**: This function must identify what to free. Typically, it checks if `xlbitDLLFree` is set, and then frees the pointer in `val.str` or `val.array.lparray`, and finally the `XLOPER12` pointer itself if it was dynamically allocated.
4.  **Avoid xlbitXLFree**: This bit is reserved for memory allocated by Excel (e.g., return values from C API callbacks like `xlfGetName`). If you receive such memory, make a deep copy if you need to keep it, then call `xlFree`.

### 8.3 Error Codes (`xlCVError`)

When returning errors from the XLL (e.g., if the Go server is unreachable), return an `XLOPER12` with `xltype = xltypeErr` and one of the following integer codes.

| Error Name | Value | Description |
| :--- | :--- | :--- |
| `xlErrNull` | `2000` | Null intersection |
| `xlErrDiv0` | `2007` | Division by zero |
| `xlErrValue` | `2015` | Invalid value |
| `xlErrRef` | `2023` | Invalid reference |
| `xlErrName` | `2029` | Invalid name |
| `xlErrNum` | `2036` | Invalid number |
| `xlErrNA` | `2042` | Value not available |
| `xlErrGettingData` | `2043` | Getting Data (Async) |
| `xlErrSpill` | `2045` | Spill error |
| `xlErrConnect` | `2046` | Connection error |
| `xlErrBlocked` | `2047` | Blocked error |
| `xlErrUnknown` | `2048` | Unknown error |
| `xlErrField` | `2049` | Field error |
| `xlErrCalc` | `2050` | Calculation error |
