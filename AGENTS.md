# xll-gen Design Document

## 1. Overview
`xll-gen` is a CLI tool designed to facilitate the creation of Excel Add-ins (XLL) using languages that are traditionally difficult to compile into DLLs or have runtime limitations in that context, such as Go.

### Core Philosophy
- **Language Agnostic Architecture**: Uses an out-of-process model. Excel (via a C++ shim) communicates with a standalone server process (e.g., written in Go) using Shared Memory.
- **Wails-like Experience**: Provides a seamless developer experience with commands like `init` and `build`. The complexity of C++ compilation and IPC is wrapped but remains transparent.
- **Non-Intrusive**: User logic resides in `main` code. The tool generates boilerplate in separate directories/packages that the user imports. Re-generation does not overwrite user logic.

## 2. Architecture

### Components
1.  **Excel Process**: Loads the generated XLL (C++).
2.  **XLL (C++ Shim)**:
    -   Auto-generated.
    -   Registers functions with Excel.
    -   Manages the lifecycle of the sidecar process (the User Server).
    -   Serializes Excel arguments to **Flatbuffers**.
    -   Writes to **Shared Memory** (`xll-gen/shm`).
    -   Signals the server and waits for a response.
3.  **User Server (Go)**:
    -   Standalone executable (embedded in XLL in `singlefile` mode).
    -   Uses generated IPC handling code.
    -   Listens on Shared Memory.
    -   Deserializes requests, routes them to the User's Implementation (Handler).
    -   Serializes responses and signals back to Excel.

### IPC Protocol
-   **Transport**: Shared Memory (Low latency, high throughput).
-   **Serialization**: Google Flatbuffers.
-   **Schema**: Dynamically generated based on user configuration.

## 2.1 System Protocol & Schema Pre-generation

To minimize generated code size and improve maintainability, the system-level FlatBuffers definitions (Chunking, Acks, Event responses, Grid types) are extracted into a static schema `pkg/protocol/protocol.fbs`.

**Schema Pre-generation Strategy:**
1.  **Static Protocol:** The `protocol.fbs` file is pre-compiled into the `github.com/xll-gen/xll-gen/pkg/protocol` Go package within the tool's repository. A corresponding C++ header `protocol_generated.h` is also pre-generated and shipped as an asset.
2.  **User Project Dependency:** Generated Go projects import `pkg/protocol` for system types (`protocol.Any`, `protocol.Grid`, etc.).
3.  **Schema Composition:** The user's `schema.fbs` (defining function requests/responses) uses `include "protocol.fbs"`.
4.  **Code Generation:** When `xll-gen generate` runs:
    -   It copies `protocol.fbs` to the user's `generated/` folder.
    -   It runs `flatc` for `schema.fbs`.
    -   It post-processes the generated Go code to replace local `protocol` imports with `github.com/xll-gen/xll-gen/pkg/protocol`.
    -   It skips generating C++ code for `protocol.fbs` (`--no-includes`), relying on the pre-generated `include/protocol_generated.h` asset.
    -   This prevents re-generation of static protocol code in the user's project.

**Benefits:**
-   **Reduced Bloat:** `server.go`, generated IPC code, and C++ sources are smaller.
-   **Centralized Logic:** Complex logic for chunking and batching resides in `pkg/server` (compiled library) rather than templates.
-   **Consistency:** All projects use the exact same protocol implementation.

## 3. Configuration (`xll.yaml`)

The project is defined by a `xll.yaml` file. This is the source of truth for code generation.

```yaml
project:
  name: "my-quant-lib"
  version: "0.1.0"

# Code generation settings
gen:
  go:
    package: "generated"

build:
  singlefile: xll
  temp_dir: "${TEMP}"

logging:
  level: info
  path: "server.log"

server:
  workers: 0
  timeout: "5s"
  launch:
    enabled: true
    # command: "${BIN}" # Default: Resolves to the server executable
    # cwd: "."          # Default: XLL directory (or Temp dir in singlefile)

# Function Definitions
functions:
  - name: "Add"
    description: "Adds two integers"
    args:
      - name: "a"
        type: "int"
        description: "First number"
      - name: "b"
        type: "int"
        description: "Second number"
    return: "int"
    volatile: false

  - name: "GetPrice"
    description: "Fetches price for a ticker"
    args:
      - name: "ticker"
        type: "string"
    return: "float"
    async: true  # Future support for async/calc
```

## 4. Project Structure

Running `xll-gen init` creates:

```text
my-project/
├── xll.yaml            # Configuration
├── main.go             # User entry point
├── go.mod
├── Taskfile.yml        # Build automation
├── generated/          # [DO NOT EDIT] Generated by xll-gen
│   ├── protocol.fbs    # Static System Schema (Copied)
│   ├── schema.fbs      # Generated Flatbuffers schema
│   ├── server.go       # Generated Go server logic
│   ├── interface.go    # Generated Go interface
│   ├── ipc/            # Generated Go types (Flatbuffers)
│   └── cpp/            # Generated C++ XLL source
│       ├── xll_main.cpp
│       ├── schema_generated.h
│       ├── CMakeLists.txt
│       └── include/    # Static C++ assets (Protocol, Utils, etc.)
└── build/              # Output directory
```

## 5. Developer Experience (CLI)

The CLI is written in Go and uses `cobra`.

### Commands

#### `init`
Scaffolds a new project.
```bash
xll-gen init my-project
```

#### `generate`
Reads `xll.yaml` and updates the `generated/` directory.
1.  Parses `xll.yaml`.
2.  Copies `protocol.fbs`.
3.  Generates `schema.fbs`.
4.  Runs `flatc` to generate Go serialization code (post-processed to import `pkg/protocol`).
5.  Runs `flatc` to generate C++ serialization code.
6.  Generates `interface.go` and `server.go`.
7.  Generates `xll_main.cpp`.

#### `build`
Wraps `task build` to compile the project.
1.  Runs `generate`.
2.  **Go Build**: Compiles `main.go` into a server binary.
3.  **C++ Build**: Compiles `generated/cpp` -> `build/my-project.xll`.
    -   In `singlefile: xll` mode, it uses Zstd to compress the Go binary and embeds it as a Windows resource.

#### `doctor`
Diagnoses the environment, specifically checking for the presence of a C++ compiler.
1. Checks for `cl.exe` (MSVC).
2. Checks for `g++` or `gcc` (MinGW).
3. If no compiler is found, it suggests installation via `winget`.
4. Checks for the presence of `flatc`. If missing, attempts to download the correct version.

## 6. Implementation Details

### User Code Integration (Go)

The user works in `main.go`. The CLI generates an interface in the generated package.

**Generated Interface (`generated/interface.go`):**
```go
package generated

import "github.com/xll-gen/xll-gen/pkg/protocol"

type XllService interface {
    Add(ctx context.Context, a int32, b int32) (int32, error)
    GetPrice(ctx context.Context, ticker string) (float64, error)
}

func Serve(handler XllService) {
    // IPC loop implementation
}
```

**User Main (`main.go`):**
```go
package main

import (
    "context"
    "my-project/generated"
)

type MyService struct{}

func (s *MyService) Add(ctx context.Context, a int32, b int32) (int32, error) {
    return a + b, nil
}

func (s *MyService) GetPrice(ctx context.Context, ticker string) (float64, error) {
    return 100.50, nil // Mock
}

func main() {
    // Connects to SHM and starts processing
    generated.Serve(&MyService{})
}
```

### C++ Generation Strategy
The C++ code must bridge Excel's `XLOPER12` types to Flatbuffers.
-   The generator creates a static C++ mapping based on types defined in `xll.yaml`.
-   Uses `xll-gen/shm` C++ library to write to the shared memory buffer.

### Build System
-   The CLI relies on `task` (Taskfile.dev) for build orchestration.
-   **Dependencies**:
    -   **Flatbuffers**: v25.9.23
    -   **SHM**: v0.5.4
    -   **Zstd**: v1.5.7 (For compression)
-   **Flatbuffers Compiler (`flatc`)**:
    -   The CLI automatically manages `flatc`.
    -   It detects the latest release from [Google Flatbuffers Releases](https://github.com/google/flatbuffers/releases).
    -   Downloads and caches the binary if not present on the system.
-   **C++ Compiler**:
    -   It must locate C++ compilers.
    -   Priority: MSVC (cl.exe) -> MinGW (g++) -> Clang.
    -   **Recommendation**: Users can easily install a compatible MinGW toolchain using `winget`:
        ```bash
        winget install -e --id BrechtSanders.WinLibs.POSIX.UCRT
        ```
-   Outputs explicit build steps to stdout for debugging/transparency.

## 7. Future Considerations
-   Support for Java/Node.js by adding `gen.java` or `gen.js` in `xll.yaml`.
-   Hot reloading (Go server restart without unloading XLL).
-   Async function support in Excel (handling long-running Go tasks).

## 8. Reference: Excel Internals

This section details the specific C API constructs used by the generated C++ code. It serves as the primary reference for agents generating registration and memory management logic.

### 8.1 xlfRegister & Data Types (`pxTypeText`)

When registering functions using `xlfRegister`, the `pxTypeText` string defines the return type and argument types. We exclusively use **XLOPER12** (Excel 2007+) types.

**Canonical Type Codes**
For types with multiple representation options, we stick to the following canonical choices to ensure consistency.

| Data Type | Code | C type | Description |
| :--- | :--- | :--- | :--- |
| **Boolean** | `A` | `short` | 0=false, 1=true. |
| **Double** | `B` | `double` | IEEE 8-byte floating point. |
| **Int** | `J` | `int32_t` | 32-bit signed integer. |
| **String** | `Q` | `XLOPER12 *` | Pointer to XLOPER12 (internally mapped to Q for safety). |
| **Array (FP)** | `K%` | `FP12 *` | Floating-point array structure. Efficient for math. |
| **Any (Value)** | `Q` | `XLOPER12 *` | Pointer to XLOPER12. Dereferences references (Pass by Value). |
| **Any (Ref)** | `U` | `XLOPER12 *` | Pointer to XLOPER12. Allows references (Range). |
| **Async** | `X` | `void *` | Async handle (Excel 2010+). |

**Strict Value Policy:**
We do **not** use optional/nullable scalar pointer types (e.g., `int?` -> `N` (int*), `float?` -> `E` (double*), `bool?` -> `L` (short*)).
*   **Reason**: Excel passes a valid pointer to a zero value (0, 0.0, false) for empty cells, making it impossible to distinguish between an explicit zero and a missing argument.
*   **Solution**: Users requiring optional inputs must use `any` (or `scalar`), which receives the raw `XLOPER12`. The generated code or user logic can then check `xltypeMissing` or empty variants.

**Note**: Do not use the legacy 8-bit string types (`C`, `D`, `F`, `G`), `XLOPER` (`P`, `R`), or legacy `FP` (`K`). Always use the wide-char / `12` variants (e.g., `FP12` / `K%`).

**Thread Safety (`$`)**
Starting in Excel 2007, Excel can perform multithreaded workbook recalculation. Unless there is a specific reason to not support it, **all generated functions should be registered as thread-safe**.
To do this, append a `$` character to the end of the `pxTypeText` string.
*   Example: `QJJ$` (Returns Value, takes two Ints, Thread-Safe).

**Registration Arguments (Form 1)**
The generator implements `xlfRegister` (Form 1) fully, passing:
1.  `module_text` (DLL name)
2.  `procedure` (Export name)
3.  `type_text` (Type string, e.g., `QJJ$`)
4.  `function_text` (Function name)
5.  `argument_text` (Comma-separated argument names)
6.  `macro_type` (1 = Function)
7.  `category` (Default: Project Name)
8.  `shortcut_text` (Optional)
9.  `help_topic` (Optional)
10. `function_help` (Description)
11. `argument_help1` (Arg 1 Description)
...

### 8.2 Memory Management

Proper memory management is critical to prevent Excel crashes.

**Rules:**
1.  **Inputs are Read-Only**: Arguments passed to the XLL function must never be freed or modified.
2.  **Returning DLL-Allocated Memory**: When the XLL returns an `XLOPER12` that points to memory allocated by the DLL (e.g., a string):
    -   Set `xltype` to `type | xlbitDLLFree`.
    -   Implement the `xlAutoFree12` callback.
    -   Use the provided `xll_mem` library helpers (`NewExcelString`, `NewXLOPER12`) which use a thread-safe object pool and `xlAutoFree12` implementation.
3.  **Strings**: We use `Q` for string inputs (XLOPER12) to ensure safety. For returns, we use `Q` (XLOPER12) wrapping a counted wide string with `xlbitDLLFree`.


### 8.3 Error Codes (`xlCVError`)

When returning errors from the XLL (e.g., if the Go server is unreachable), return an `XLOPER12` with `xltype = xltypeErr` and one of the following integer codes.

| Error Name | Value | Description |
| :--- | :--- | :--- |
| `xlErrNull` | `2000` | Null intersection |
| `xlErrDiv0` | `2007` | Division by zero |
| `xlErrValue` | `2015` | Invalid value |
| `xlErrRef` | `2023` | Invalid reference |
| `xlErrName` | `2029` | Invalid name |
| `xlErrNum` | `2036` | Invalid number |
| `xlErrNA` | `2042` | Value not available |
| `xlErrGettingData` | `2043` | Getting Data (Async) |
| `xlErrSpill` | `2045` | Spill error |
| `xlErrConnect` | `2046` | Connection error |
| `xlErrBlocked` | `2047` | Blocked error |
| `xlErrUnknown` | `2048` | Unknown error |
| `xlErrField` | `2049` | Field error |
| `xlErrCalc` | `2050` | Calculation error |

### 8.4 Event Handlers

Starting with Excel 2010, `xlEventRegister` allows XLLs to register for specific system events, primarily to manage the lifecycle of asynchronous user-defined functions (UDFs).

**Supported Events:**
*   `CalculationEnded` (Code 1): Raised when Excel completes a calculation cycle. Useful for freeing resources allocated during async calculations.
*   `CalculationCanceled` (Code 2): Raised when the user interrupts the calculation (e.g., via ESC). The XLL should abort pending async activities. **Immediately following this event, the `CalculationEnded` event is raised.**

**Note**: `CalculationEnded` and `CalculationCanceled` are **not** raised during programmatic recalculation.

**Configuration (`xll.yaml`):**
```yaml
events:
  - type: "CalculationEnded"
    name: "OnCalculationEnded"
```
This generates a corresponding C++ handler that forwards the event to the Go server.

**Command Scheduling**:
The Go server allows scheduling Excel commands to be executed by the C++ XLL during the `CalculationEnded` event.
*   The Go server maintains a queue of commands (`ScheduleSet`, `ScheduleFormat`).
*   When `CalculationEnded` is triggered, the Go server serializes these commands into the response.
*   The C++ XLL receives the response and executes the commands using `xlSet` and `xlcFormatNumber`.

## 9. Reference: Shared Memory (IPC)

The `xll-gen/shm` library provides low-latency IPC. For maximum performance, we use **Zero-Copy** operations where possible, especially for FlatBuffers.

### 9.1 Zero-Copy (C++ Host)

Instead of building a FlatBuffer on the heap and copying it to the shared memory slot, we construct it directly in the slot's request buffer.

```cpp
// 1. Acquire a Zero-Copy Slot
auto slot = host.GetZeroCopySlot();

// 2. Build FlatBuffer directly in shared memory
// slot.GetReqBuffer() returns the pointer to the buffer.
// We pass it to the builder as the initial buffer.
flatbuffers::FlatBufferBuilder builder(
    slot.GetMaxReqSize(),
    nullptr,
    false,
    slot.GetReqBuffer()
);

// ... build your object ...
// auto offset = CreateMyRequest(builder, ...);
// builder.Finish(offset);

// 3. Send Request
// Signals MSG_ID_FLATBUFFER (or user ID) and handles size internally.
slot.SendFlatBuffer(builder.GetSize());

// 4. Access Response Directly (Zero-Copy)
// The response is available in the response buffer immediately after Send returns.
uint8_t* respData = slot.GetRespBuffer();
int32_t respSize = slot.GetRespSize();
```

### 9.2 Zero-Copy (Go Guest)

The Go client handler receives a slice that points directly to the shared memory region. Reading from `req` is zero-copy.

```go
client.Handle(func(req []byte, respBuf []byte, msgId uint32) int32 {
    // 'req' points to the shared memory slot payload.
    // It is safe to read directly (e.g., using FlatBuffers GetRootAs...).

    if msgId == shm.MsgIdFlatbuffer {
        // processFlatBuffer(req)
    }

    // Write response to respBuf
    // ...
    return bytesWritten
})
```

## 10. Agent Guidelines

*   **Documentation Updates**: When modifying features or adding new capabilities, you must update the relevant documentation (e.g., `README.md`, `AGENTS.md`) to reflect the changes.
*   **Language Policy**: All documentation, code comments, commit messages, and other project-related text must be in English.
*   **Versioning**: The version of `xll-gen` is defined in `version/version.go`. All generated files (C++, Go, CMake, etc.) must include a header comment indicating the version of `xll-gen` that created them. This helps in debugging and ensures users know when their artifacts are out of date.
*   **Testing**: When applying changes due to upstream library updates (e.g., `shm` API changes), ensure that any outdated or incompatible tests are updated or deleted if they are no longer relevant.
*   **Conflict Resolution**: Before committing or submitting changes, always check for conflicts with the `main` branch and resolve them.
*   **Code Comments**: Remove verbose comments that are unnecessary because the code is self-explanatory. Comments should focus on explaining the "why" or complex logic, rather than restating what the code does.

## 11. Development Workflow

*   **Temporary Projects**: Use directories starting with `temp_` (e.g., `temp_verify`, `temp_test`) for creating temporary test projects. These are git-ignored to prevent accidental commits of artifacts.

## 12. Tag Message Guidelines

When creating a tag message, adhere to the following format:

1.  **Major Changes Summary**: Group major changes by category (e.g., Performance, Feature, Fix). Summarize the change and include the commit hash.
2.  **Detailed Commit List**: List all commits (including those not in the summary) with their commit message and hash.
3.  **Hyperlinks**: Ensure every commit hash is a hyperlink.

**Example:**

```text
### Features
* Added async support ([1a2b3c](http://url...))

### Performance
* Optimized IPC ([4d5e6f](http://url...))

### All Commits
* [1a2b3c](http://url...) Added async support
* [4d5e6f](http://url...) Optimized IPC
* [7g8h9i](http://url...) Fixed typo in README
```

## 13. Reference: Optional & Variable Arguments

This section describes how to handle **Optional Arguments** and **Variable Arguments** in Excel XLL development.

Since the Excel C API does not support variable arguments like C's `va_list`, the standard approach is **"Accept pointers up to a maximum count and check for `xltypeMissing`"**.

### 13.1 Core Mechanism

There are 3 key rules for handling omitted arguments in an Excel XLL:

1.  **Type Registration (`pxTypeText`)**: You must register argument types as `P`, `Q` (XLOPER/XLOPER12), or `U`, `R` (Range). Basic types like `double(B)` cannot be used because they are converted to 0 or cause errors when omitted.
2.  **Missing Detection (`xltypeMissing`)**: In the C++ code, check if the `xltype` of the received `XLOPER12` is `xltypeMissing`.
3.  **UI Treatment (`pxArgumentText`)**: To indicate optional values to the user, enclose the argument name in brackets `[ ]` during registration.

### 13.2 Optional Arguments Implementation Example

A simple function accepting 1 required argument and 1 optional argument.

**Scenario:** `CalcWithOption(Value, [Multiplier])`
*   `Value`: Required
*   `Multiplier`: Optional (Default value 1.0 if omitted)

#### C++ Implementation

```cpp
#include <windows.h>
#include "xlcall.h"

// Registered Type String: "QQQ" (Return Q, Arg1 Q, Arg2 Q)
extern "C" __declspec(dllexport) LPXLOPER12 WINAPI CalcWithOption(LPXLOPER12 pxVal, LPXLOPER12 pxMul)
{
    static XLOPER12 xResult;
    double value = 0.0;
    double multiplier = 1.0; // Default Value

    // 1. Extract Required Argument
    if (pxVal->xltype == xltypeNum) {
        value = pxVal->val.num;
    } else {
        xResult.xltype = xltypeErr;
        xResult.val.err = xlerrValue;
        return &xResult;
    }

    // 2. Handle Optional Argument (Core Logic)
    // If omitted, Excel passes xltypeMissing
    if (pxMul->xltype != xltypeMissing) {
        // Read value only if not missing
        if (pxMul->xltype == xltypeNum) {
            multiplier = pxMul->val.num;
        }
        // Add Coerce logic if necessary
    }

    // 3. Return Result
    xResult.xltype = xltypeNum;
    xResult.val.num = value * multiplier;

    return &xResult;
}
```

#### xlfRegister

```cpp
Excel12(xlfRegister, 0, 10,
    (LPXLOPER12)pxModuleText,
    (LPXLOPER12)TempStr12(L"CalcWithOption"), // C++ Function Name
    (LPXLOPER12)TempStr12(L"QQQ"),            // Type String
    (LPXLOPER12)TempStr12(L"CalcWithOption"), // Excel Function Name
    (LPXLOPER12)TempStr12(L"Value, [Multiplier]"), // UI: Brackets for optional
    (LPXLOPER12)TempStr12(L"1"),              // Function(1)
    (LPXLOPER12)TempStr12(L"MyAddin"),        // Category
    (LPXLOPER12)TempStr12(L""),               // Shortcut
    (LPXLOPER12)TempStr12(L""),               // Help Topic
    (LPXLOPER12)TempStr12(L"Calculates value with optional multiplier.") // Description
);
```

### 13.3 Variable Arguments Implementation Example

Excel does not directly support variable arguments like `SUM(n1, n2, ...)`. You must use the **Sparse Arguments** approach, defining a maximum count (e.g., 10) and listing all arguments.

**Scenario:** `MySum(v1, [v2], ... [v10])`
*   Accepts up to 10 numbers and calculates the sum.

#### C++ Implementation (Loop)

```cpp
#define MAX_ARGS 10

// Explicitly declare all 10 arguments
extern "C" __declspec(dllexport) LPXLOPER12 WINAPI MySum(
    LPXLOPER12 p1, LPXLOPER12 p2, LPXLOPER12 p3, LPXLOPER12 p4, LPXLOPER12 p5,
    LPXLOPER12 p6, LPXLOPER12 p7, LPXLOPER12 p8, LPXLOPER12 p9, LPXLOPER12 p10
) {
    static XLOPER12 xResult;
    double sum = 0.0;

    // 1. Group arguments into an array for looping
    LPXLOPER12 args[MAX_ARGS] = { p1, p2, p3, p4, p5, p6, p7, p8, p9, p10 };

    // 2. Iterate and sum non-missing values
    for (int i = 0; i < MAX_ARGS; i++) {
        // Skip missing arguments
        if (args[i]->xltype == xltypeMissing) {
            continue;
        }

        if (args[i]->xltype == xltypeNum) {
            sum += args[i]->val.num;
        }
        // Real implementation should handle xltypeSRef, xltypeMulti (xlCoerce)
    }

    xResult.xltype = xltypeNum;
    xResult.val.num = sum;
    return &xResult;
}
```

#### xlfRegister

```cpp
// Type String: Return(Q) + 10 Args(Q...Q) = 11 Qs
// Argument Text: "v1, [v2], [v3], ... [v10]"

Excel12(xlfRegister, 0, 5,
    (LPXLOPER12)pxModuleText,
    (LPXLOPER12)TempStr12(L"MySum"),          // C++ Function Name
    (LPXLOPER12)TempStr12(L"QQQQQQQQQQQ"),    // Type: 11 Qs
    (LPXLOPER12)TempStr12(L"MySum"),          // Excel Function Name
    (LPXLOPER12)TempStr12(L"v1, [v2], [v3], [v4], [v5], [v6], [v7], [v8], [v9], [v10]") // UI Text
);
```

### 13.4 Summary and Recommendations

| Category | Approach | Note |
| :--- | :--- | :--- |
| **Type** | `P`, `Q` (XLOPER/12) or `U` | Cannot use basic types like `double` |
| **Check** | `arg->xltype == xltypeMissing` | Handle default value when missing |
| **UI** | `[ArgName]` format | Write directly in `pxArgumentText` |
| **Variable Args** | List max count of arguments | Limit to ~20-30 (Excel limit is 255) |

#### Tip: Too Many Arguments
Listing `p1...p30` is inefficient. In this case, design the function to accept a **Single `xltypeMulti` (Range/Array) argument**.

*   **Before:** `=MyFunc(A1, B1, C1, ...)` (Argument List)
*   **After:** `=MyFunc(A1:C1)` or `=MyFunc((A1, B1, C1))` (Multi-area Reference)
    *   This only requires registering 1 argument (`Q` or `U`) and looping through the array in C++, which is much cleaner.
