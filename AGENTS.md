# xll-gen Design Document

## 1. Overview
`xll-gen` is a CLI tool designed to facilitate the creation of Excel Add-ins (XLL) using languages that are traditionally difficult to compile into DLLs or have runtime limitations in that context, such as Go.

### Core Philosophy
- **Language Agnostic Architecture**: Uses an out-of-process model. Excel (via a C++ shim) communicates with a standalone server process (e.g., written in Go) using Shared Memory.
- **Wails-like Experience**: Provides a seamless developer experience with commands like `init`, `build`, and `dev`. The complexity of C++ compilation and IPC is wrapped but remains transparent.
- **Non-Intrusive**: User logic resides in `main` code. The tool generates boilerplate in separate directories/packages that the user imports. Re-generation does not overwrite user logic.

## 2. Architecture

### Components
1.  **Excel Process**: Loads the generated XLL (C++).
2.  **XLL (C++ Shim)**:
    -   Auto-generated.
    -   Registers functions with Excel.
    -   Manages the lifecycle of the sidecar process (the User Server).
    -   Serializes Excel arguments to **Flatbuffers**.
    -   Writes to **Shared Memory** (`xll-gen/shm`).
    -   Signals the server and waits for a response.
3.  **User Server (Go)**:
    -   Standalone executable.
    -   Uses generated IPC handling code.
    -   Listens on Shared Memory.
    -   Deserializes requests, routes them to the User's Implementation (Handler).
    -   Serializes responses and signals back to Excel.

### IPC Protocol
-   **Transport**: Shared Memory (Low latency, high throughput).
-   **Serialization**: Google Flatbuffers.
-   **Schema**: Dynamically generated based on user configuration.

## 3. Configuration (`xll.yaml`)

The project is defined by a `xll.yaml` file. This is the source of truth for code generation.

```yaml
project:
  name: "my-quant-lib"
  version: "0.1.0"

# Code generation settings
gen:
  go:
    package: "pkg/generated"

# Function Definitions
functions:
  - name: "Add"
    description: "Adds two integers"
    args:
      - name: "a"
        type: "int"
        description: "First number"
      - name: "b"
        type: "int"
        description: "Second number"
    return: "int"
    volatile: false

  - name: "GetPrice"
    description: "Fetches price for a ticker"
    args:
      - name: "ticker"
        type: "string"
    return: "float"
    async: true  # Future support for async/calc
```

## 4. Project Structure

Running `xll-gen init` creates:

```text
my-project/
├── xll.yaml            # Configuration
├── main.go             # User entry point
├── go.mod
├── generated/          # [DO NOT EDIT] Generated by xll-gen
│   ├── schema.fbs      # Generated Flatbuffers schema
│   ├── go/             # Generated Go bindings & server logic
│   │   ├── types.go
│   │   ├── server.go
│   │   └── interface.go
│   └── cpp/            # Generated C++ XLL source
│       ├── xll_main.cpp
│       └── flatbuffers/
└── build/              # Output directory
```

## 5. Developer Experience (CLI)

The CLI is written in Go and uses `cobra`.

### Commands

#### `init`
Scaffolds a new project.
```bash
xll-gen init my-project
```

#### `generate`
Reads `xll.yaml` and updates the `generated/` directory.
1.  Parses `xll.yaml`.
2.  Generates `schema.fbs`.
3.  Runs `flatc` (embedded or managed) to generate Go and C++ serialization code.
4.  Generates `interface.go` (Go interface for user to implement).
5.  Generates `xll_main.cpp` (C++ Excel registration and IPC logic).

#### `build`
Wraps the build process for both the Go server and the C++ XLL.
1.  Runs `generate`.
2.  **Go Build**: Compiles `main.go` -> `build/my-project.exe`.
3.  **C++ Build**: Detects available compiler (MSVC, MinGW) and compiles `generated/cpp` -> `build/my-project.xll`.
    -   *Transparency*: Displays the actual commands being executed (like `cl.exe ...` or `go build ...`).

#### `clean`
Removes `build/` and `generated/`.

#### `doctor`
Diagnoses the environment, specifically checking for the presence of a C++ compiler.
1. Checks for `cl.exe` (MSVC).
2. Checks for `g++` or `gcc` (MinGW).
3. If no compiler is found, it suggests installation via `winget`.
4. Checks for the presence of `flatc`. If missing, attempts to download the correct version.

## 6. Implementation Details

### User Code Integration (Go)

The user works in `main.go`. The CLI generates an interface in the generated package.

**Generated Interface (`generated/go/interface.go`):**
```go
package generated

type XllService interface {
    Add(a int32, b int32) (int32, error)
    GetPrice(ticker string) (float64, error)
}

func Serve(handler XllService) {
    // IPC loop implementation
}
```

**User Main (`main.go`):**
```go
package main

import (
    "my-project/generated"
)

type MyService struct{}

func (s *MyService) Add(a int32, b int32) (int32, error) {
    return a + b, nil
}

func (s *MyService) GetPrice(ticker string) (float64, error) {
    return 100.50, nil // Mock
}

func main() {
    // Connects to SHM and starts processing
    generated.Serve(&MyService{})
}
```

### C++ Generation Strategy
The C++ code must bridge Excel's `XLOPER12` types to Flatbuffers.
-   The generator creates a static C++ mapping based on types defined in `xll.yaml`.
-   Uses `xll-gen/shm` C++ library to write to the shared memory buffer.

### Build System
-   The CLI mimics `make` or `task` logic internally.
-   **Flatbuffers Compiler (`flatc`)**:
    -   The CLI automatically manages `flatc`.
    -   It detects the latest release from [Google Flatbuffers Releases](https://github.com/google/flatbuffers/releases) (e.g., v25.9.23).
    -   Downloads and caches the binary if not present on the system.
-   **C++ Compiler**:
    -   It must locate C++ compilers.
    -   Priority: MSVC (cl.exe) -> MinGW (g++) -> Clang.
    -   **Recommendation**: Users can easily install a compatible MinGW toolchain using `winget`:
        ```bash
        winget install -e --id BrechtSanders.WinLibs.POSIX.UCRT
        ```
-   Outputs explicit build steps to stdout for debugging/transparency.

## 7. Future Considerations
-   Support for Java/Node.js by adding `gen.java` or `gen.js` in `xll.yaml`.
-   Hot reloading (Go server restart without unloading XLL).
-   Async function support in Excel (handling long-running Go tasks).
