
// Code generated by xll-gen v0.1.0. DO NOT EDIT.
#include <windows.h>
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <map>
#include <mutex>
#include <sstream>
#include <wchar.h>
#include <random>
#include <iostream>
#include "include/xlcall.h"
#include "include/xll_mem.h"
#include "shm/DirectHost.h"
#include "shm/IPCUtils.h"
#include "schema_generated.h"

// System Message IDs
#define MSG_ACK 2
#define MSG_CHUNK 128
#define MSG_SETREFCACHE 129
#define MSG_CALCULATION_ENDED 130
#define MSG_CALCULATION_CANCELED 131
#define MSG_USER_START 132

shm::DirectHost g_host;
std::thread g_worker;
std::atomic<bool> g_running{false};
std::map<std::string, bool> g_sentRefCache;
std::mutex g_refCacheMutex;

// Global Process Handle (for auto-launched server)
HANDLE g_hChildProcess = NULL;
HINSTANCE g_hModule = NULL;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
    }
    return TRUE;
}

// Helpers for registration
LPXLOPER12 TempStr12(const wchar_t* txt) {
    static XLOPER12 xOp[10];
    static int i = 0;
    i = (i + 1) % 10;
    LPXLOPER12 op = &xOp[i];

    op->xltype = xltypeStr;
    static wchar_t strBuf[10][256];
    size_t len = 0;
    if (txt) len = wcslen(txt);
    if (len > 255) len = 255;

    strBuf[i][0] = (wchar_t)len;
    if (len > 0) wmemcpy(strBuf[i]+1, txt, len);

    op->val.str = strBuf[i];
    return op;
}

LPXLOPER12 TempInt12(int val) {
    static XLOPER12 xOp[10];
    static int i = 0;
    i = (i + 1) % 10;
    LPXLOPER12 op = &xOp[i];
    op->xltype = xltypeInt;
    op->val.w = val;
    return op;
}

// Utility: String Conversion
std::wstring StringToWString(const std::string& str) {
    if (str.empty()) return std::wstring();
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), NULL, 0);
    std::wstring wstrTo(size_needed, 0);
    MultiByteToWideChar(CP_UTF8, 0, &str[0], (int)str.size(), &wstrTo[0], size_needed);
    return wstrTo;
}

std::string WideToUtf8(const std::wstring& wstr) {
    if (wstr.empty()) return "";
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
    std::string strTo(size_needed, 0);
    WideCharToMultiByte(CP_UTF8, 0, &wstr[0], (int)wstr.size(), &strTo[0], size_needed, NULL, NULL);
    return strTo;
}

// Optimization: Thread-local buffer for string conversion
// Avoids allocating std::string for every conversion.
thread_local std::vector<char> g_strBuf;

const char* ConvertExcelString(const wchar_t* wstr) {
    if (!wstr) return "";
    size_t len = (size_t)wstr[0]; // Pascal string length
    if (len == 0) return "";

    // Ensure buffer space (UTF-8 max expansion is 4x)
    size_t cap = len * 4 + 1;
    if (g_strBuf.size() < cap) g_strBuf.resize(cap);

    int n = WideCharToMultiByte(CP_UTF8, 0, wstr + 1, (int)len, g_strBuf.data(), (int)g_strBuf.size(), NULL, NULL);
    if (n >= 0) g_strBuf[n] = '\0';
    else g_strBuf[0] = '\0';

    return g_strBuf.data();
}

std::wstring GetSheetName(LPXLOPER12 pxRef) {
    if (!pxRef || (pxRef->xltype != xltypeRef && pxRef->xltype != xltypeSRef)) {
        return L"";
    }

    XLOPER12 xRes;
    int ret = Excel12(xlSheetNm, &xRes, 1, pxRef);
    if (ret != xlretSuccess) return L"";

    std::wstring result;
    if (xRes.xltype == xltypeStr && xRes.val.str) {
         size_t len = (size_t)xRes.val.str[0];
         if (len > 0) {
             result.assign(xRes.val.str + 1, len);
         }
    }
    Excel12(xlFree, 0, 1, &xRes);
    return result;
}

std::wstring GetXllDir() {
    wchar_t path[MAX_PATH];
    if (GetModuleFileNameW(g_hModule, path, MAX_PATH) == 0) return L"";
    std::wstring p(path);
    size_t pos = p.find_last_of(L"\\/");
    if (pos != std::wstring::npos) {
        return p.substr(0, pos);
    }
    return L".";
}

// Chunking helper
int SendChunked(const uint8_t* data, size_t size, std::vector<uint8_t>& respBuf) {
    // Thread-safe random number generation
    thread_local std::mt19937_64 rng(std::random_device{}());
    thread_local std::uniform_int_distribution<uint64_t> dist;
    uint64_t transferId = dist(rng);

    const size_t chunkSize = 950 * 1024; // 950KB
    size_t offset = 0;

    while (offset < size) {
        size_t len = std::min(chunkSize, size - offset);

        flatbuffers::FlatBufferBuilder b(1024 + len); // Approx
        auto dataOff = b.CreateVector(data + offset, len);
        // MSG_SETREFCACHE is 129
        auto chunk = ipc::CreateChunk(b, transferId, (uint32_t)size, (uint32_t)offset, dataOff, MSG_SETREFCACHE);
        b.Finish(chunk);

        // MsgID 128 for Chunk
        int ok = g_host.Send(b.GetBufferPointer(), b.GetSize(), MSG_CHUNK, respBuf);
        if (ok < 0) return ok; // Fail

        // Response must be Ack (MsgID 2)
        // Since DirectHost.Send is copy-based, respBuf contains the response.
        // But SendChunked usage in ConvertAny implies we check 'ok' and respBuf.
        // If it's a chunk, we expect Ack(2) with ok=true
        if (respBuf.empty()) return -1;
        // NOTE: shm::DirectHost::Send returns the msgId of response or negative error.
        // Wait, DirectHost::Send signature: int Send(req, reqSize, reqMsgId, &respBuf)
        // It returns msgId of response.
        if (ok != MSG_ACK) return -1; // Expecting Ack

        auto ack = ipc::GetAck(respBuf.data());
        if (!ack || !ack->ok()) return -1;

        offset += len;
    }
    return 1; // Success
}

const uint8_t* ReceiveChunked(shm::ZeroCopySlot& slot, int reqMsgId, size_t reqSize) {
    int ok = slot.Send(reqMsgId, reqSize);
    if (ok < 0) return nullptr;

    if (slot.GetRespMsgId() == MSG_CHUNK || ipc::ChunkBufferHasIdentifier(slot.GetRespBuffer())) {
        thread_local std::vector<uint8_t> buf;
        buf.clear();

        while(true) {
            auto chunk = ipc::GetChunk(slot.GetRespBuffer());
            auto data = chunk->data();
            buf.insert(buf.end(), data->begin(), data->end());

            if (buf.size() >= chunk->total_size()) return buf.data();

            // Request next chunk via Ack (MsgID 2)
            flatbuffers::FlatBufferBuilder b(128, nullptr, false, slot.GetReqBuffer());
            auto ack = ipc::CreateAck(b, chunk->id(), true);
            b.Finish(ack);

            if (slot.Send(MSG_ACK, b.GetSize()) < 0) return nullptr;
            if (slot.GetRespMsgId() != MSG_CHUNK && !ipc::ChunkBufferHasIdentifier(slot.GetRespBuffer())) return nullptr;
        }
    }
    return slot.GetRespBuffer();
}

flatbuffers::Offset<ipc::types::Range> ConvertRange(LPXLOPER12 op, flatbuffers::FlatBufferBuilder& builder) {
    if (!op) return 0;

    std::vector<ipc::types::Rect> refs;
    std::wstring sheetName = GetSheetName(op);

    if (op->xltype == xltypeRef) {
        if (op->val.mref.lpmref) {
            for (WORD i = 0; i < op->val.mref.lpmref->count; ++i) {
                const auto& r = op->val.mref.lpmref->reftbl[i];
                refs.emplace_back(r.rwFirst, r.rwLast, r.colFirst, r.colLast);
            }
        }
    } else if (op->xltype == xltypeSRef) {
        const auto& r = op->val.sref.ref;
        refs.emplace_back(r.rwFirst, r.rwLast, r.colFirst, r.colLast);
    }

    auto sheetNameOffset = builder.CreateString(WideToUtf8(sheetName));
    auto refsOffset = builder.CreateVectorOfStructs(refs);
    return ipc::types::CreateRange(builder, sheetNameOffset, refsOffset);
}

flatbuffers::Offset<ipc::types::Scalar> ConvertScalar(const XLOPER12& cell, flatbuffers::FlatBufferBuilder& builder) {
    if (cell.xltype == xltypeNum) {
        auto val = ipc::types::CreateNum(builder, cell.val.num);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Num, val.Union());
    } else if (cell.xltype == xltypeInt) {
        auto val = ipc::types::CreateInt(builder, cell.val.w);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Int, val.Union());
    } else if (cell.xltype == xltypeBool) {
        auto val = ipc::types::CreateBool(builder, cell.val.xbool);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Bool, val.Union());
    } else if (cell.xltype == xltypeStr) {
        auto s = ConvertExcelString(cell.val.str);
        auto sOff = builder.CreateString(s);
        auto val = ipc::types::CreateStr(builder, sOff);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Str, val.Union());
    } else if (cell.xltype == xltypeErr) {
        auto val = ipc::types::CreateErr(builder, (ipc::types::XlError)cell.val.err);
        return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Err, val.Union());
    }
    auto val = ipc::types::CreateNil(builder);
    return ipc::types::CreateScalar(builder, ipc::types::ScalarValue_Nil, val.Union());
}

flatbuffers::Offset<ipc::types::Any> ConvertMultiToAny(const XLOPER12& xMulti, flatbuffers::FlatBufferBuilder& builder) {
    int rows = xMulti.val.array.rows;
    int cols = xMulti.val.array.columns;
    int count = rows * cols;

    bool allNum = true;
    for(int i=0; i<count; ++i) {
        if (xMulti.val.array.lparray[i].xltype != xltypeNum) {
            allNum = false;
            break;
        }
    }

    if (allNum) {
        std::vector<double> data;
        data.reserve(count);
        for(int i=0; i<count; ++i) {
            data.push_back(xMulti.val.array.lparray[i].val.num);
        }
        auto dataOff = builder.CreateVector(data);
        auto arr = ipc::types::CreateNumArray(builder, rows, cols, dataOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_NumArray, arr.Union());
    } else {
        std::vector<flatbuffers::Offset<ipc::types::Scalar>> data;
        data.reserve(count);
        for(int i=0; i<count; ++i) {
             data.push_back(ConvertScalar(xMulti.val.array.lparray[i], builder));
        }
        auto dataOff = builder.CreateVector(data);
        auto arr = ipc::types::CreateArray(builder, rows, cols, dataOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Array, arr.Union());
    }
}

flatbuffers::Offset<ipc::types::Any> ConvertAny(LPXLOPER12 op, flatbuffers::FlatBufferBuilder& builder) {
    if (!op) {
        auto nilVal = ipc::types::CreateNil(builder);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, nilVal.Union());
    }

    if (op->xltype == xltypeNum) {
        auto val = ipc::types::CreateNum(builder, op->val.num);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Num, val.Union());
    } else if (op->xltype == xltypeInt) {
        auto val = ipc::types::CreateInt(builder, op->val.w);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Int, val.Union());
    } else if (op->xltype == xltypeBool) {
        auto val = ipc::types::CreateBool(builder, op->val.xbool);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Bool, val.Union());
    } else if (op->xltype == xltypeStr) {
        auto s = ConvertExcelString(op->val.str);
        auto sOff = builder.CreateString(s);
        auto val = ipc::types::CreateStr(builder, sOff);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Str, val.Union());
    } else if (op->xltype == xltypeErr) {
        auto val = ipc::types::CreateErr(builder, (ipc::types::XlError)op->val.err);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Err, val.Union());
    } else if (op->xltype == xltypeMissing || op->xltype == xltypeNil) {
        auto val = ipc::types::CreateNil(builder);
        return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, val.Union());
    } else if (op->xltype == xltypeRef || op->xltype == xltypeSRef) {
        long rows = 0;
        long cols = 0;
        std::wstring sheetName = GetSheetName(op);
        std::stringstream ss;
        ss << WideToUtf8(sheetName) << "!";

        if (op->xltype == xltypeRef) {
             if (op->val.mref.lpmref) {
                 for (WORD i = 0; i < op->val.mref.lpmref->count; ++i) {
                     const auto& r = op->val.mref.lpmref->reftbl[i];
                     rows += (r.rwLast - r.rwFirst + 1);
                     if (i==0) cols = (r.colLast - r.colFirst + 1);
                     ss << r.rwFirst << ":" << r.rwLast << ":" << r.colFirst << ":" << r.colLast << ";";
                 }
             }
        } else {
             const auto& r = op->val.sref.ref;
             rows = r.rwLast - r.rwFirst + 1;
             cols = r.colLast - r.colFirst + 1;
             ss << r.rwFirst << ":" << r.rwLast << ":" << r.colFirst << ":" << r.colLast;
        }

        long totalCells = rows * cols;
        std::string key = ss.str();

        bool useCache = (totalCells > 100);

        if (useCache) {
             std::lock_guard<std::mutex> lock(g_refCacheMutex);
             bool cached = g_sentRefCache[key];
             if (!cached) {
                  XLOPER12 xMulti;
                  int ret = Excel12(xlCoerce, &xMulti, 2, op, TempInt12(xltypeMulti));
                  if (ret == xlretSuccess) {
                      flatbuffers::FlatBufferBuilder reqB(1024);

                      auto anyOff = ConvertMultiToAny(xMulti, reqB);
                      auto keyOff = reqB.CreateString(key);
                      auto cacheReq = ipc::CreateSetRefCacheRequest(reqB, keyOff, anyOff);
                      reqB.Finish(cacheReq);

                      Excel12(xlFree, 0, 1, &xMulti);

                      std::vector<uint8_t> respBuf;
                      int ok;
                      if (reqB.GetSize() > 950 * 1024) {
                          ok = SendChunked(reqB.GetBufferPointer(), reqB.GetSize(), respBuf);
                      } else {
                          // MSG_SETREFCACHE (129)
                          ok = g_host.Send(reqB.GetBufferPointer(), reqB.GetSize(), MSG_SETREFCACHE, respBuf);
                      }

                      if (ok == MSG_ACK && !respBuf.empty()) {
                          auto ack = ipc::GetAck(respBuf.data());
                          if (ack && ack->ok()) {
                              g_sentRefCache[key] = true;
                              cached = true;
                          }
                      }
                  }
             }

             if (cached) {
                 auto keyOff = builder.CreateString(key);
                 auto val = ipc::types::CreateRefCache(builder, keyOff);
                 return ipc::types::CreateAny(builder, ipc::types::AnyValue_RefCache, val.Union());
             }
        }

        XLOPER12 xMulti;
        int ret = Excel12(xlCoerce, &xMulti, 2, op, TempInt12(xltypeMulti));
        if (ret == xlretSuccess) {
             auto anyOff = ConvertMultiToAny(xMulti, builder);
             Excel12(xlFree, 0, 1, &xMulti);
             return anyOff;
        }
    }

    auto nilVal = ipc::types::CreateNil(builder);
    return ipc::types::CreateAny(builder, ipc::types::AnyValue_Nil, nilVal.Union());
}

// Guest Call Handler (Async Return)
int32_t GuestHandler(const uint8_t* req, uint8_t* resp, uint32_t msgId) {
    switch (msgId) {
    case MSG_CHUNK: { // Chunk (128)
        static std::map<uint64_t, std::vector<uint8_t>> asyncChunks;
        auto chunk = ipc::GetChunk(req);
        auto id = chunk->id();
        auto data = chunk->data();

        std::vector<uint8_t>& buf = asyncChunks[id];
        if (buf.empty()) buf.reserve(chunk->total_size());

        buf.insert(buf.end(), data->begin(), data->end());

        if (buf.size() >= chunk->total_size()) {
             uint32_t originalMsgId = chunk->msg_id();
             std::vector<uint8_t> fullPayload = buf;
             asyncChunks.erase(id);
             return GuestHandler(fullPayload.data(), resp, originalMsgId);
        }

        // Send Ack (MsgID 2) to request next
        flatbuffers::FlatBufferBuilder ackB(64);
        auto ack = ipc::CreateAck(ackB, id, true);
        ackB.Finish(ack);
        memcpy(resp, ackB.GetBufferPointer(), ackB.GetSize());
        return ackB.GetSize();
    }



    default:
        return 0;
    }
}

extern "C" {

__declspec(dllexport) int __stdcall xlAutoOpen() {
    // 1024 slots, 1MB size, 16 guest slots

    std::string shmName = "ProbeExperiment_" + std::to_string(GetCurrentProcessId());


    if (!g_host.Init(shmName.c_str(), 1024, 1024*1024, 16)) {
        return 0;
    }

    g_running = true;
    g_worker = std::thread([]{
        while(g_running) {
             int n = g_host.ProcessGuestCalls(GuestHandler);
             if (n == 0) std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }
    });

    static XLOPER12 xDll;
    Excel12(xlGetName, &xDll, 0);



    bool needCalcEnded = false;

    if (needCalcEnded) {
         Excel12(xlEventRegister, 0, 2, TempStr12(L"CalculationEnded"), TempInt12(xleventCalculationEnded));
    }



    {
        Excel12(xlfRegister, 0, 11,
            &xDll,
            TempStr12(L"ProbeString"),
            TempStr12(L"QD%$"),
            TempStr12(L"ProbeString"),
            TempStr12(L"s"),
            TempStr12(L"1"),
            TempStr12(L"ProbeExperiment"),
            TempStr12(L""),
            TempStr12(L""),
            TempStr12(L"Returns the pointer address of the input string argument"),
            TempStr12(L"")

        );
    }




    Excel12(xlFree, 0, 1, &xDll);
    return 1;
}

__declspec(dllexport) int __stdcall xlAutoClose() {
    g_running = false;
    if (g_worker.joinable()) g_worker.join();
    g_host.Shutdown();

    if (g_hChildProcess) {
        TerminateProcess(g_hChildProcess, 0);
        CloseHandle(g_hChildProcess);
        g_hChildProcess = NULL;
    }
    return 1;
}



__declspec(dllexport) void __stdcall CalculationEnded() {
    {
        std::lock_guard<std::mutex> lock(g_refCacheMutex);
        g_sentRefCache.clear();
    }
    auto slot = g_host.GetZeroCopySlot();
    slot.Send(MSG_CALCULATION_ENDED, 0);
}



__declspec(dllexport) LPXLOPER12 __stdcall ProbeString(const wchar_t* s) {
    std::wstringstream ss;
    ss << L"0x" << std::hex << (uintptr_t)s;
    return NewExcelString(ss.str().c_str());
}


} // extern "C"
