// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_IPC_H_
#define FLATBUFFERS_GENERATED_SCHEMA_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

#include "xltypes_generated.h"

namespace ipc {

struct Ack;
struct AckBuilder;

struct Chunk;
struct ChunkBuilder;

struct SetRefCacheRequest;
struct SetRefCacheRequestBuilder;

struct ProbeStringRequest;
struct ProbeStringRequestBuilder;

struct ProbeStringResponse;
struct ProbeStringResponseBuilder;

struct Ack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OK = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool ok() const {
    return GetField<uint8_t>(VT_OK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           verifier.EndTable();
  }
};

struct AckBuilder {
  typedef Ack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Ack::VT_ID, id, 0);
  }
  void add_ok(bool ok) {
    fbb_.AddElement<uint8_t>(Ack::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit AckBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Ack> CreateAck(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    bool ok = false) {
  AckBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOTAL_SIZE = 6,
    VT_OFFSET = 8,
    VT_DATA = 10,
    VT_MSG_ID = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint32_t total_size() const {
    return GetField<uint32_t>(VT_TOTAL_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  uint32_t msg_id() const {
    return GetField<uint32_t>(VT_MSG_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint32_t>(verifier, VT_MSG_ID, 4) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Chunk::VT_ID, id, 0);
  }
  void add_total_size(uint32_t total_size) {
    fbb_.AddElement<uint32_t>(Chunk::VT_TOTAL_SIZE, total_size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(Chunk::VT_OFFSET, offset, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Chunk::VT_DATA, data);
  }
  void add_msg_id(uint32_t msg_id) {
    fbb_.AddElement<uint32_t>(Chunk::VT_MSG_ID, msg_id, 0);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0,
    uint32_t msg_id = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_msg_id(msg_id);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_total_size(total_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chunk> CreateChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint32_t total_size = 0,
    uint32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    uint32_t msg_id = 0) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return ipc::CreateChunk(
      _fbb,
      id,
      total_size,
      offset,
      data__,
      msg_id);
}

struct SetRefCacheRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetRefCacheRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ipc::types::Any *val() const {
    return GetPointer<const ipc::types::Any *>(VT_VAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyTable(val()) &&
           verifier.EndTable();
  }
};

struct SetRefCacheRequestBuilder {
  typedef SetRefCacheRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(SetRefCacheRequest::VT_KEY, key);
  }
  void add_val(::flatbuffers::Offset<ipc::types::Any> val) {
    fbb_.AddOffset(SetRefCacheRequest::VT_VAL, val);
  }
  explicit SetRefCacheRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetRefCacheRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetRefCacheRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<ipc::types::Any> val = 0) {
  SetRefCacheRequestBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SetRefCacheRequest> CreateSetRefCacheRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    ::flatbuffers::Offset<ipc::types::Any> val = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return ipc::CreateSetRefCacheRequest(
      _fbb,
      key__,
      val);
}

struct ProbeStringRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProbeStringRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4
  };
  const ::flatbuffers::String *s() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           verifier.EndTable();
  }
};

struct ProbeStringRequestBuilder {
  typedef ProbeStringRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_s(::flatbuffers::Offset<::flatbuffers::String> s) {
    fbb_.AddOffset(ProbeStringRequest::VT_S, s);
  }
  explicit ProbeStringRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProbeStringRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProbeStringRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProbeStringRequest> CreateProbeStringRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> s = 0) {
  ProbeStringRequestBuilder builder_(_fbb);
  builder_.add_s(s);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProbeStringRequest> CreateProbeStringRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr) {
  auto s__ = s ? _fbb.CreateString(s) : 0;
  return ipc::CreateProbeStringRequest(
      _fbb,
      s__);
}

struct ProbeStringResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProbeStringResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_ERROR = 6
  };
  const ::flatbuffers::String *result() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESULT);
  }
  const ::flatbuffers::String *error() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyString(result()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct ProbeStringResponseBuilder {
  typedef ProbeStringResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(::flatbuffers::Offset<::flatbuffers::String> result) {
    fbb_.AddOffset(ProbeStringResponse::VT_RESULT, result);
  }
  void add_error(::flatbuffers::Offset<::flatbuffers::String> error) {
    fbb_.AddOffset(ProbeStringResponse::VT_ERROR, error);
  }
  explicit ProbeStringResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProbeStringResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProbeStringResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ProbeStringResponse> CreateProbeStringResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> result = 0,
    ::flatbuffers::Offset<::flatbuffers::String> error = 0) {
  ProbeStringResponseBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_result(result);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProbeStringResponse> CreateProbeStringResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *result = nullptr,
    const char *error = nullptr) {
  auto result__ = result ? _fbb.CreateString(result) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return ipc::CreateProbeStringResponse(
      _fbb,
      result__,
      error__);
}

inline const ipc::Chunk *GetChunk(const void *buf) {
  return ::flatbuffers::GetRoot<ipc::Chunk>(buf);
}

inline const ipc::Chunk *GetSizePrefixedChunk(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ipc::Chunk>(buf);
}

inline const char *ChunkIdentifier() {
  return "XCHN";
}

inline bool ChunkBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ChunkIdentifier());
}

inline bool SizePrefixedChunkBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ChunkIdentifier(), true);
}

inline bool VerifyChunkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ipc::Chunk>(ChunkIdentifier());
}

inline bool VerifySizePrefixedChunkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ipc::Chunk>(ChunkIdentifier());
}

inline void FinishChunkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ipc::Chunk> root) {
  fbb.Finish(root, ChunkIdentifier());
}

inline void FinishSizePrefixedChunkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ipc::Chunk> root) {
  fbb.FinishSizePrefixed(root, ChunkIdentifier());
}

}  // namespace ipc

#endif  // FLATBUFFERS_GENERATED_SCHEMA_IPC_H_
